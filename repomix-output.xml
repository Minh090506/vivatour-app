This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/__tests__/api/operator-approvals.test.ts
src/__tests__/api/operator-lock.test.ts
src/__tests__/api/operator-reports.test.ts
src/__tests__/api/reports.test.ts
src/__tests__/api/supplier-transactions.test.ts
src/__tests__/api/suppliers.test.ts
src/__tests__/config/operator-config.test.ts
src/__tests__/config/supplier-config.test.ts
src/__tests__/lib/id-utils.test.ts
src/__tests__/lib/lock-utils.test.ts
src/__tests__/lib/report-utils.test.ts
src/__tests__/lib/report-validation.test.ts
src/__tests__/lib/request-utils.test.ts
src/__tests__/lib/sheet-mappers.test.ts
src/__tests__/lib/supplier-balance.test.ts
src/app/(dashboard)/layout.tsx
src/app/(dashboard)/operators/[id]/error.tsx
src/app/(dashboard)/operators/[id]/page.tsx
src/app/(dashboard)/operators/approvals/error.tsx
src/app/(dashboard)/operators/approvals/page.tsx
src/app/(dashboard)/operators/create/error.tsx
src/app/(dashboard)/operators/create/page.tsx
src/app/(dashboard)/operators/error.tsx
src/app/(dashboard)/operators/page.tsx
src/app/(dashboard)/operators/reports/error.tsx
src/app/(dashboard)/operators/reports/page.tsx
src/app/(dashboard)/page.tsx
src/app/(dashboard)/reports/page.tsx
src/app/(dashboard)/requests/[id]/edit/error.tsx
src/app/(dashboard)/requests/[id]/edit/page.tsx
src/app/(dashboard)/requests/[id]/error.tsx
src/app/(dashboard)/requests/[id]/page.tsx
src/app/(dashboard)/requests/create/error.tsx
src/app/(dashboard)/requests/create/page.tsx
src/app/(dashboard)/requests/error.tsx
src/app/(dashboard)/requests/page.tsx
src/app/(dashboard)/revenues/page.tsx
src/app/(dashboard)/settings/page.tsx
src/app/(dashboard)/suppliers/[id]/page.tsx
src/app/(dashboard)/suppliers/create/page.tsx
src/app/(dashboard)/suppliers/page.tsx
src/app/(dashboard)/suppliers/reports/page.tsx
src/app/api/auth/[...nextauth]/route.ts
src/app/api/config/follow-up-statuses/[id]/route.ts
src/app/api/config/follow-up-statuses/reorder/route.ts
src/app/api/config/follow-up-statuses/route.ts
src/app/api/config/follow-up/route.ts
src/app/api/config/sellers/[id]/route.ts
src/app/api/config/sellers/route.ts
src/app/api/config/user/me/route.ts
src/app/api/config/user/route.ts
src/app/api/operators/[id]/approve/route.ts
src/app/api/operators/[id]/lock/route.ts
src/app/api/operators/[id]/route.ts
src/app/api/operators/[id]/unlock/route.ts
src/app/api/operators/approve/route.ts
src/app/api/operators/archive/route.ts
src/app/api/operators/lock-period/route.ts
src/app/api/operators/pending-payments/route.ts
src/app/api/operators/route.ts
src/app/api/operators/unarchive/route.ts
src/app/api/reports/cost-breakdown/route.ts
src/app/api/reports/dashboard/route.ts
src/app/api/reports/funnel/route.ts
src/app/api/reports/operator-costs/route.ts
src/app/api/reports/operator-payments/route.ts
src/app/api/reports/profit/route.ts
src/app/api/reports/revenue-trend/route.ts
src/app/api/reports/supplier-balance/route.ts
src/app/api/requests/[id]/route.ts
src/app/api/requests/route.ts
src/app/api/revenues/[id]/history/route.ts
src/app/api/revenues/[id]/lock/route.ts
src/app/api/revenues/[id]/route.ts
src/app/api/revenues/[id]/unlock/route.ts
src/app/api/revenues/route.ts
src/app/api/revenues/sales/route.ts
src/app/api/supplier-transactions/[id]/route.ts
src/app/api/supplier-transactions/route.ts
src/app/api/suppliers/[id]/route.ts
src/app/api/suppliers/generate-code/route.ts
src/app/api/suppliers/route.ts
src/app/api/sync/sheets/route.ts
src/app/api/users/route.ts
src/app/favicon.ico
src/app/forbidden/page.tsx
src/app/globals.css
src/app/layout.tsx
src/app/login/__tests__/login-form.test.tsx
src/app/login/__tests__/login-validation.test.ts
src/app/login/__tests__/page.test.tsx
src/app/login/login-form.tsx
src/app/login/page.tsx
src/auth.config.ts
src/auth.ts
src/components/dashboard/follow-up-widget.tsx
src/components/layout/AIAssistant.tsx
src/components/layout/Header.tsx
src/components/layouts/index.ts
src/components/layouts/master-detail-layout.tsx
src/components/layouts/slide-in-panel.tsx
src/components/operators/approval-summary-cards.tsx
src/components/operators/index.ts
src/components/operators/lock-indicator.tsx
src/components/operators/operator-approval-table.tsx
src/components/operators/operator-form.tsx
src/components/operators/operator-history-panel.tsx
src/components/operators/operator-list-filters.tsx
src/components/operators/operator-lock-dialog.tsx
src/components/operators/operator-lock-tier-badge.tsx
src/components/operators/reports/cost-by-service-chart.tsx
src/components/operators/reports/cost-by-supplier-table.tsx
src/components/operators/reports/monthly-trend.tsx
src/components/operators/reports/payment-status-cards.tsx
src/components/operators/reports/profit-chart.tsx
src/components/operators/reports/profit-report-table.tsx
src/components/providers/index.ts
src/components/providers/session-provider-wrapper.tsx
src/components/reports/cost-breakdown-chart.tsx
src/components/reports/date-range-selector.tsx
src/components/reports/funnel-chart.tsx
src/components/reports/kpi-cards.tsx
src/components/reports/revenue-trend-chart.tsx
src/components/requests/index.ts
src/components/requests/request-detail-panel.tsx
src/components/requests/request-filters.tsx
src/components/requests/request-form.tsx
src/components/requests/request-list-item.tsx
src/components/requests/request-list-panel.tsx
src/components/requests/request-services-table.tsx
src/components/requests/request-status-badge.tsx
src/components/requests/request-table.tsx
src/components/revenues/index.ts
src/components/revenues/revenue-form.tsx
src/components/revenues/revenue-history-panel.tsx
src/components/revenues/revenue-lock-dialog.tsx
src/components/revenues/revenue-summary-card.tsx
src/components/revenues/revenue-table.tsx
src/components/revenues/sales-summary-table.tsx
src/components/settings/followup-status-form-modal.tsx
src/components/settings/followup-status-table.tsx
src/components/settings/google-sheets-sync.tsx
src/components/settings/index.ts
src/components/settings/seller-form-modal.tsx
src/components/settings/seller-table.tsx
src/components/shared/lock-tier-badge.tsx
src/components/suppliers/edit-supplier-modal.tsx
src/components/suppliers/supplier-form.tsx
src/components/suppliers/supplier-selector.tsx
src/components/suppliers/transaction-form.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/alert.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/checkbox.tsx
src/components/ui/command.tsx
src/components/ui/currency-input.tsx
src/components/ui/dialog.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/error-fallback.tsx
src/components/ui/form.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/popover.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/sheet.tsx
src/components/ui/skeleton.tsx
src/components/ui/sonner.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/components/ui/tooltip.tsx
src/config/lock-config.ts
src/config/operator-config.ts
src/config/request-config.ts
src/config/revenue-config.ts
src/config/supplier-config.ts
src/hooks/index.ts
src/hooks/use-permission.ts
src/hooks/use-reports.ts
src/lib/__mocks__/auth-utils.ts
src/lib/__mocks__/db.ts
src/lib/api/fetch-utils.ts
src/lib/auth-utils.ts
src/lib/db.ts
src/lib/google-sheets.ts
src/lib/id-utils.ts
src/lib/lock-utils.ts
src/lib/logger.ts
src/lib/operator-history.ts
src/lib/operator-validation.ts
src/lib/permissions.ts
src/lib/report-utils.ts
src/lib/request-utils.ts
src/lib/revenue-history.ts
src/lib/sheet-mappers.ts
src/lib/supplier-balance.ts
src/lib/sync/__tests__/write-back-queue.test.ts
src/lib/sync/write-back-queue.ts
src/lib/utils.ts
src/lib/utils/parse-utils.ts
src/lib/validations/config-validation.ts
src/lib/validations/operator-validation.ts
src/lib/validations/report-validation.ts
src/lib/validations/request-validation.ts
src/lib/validations/revenue-validation.ts
src/lib/validations/seller-validation.ts
src/proxy.ts
src/types/index.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/__tests__/api/operator-reports.test.ts">
/**
 * @jest-environment node
 */

// Tests for Operator Reports API routes
// Covers: GET /api/reports/operator-costs, GET /api/reports/operator-payments

import { NextRequest } from 'next/server';
import { prismaMock } from '@/lib/__mocks__/db';

// Mock the db module
jest.mock('@/lib/db', () => ({
  prisma: prismaMock,
}));

import { GET as getCostReport } from '@/app/api/reports/operator-costs/route';
import { GET as getPaymentReport } from '@/app/api/reports/operator-payments/route';

// Helper to create mock NextRequest
function createMockRequest(url: string): NextRequest {
  return new NextRequest(new URL(url, 'http://localhost:3000'));
}

describe('GET /api/reports/operator-costs', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return cost report grouped by service type, supplier, and month', async () => {
    const mockOperators = [
      {
        id: 'op1',
        serviceType: 'HOTEL',
        supplierId: 'sup1',
        supplier: null,
        serviceDate: new Date('2026-01-15'),
        totalCost: 5000000,
        supplierRef: { name: 'Khách sạn ABC' },
        request: { code: 'REQ001' },
      },
      {
        id: 'op2',
        serviceType: 'TRANSPORT',
        supplierId: 'sup2',
        supplier: null,
        serviceDate: new Date('2026-01-20'),
        totalCost: 2000000,
        supplierRef: { name: 'Xe du lịch XYZ' },
        request: { code: 'REQ001' },
      },
      {
        id: 'op3',
        serviceType: 'HOTEL',
        supplierId: 'sup1',
        supplier: null,
        serviceDate: new Date('2026-02-10'),
        totalCost: 3000000,
        supplierRef: { name: 'Khách sạn ABC' },
        request: { code: 'REQ002' },
      },
    ];

    prismaMock.operator.findMany.mockResolvedValue(mockOperators as never);

    const request = createMockRequest('http://localhost:3000/api/reports/operator-costs');
    const response = await getCostReport(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);

    // Check summary
    expect(data.data.summary.totalCost).toBe(10000000);
    expect(data.data.summary.totalCount).toBe(3);
    expect(data.data.summary.avgCost).toBe(3333333);

    // Check by service type - should have HOTEL and TRANSPORT
    expect(data.data.byServiceType).toHaveLength(2);
    const hotelType = data.data.byServiceType.find((t: { type: string }) => t.type === 'HOTEL');
    expect(hotelType.total).toBe(8000000);
    expect(hotelType.count).toBe(2);

    // Check by supplier
    expect(data.data.bySupplier).toHaveLength(2);

    // Check by month
    expect(data.data.byMonth).toHaveLength(2);
  });

  it('should filter by date range', async () => {
    prismaMock.operator.findMany.mockResolvedValue([] as never);

    const request = createMockRequest(
      'http://localhost:3000/api/reports/operator-costs?fromDate=2026-01-01&toDate=2026-01-31'
    );
    const response = await getCostReport(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(prismaMock.operator.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          serviceDate: expect.objectContaining({
            gte: expect.any(Date),
            lte: expect.any(Date),
          }),
        }),
      })
    );
  });

  it('should filter by service type', async () => {
    prismaMock.operator.findMany.mockResolvedValue([] as never);

    const request = createMockRequest(
      'http://localhost:3000/api/reports/operator-costs?serviceType=HOTEL'
    );
    const response = await getCostReport(request);

    expect(response.status).toBe(200);
    expect(prismaMock.operator.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          serviceType: 'HOTEL',
        }),
      })
    );
  });

  it('should handle empty data gracefully', async () => {
    prismaMock.operator.findMany.mockResolvedValue([] as never);

    const request = createMockRequest('http://localhost:3000/api/reports/operator-costs');
    const response = await getCostReport(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.summary.totalCost).toBe(0);
    expect(data.data.summary.totalCount).toBe(0);
    expect(data.data.summary.avgCost).toBe(0);
    expect(data.data.byServiceType).toHaveLength(0);
    expect(data.data.bySupplier).toHaveLength(0);
    expect(data.data.byMonth).toHaveLength(0);
  });

  it('should handle database errors', async () => {
    prismaMock.operator.findMany.mockRejectedValue(new Error('Database error') as never);

    const request = createMockRequest('http://localhost:3000/api/reports/operator-costs');
    const response = await getCostReport(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Lỗi tạo báo cáo');
  });

  it('should reject invalid date format', async () => {
    const request = createMockRequest(
      'http://localhost:3000/api/reports/operator-costs?fromDate=invalid-date'
    );
    const response = await getCostReport(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Ngày bắt đầu không hợp lệ');
  });

  it('should reject invalid service type', async () => {
    const request = createMockRequest(
      'http://localhost:3000/api/reports/operator-costs?serviceType=INVALID_TYPE'
    );
    const response = await getCostReport(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Loại dịch vụ không hợp lệ');
  });
});

describe('GET /api/reports/operator-payments', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return payment status summary', async () => {
    // Mock aggregate calls
    prismaMock.operator.aggregate
      .mockResolvedValueOnce({ _count: { id: 5 }, _sum: { totalCost: 10000000 } } as never)  // pending
      .mockResolvedValueOnce({ _count: { id: 2 }, _sum: { totalCost: 4000000 } } as never)   // dueThisWeek
      .mockResolvedValueOnce({ _count: { id: 1 }, _sum: { totalCost: 2000000 } } as never)   // overdue
      .mockResolvedValueOnce({ _count: { id: 3 }, _sum: { totalCost: 6000000 } } as never);  // paidThisMonth

    const request = createMockRequest('http://localhost:3000/api/reports/operator-payments');
    const response = await getPaymentReport(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.pending.count).toBe(5);
    expect(data.data.pending.total).toBe(10000000);
    expect(data.data.dueThisWeek.count).toBe(2);
    expect(data.data.dueThisWeek.total).toBe(4000000);
    expect(data.data.overdue.count).toBe(1);
    expect(data.data.overdue.total).toBe(2000000);
    expect(data.data.paidThisMonth.count).toBe(3);
    expect(data.data.paidThisMonth.total).toBe(6000000);
  });

  it('should handle null totals gracefully', async () => {
    prismaMock.operator.aggregate
      .mockResolvedValueOnce({ _count: { id: 0 }, _sum: { totalCost: null } } as never)
      .mockResolvedValueOnce({ _count: { id: 0 }, _sum: { totalCost: null } } as never)
      .mockResolvedValueOnce({ _count: { id: 0 }, _sum: { totalCost: null } } as never)
      .mockResolvedValueOnce({ _count: { id: 0 }, _sum: { totalCost: null } } as never);

    const request = createMockRequest('http://localhost:3000/api/reports/operator-payments');
    const response = await getPaymentReport(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.pending.count).toBe(0);
    expect(data.data.pending.total).toBe(0);
  });

  it('should handle database errors', async () => {
    prismaMock.operator.aggregate.mockRejectedValue(new Error('Database error') as never);

    const request = createMockRequest('http://localhost:3000/api/reports/operator-payments');
    const response = await getPaymentReport(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Lỗi tạo báo cáo');
  });

  it('should reject invalid month format', async () => {
    const request = createMockRequest(
      'http://localhost:3000/api/reports/operator-payments?month=2026-13'
    );
    const response = await getPaymentReport(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Định dạng tháng không hợp lệ');
  });
});
</file>

<file path="src/__tests__/config/supplier-config.test.ts">
/**
 * @jest-environment node
 */

// Tests for supplier configuration and code generation
// Covers: generateSupplierCode, getNamePrefix, removeDiacritics

import {
  SUPPLIER_TYPES,
  SUPPLIER_LOCATIONS,
  PAYMENT_MODELS,
  SUPPLIER_TYPE_KEYS,
  SUPPLIER_LOCATION_KEYS,
  generateSupplierCode,
  removeDiacritics,
  getNamePrefix,
} from '@/config/supplier-config';

describe('SUPPLIER_TYPES configuration', () => {
  it('should have 9 supplier types', () => {
    expect(SUPPLIER_TYPE_KEYS).toHaveLength(9);
  });

  it('should have 3-character prefixes for all types', () => {
    SUPPLIER_TYPE_KEYS.forEach((key) => {
      expect(SUPPLIER_TYPES[key].prefix).toHaveLength(3);
    });
  });

  it('should include all expected types', () => {
    expect(SUPPLIER_TYPE_KEYS).toContain('HOTEL');
    expect(SUPPLIER_TYPE_KEYS).toContain('RESTAURANT');
    expect(SUPPLIER_TYPE_KEYS).toContain('TRANSPORT');
    expect(SUPPLIER_TYPE_KEYS).toContain('GUIDE');
    expect(SUPPLIER_TYPE_KEYS).toContain('VISA');
    expect(SUPPLIER_TYPE_KEYS).toContain('VMB');
    expect(SUPPLIER_TYPE_KEYS).toContain('CRUISE');
    expect(SUPPLIER_TYPE_KEYS).toContain('ACTIVITY');
    expect(SUPPLIER_TYPE_KEYS).toContain('OTHER');
  });

  it('should have correct prefix mappings', () => {
    expect(SUPPLIER_TYPES.HOTEL.prefix).toBe('HOT');
    expect(SUPPLIER_TYPES.RESTAURANT.prefix).toBe('RES');
    expect(SUPPLIER_TYPES.TRANSPORT.prefix).toBe('TRA');
    expect(SUPPLIER_TYPES.VMB.prefix).toBe('VMB');
    expect(SUPPLIER_TYPES.OTHER.prefix).toBe('OTH');
  });
});

describe('SUPPLIER_LOCATIONS configuration', () => {
  it('should have 18 locations', () => {
    expect(SUPPLIER_LOCATION_KEYS).toHaveLength(18);
  });

  it('should have 2-3 character prefixes for all locations', () => {
    SUPPLIER_LOCATION_KEYS.forEach((key) => {
      const prefix = SUPPLIER_LOCATIONS[key].prefix;
      expect(prefix.length).toBeGreaterThanOrEqual(2);
      expect(prefix.length).toBeLessThanOrEqual(3);
    });
  });

  it('should include key Vietnam locations', () => {
    expect(SUPPLIER_LOCATION_KEYS).toContain('HA_NOI');
    expect(SUPPLIER_LOCATION_KEYS).toContain('HO_CHI_MINH');
    expect(SUPPLIER_LOCATION_KEYS).toContain('DA_NANG');
    expect(SUPPLIER_LOCATION_KEYS).toContain('HA_LONG');
  });

  it('should include international locations', () => {
    expect(SUPPLIER_LOCATION_KEYS).toContain('THAI_LAN');
    expect(SUPPLIER_LOCATION_KEYS).toContain('CAMBODIA');
    expect(SUPPLIER_LOCATION_KEYS).toContain('LAO');
  });
});

describe('PAYMENT_MODELS configuration', () => {
  it('should have 3 payment models', () => {
    expect(Object.keys(PAYMENT_MODELS)).toHaveLength(3);
  });

  it('should include all expected models', () => {
    expect(PAYMENT_MODELS).toHaveProperty('PREPAID');
    expect(PAYMENT_MODELS).toHaveProperty('PAY_PER_USE');
    expect(PAYMENT_MODELS).toHaveProperty('CREDIT');
  });

  it('should have labels and descriptions', () => {
    Object.values(PAYMENT_MODELS).forEach((model) => {
      expect(model.label).toBeDefined();
      expect(model.description).toBeDefined();
    });
  });
});

describe('removeDiacritics', () => {
  it('should remove Vietnamese diacritics from A variants', () => {
    expect(removeDiacritics('ÀÁẢÃẠ')).toBe('AAAAA');
    expect(removeDiacritics('ẰẮẲẴẶ')).toBe('AAAAA');
    expect(removeDiacritics('ẦẤẨẪẬ')).toBe('AAAAA');
  });

  it('should remove Vietnamese diacritics from E variants', () => {
    expect(removeDiacritics('ÈÉẺẼẸ')).toBe('EEEEE');
    expect(removeDiacritics('ỀẾỂỄỆ')).toBe('EEEEE');
  });

  it('should remove Vietnamese diacritics from I variants', () => {
    expect(removeDiacritics('ÌÍỈĨỊ')).toBe('IIIII');
  });

  it('should remove Vietnamese diacritics from O variants', () => {
    expect(removeDiacritics('ÒÓỎÕỌ')).toBe('OOOOO');
    expect(removeDiacritics('ỒỐỔỖỘ')).toBe('OOOOO');
    expect(removeDiacritics('ỜỚỞỠỢ')).toBe('OOOOO');
  });

  it('should remove Vietnamese diacritics from U variants', () => {
    expect(removeDiacritics('ÙÚỦŨỤ')).toBe('UUUUU');
    expect(removeDiacritics('ỪỨỬỮỰ')).toBe('UUUUU');
  });

  it('should remove Vietnamese diacritics from Y variants', () => {
    expect(removeDiacritics('ỲÝỶỸỴ')).toBe('YYYYY');
  });

  it('should convert Đ to D', () => {
    expect(removeDiacritics('Đ')).toBe('D');
    expect(removeDiacritics('ĐÀ NẴNG')).toBe('DA NANG');
  });

  it('should preserve non-diacritic characters', () => {
    expect(removeDiacritics('ABC123')).toBe('ABC123');
    expect(removeDiacritics('HELLO')).toBe('HELLO');
  });

  it('should handle mixed strings', () => {
    expect(removeDiacritics('HÀ NỘI')).toBe('HA NOI');
    expect(removeDiacritics('HỒ CHÍ MINH')).toBe('HO CHI MINH');
    expect(removeDiacritics('PHÚ QUỐC')).toBe('PHU QUOC');
  });

  it('should handle empty string', () => {
    expect(removeDiacritics('')).toBe('');
  });
});

describe('getNamePrefix', () => {
  it('should extract first 3 characters from simple name', () => {
    expect(getNamePrefix('HOTEL')).toBe('HOT');
    expect(getNamePrefix('RESTAURANT')).toBe('RES');
  });

  it('should use first word only', () => {
    expect(getNamePrefix('GRAND HOTEL SAIGON')).toBe('GRA');
    expect(getNamePrefix('MY LINH TOURS')).toBe('MYX'); // 2 chars + X padding
  });

  it('should handle Vietnamese names with diacritics', () => {
    expect(getNamePrefix('Đại Việt')).toBe('DAI');
    expect(getNamePrefix('Hồng Hà')).toBe('HON');
    expect(getNamePrefix('Phú Quốc Resort')).toBe('PHU');
  });

  it('should pad short names with X', () => {
    expect(getNamePrefix('AB')).toBe('ABX');
    expect(getNamePrefix('A')).toBe('AXX');
  });

  it('should return XXX for empty name', () => {
    expect(getNamePrefix('')).toBe('XXX');
  });

  it('should return XXX for null/undefined', () => {
    expect(getNamePrefix(null as unknown as string)).toBe('XXX');
    expect(getNamePrefix(undefined as unknown as string)).toBe('XXX');
  });

  it('should trim whitespace', () => {
    expect(getNamePrefix('  HOTEL ABC  ')).toBe('HOT');
  });

  it('should convert to uppercase', () => {
    expect(getNamePrefix('hotel')).toBe('HOT');
    expect(getNamePrefix('Hotel Saigon')).toBe('HOT');
  });
});

describe('generateSupplierCode', () => {
  it('should generate correct code format: TYPE-LOCATION-NAME-SEQUENCE', () => {
    const code = generateSupplierCode('HOTEL', 'Ankora Hotel', 'DA_NANG', 2);
    expect(code).toBe('HOT-DN-ANK-0002');
  });

  it('should use XX for missing location', () => {
    const code = generateSupplierCode('HOTEL', 'Ankora Hotel', null, 1);
    expect(code).toBe('HOT-XX-ANK-0001');
  });

  it('should use XX for undefined location', () => {
    const code = generateSupplierCode('HOTEL', 'Ankora Hotel', undefined, 1);
    expect(code).toBe('HOT-XX-ANK-0001');
  });

  it('should pad sequence to 4 digits', () => {
    expect(generateSupplierCode('HOTEL', 'Test', 'HA_NOI', 1)).toContain('-0001');
    expect(generateSupplierCode('HOTEL', 'Test', 'HA_NOI', 99)).toContain('-0099');
    expect(generateSupplierCode('HOTEL', 'Test', 'HA_NOI', 999)).toContain('-0999');
    expect(generateSupplierCode('HOTEL', 'Test', 'HA_NOI', 9999)).toContain('-9999');
  });

  it('should default sequence to 1', () => {
    const code = generateSupplierCode('HOTEL', 'Test Hotel', 'HA_NOI');
    expect(code).toBe('HOT-HN-TES-0001');
  });

  describe('for each supplier type', () => {
    const testCases: Array<{ type: keyof typeof SUPPLIER_TYPES; expectedPrefix: string }> = [
      { type: 'HOTEL', expectedPrefix: 'HOT' },
      { type: 'RESTAURANT', expectedPrefix: 'RES' },
      { type: 'TRANSPORT', expectedPrefix: 'TRA' },
      { type: 'GUIDE', expectedPrefix: 'GUI' },
      { type: 'VISA', expectedPrefix: 'VIS' },
      { type: 'VMB', expectedPrefix: 'VMB' },
      { type: 'CRUISE', expectedPrefix: 'CRU' },
      { type: 'ACTIVITY', expectedPrefix: 'ACT' },
      { type: 'OTHER', expectedPrefix: 'OTH' },
    ];

    testCases.forEach(({ type, expectedPrefix }) => {
      it(`should use ${expectedPrefix} for ${type}`, () => {
        const code = generateSupplierCode(type, 'Test', 'HA_NOI', 1);
        expect(code.startsWith(expectedPrefix)).toBe(true);
      });
    });
  });

  describe('for each location', () => {
    const locationTests: Array<{ location: keyof typeof SUPPLIER_LOCATIONS; expectedPrefix: string }> = [
      { location: 'HA_NOI', expectedPrefix: 'HN' },
      { location: 'DA_NANG', expectedPrefix: 'DN' },
      { location: 'HO_CHI_MINH', expectedPrefix: 'HCM' },
      { location: 'HA_LONG', expectedPrefix: 'HL' },
      { location: 'PHU_QUOC', expectedPrefix: 'PQ' },
      { location: 'THAI_LAN', expectedPrefix: 'TL' },
      { location: 'CAMBODIA', expectedPrefix: 'CB' },
    ];

    locationTests.forEach(({ location, expectedPrefix }) => {
      it(`should use ${expectedPrefix} for ${location}`, () => {
        const code = generateSupplierCode('HOTEL', 'Test', location, 1);
        expect(code).toContain(`-${expectedPrefix}-`);
      });
    });
  });

  it('should handle Vietnamese names correctly', () => {
    const code = generateSupplierCode('HOTEL', 'Đại Việt Hotel', 'DA_NANG', 5);
    expect(code).toBe('HOT-DN-DAI-0005');
  });

  it('should handle single character name', () => {
    const code = generateSupplierCode('HOTEL', 'A', 'HA_NOI', 1);
    expect(code).toBe('HOT-HN-AXX-0001');
  });

  it('should handle empty name', () => {
    const code = generateSupplierCode('HOTEL', '', 'HA_NOI', 1);
    expect(code).toBe('HOT-HN-XXX-0001');
  });

  it('should handle name with only spaces', () => {
    const code = generateSupplierCode('HOTEL', '   ', 'HA_NOI', 1);
    expect(code).toBe('HOT-HN-XXX-0001');
  });

  it('should handle multi-word names (use first word only)', () => {
    const code = generateSupplierCode('RESTAURANT', 'PHO 24 RESTAURANT', 'HO_CHI_MINH', 3);
    expect(code).toBe('RES-HCM-PHO-0003');
  });
});
</file>

<file path="src/__tests__/lib/supplier-balance.test.ts">
/**
 * @jest-environment node
 */

// Tests for supplier balance calculation logic
// Covers: calculateSupplierBalance, getSupplierBalanceSummary

import { prismaMock } from '@/lib/__mocks__/db';

// Mock the db module before importing the module under test
jest.mock('@/lib/db', () => ({
  prisma: prismaMock,
}));

import { calculateSupplierBalance, getSupplierBalanceSummary } from '@/lib/supplier-balance';

describe('calculateSupplierBalance', () => {
  const testSupplierId = 'supplier-123';

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should calculate balance correctly with all transaction types', async () => {
    // Mock transaction groupBy results
    prismaMock.supplierTransaction.groupBy.mockResolvedValue([
      { type: 'DEPOSIT', _sum: { amount: 10000000 }, _count: { _all: 1 } },
      { type: 'REFUND', _sum: { amount: 500000 }, _count: { _all: 1 } },
      { type: 'ADJUSTMENT', _sum: { amount: 200000 }, _count: { _all: 1 } },
      { type: 'FEE', _sum: { amount: 100000 }, _count: { _all: 1 } },
    ] as never);

    // Mock operator costs
    prismaMock.operator.aggregate.mockResolvedValue({
      _sum: { totalCost: 3000000 },
      _count: { _all: 2 },
      _avg: {},
      _min: {},
      _max: {},
    } as never);

    const result = await calculateSupplierBalance(testSupplierId);

    // Balance = 10,000,000 + 500,000 + 200,000 - 100,000 - 3,000,000 = 7,600,000
    expect(result).toEqual({
      deposits: 10000000,
      refunds: 500000,
      adjustments: 200000,
      fees: 100000,
      costs: 3000000,
      balance: 7600000,
    });
  });

  it('should handle zero transactions (new supplier)', async () => {
    prismaMock.supplierTransaction.groupBy.mockResolvedValue([] as never);
    prismaMock.operator.aggregate.mockResolvedValue({
      _sum: { totalCost: null },
      _count: { _all: 0 },
      _avg: {},
      _min: {},
      _max: {},
    } as never);

    const result = await calculateSupplierBalance(testSupplierId);

    expect(result).toEqual({
      deposits: 0,
      refunds: 0,
      adjustments: 0,
      fees: 0,
      costs: 0,
      balance: 0,
    });
  });

  it('should handle deposits only', async () => {
    prismaMock.supplierTransaction.groupBy.mockResolvedValue([
      { type: 'DEPOSIT', _sum: { amount: 5000000 }, _count: { _all: 1 } },
    ] as never);
    prismaMock.operator.aggregate.mockResolvedValue({
      _sum: { totalCost: null },
      _count: { _all: 0 },
      _avg: {},
      _min: {},
      _max: {},
    } as never);

    const result = await calculateSupplierBalance(testSupplierId);

    expect(result.deposits).toBe(5000000);
    expect(result.balance).toBe(5000000);
  });

  it('should calculate negative balance when costs exceed deposits', async () => {
    prismaMock.supplierTransaction.groupBy.mockResolvedValue([
      { type: 'DEPOSIT', _sum: { amount: 1000000 }, _count: { _all: 1 } },
    ] as never);
    prismaMock.operator.aggregate.mockResolvedValue({
      _sum: { totalCost: 3000000 },
      _count: { _all: 1 },
      _avg: {},
      _min: {},
      _max: {},
    } as never);

    const result = await calculateSupplierBalance(testSupplierId);

    expect(result.balance).toBe(-2000000); // 1M - 3M = -2M
  });

  it('should handle large numeric values', async () => {
    const largeDeposit = 999999999999999; // Near max for Decimal(15,0)

    prismaMock.supplierTransaction.groupBy.mockResolvedValue([
      { type: 'DEPOSIT', _sum: { amount: largeDeposit }, _count: { _all: 1 } },
    ] as never);
    prismaMock.operator.aggregate.mockResolvedValue({
      _sum: { totalCost: null },
      _count: { _all: 0 },
      _avg: {},
      _min: {},
      _max: {},
    } as never);

    const result = await calculateSupplierBalance(testSupplierId);

    expect(result.deposits).toBe(largeDeposit);
    expect(result.balance).toBe(largeDeposit);
  });

  it('should call Prisma with correct supplier ID', async () => {
    prismaMock.supplierTransaction.groupBy.mockResolvedValue([] as never);
    prismaMock.operator.aggregate.mockResolvedValue({
      _sum: { totalCost: null },
      _count: { _all: 0 },
      _avg: {},
      _min: {},
      _max: {},
    } as never);

    await calculateSupplierBalance(testSupplierId);

    expect(prismaMock.supplierTransaction.groupBy).toHaveBeenCalledWith({
      by: ['type'],
      where: { supplierId: testSupplierId },
      _sum: { amount: true },
    });

    expect(prismaMock.operator.aggregate).toHaveBeenCalledWith({
      where: { supplierId: testSupplierId },
      _sum: { totalCost: true },
    });
  });
});

describe('getSupplierBalanceSummary', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return balance summary for all active suppliers', async () => {
    const mockSuppliers = [
      { id: 'sup-1', code: 'HOT-DN-ABC-0001', name: 'Hotel A', type: 'HOTEL', paymentModel: 'PREPAID', isActive: true },
      { id: 'sup-2', code: 'RES-HN-XYZ-0001', name: 'Restaurant B', type: 'RESTAURANT', paymentModel: 'CREDIT', isActive: true },
    ];

    prismaMock.supplier.findMany.mockResolvedValue(mockSuppliers as never);

    // Mock balance calculations for each supplier
    prismaMock.supplierTransaction.groupBy
      .mockResolvedValueOnce([
        { type: 'DEPOSIT', _sum: { amount: 5000000 }, _count: { _all: 1 } },
      ] as never)
      .mockResolvedValueOnce([
        { type: 'DEPOSIT', _sum: { amount: 3000000 }, _count: { _all: 1 } },
      ] as never);

    prismaMock.operator.aggregate
      .mockResolvedValueOnce({
        _sum: { totalCost: 1000000 },
        _count: { _all: 1 },
        _avg: {},
        _min: {},
        _max: {},
      } as never)
      .mockResolvedValueOnce({
        _sum: { totalCost: 500000 },
        _count: { _all: 1 },
        _avg: {},
        _min: {},
        _max: {},
      } as never);

    const result = await getSupplierBalanceSummary();

    expect(result.summary.supplierCount).toBe(2);
    expect(result.summary.totalDeposits).toBe(8000000); // 5M + 3M
    expect(result.summary.totalCosts).toBe(1500000); // 1M + 500K
    expect(result.summary.positiveBalance).toBe(2); // Both have positive balance
    expect(result.summary.negativeBalance).toBe(0);
    expect(result.data).toHaveLength(2);
  });

  it('should filter by supplier type when provided', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([] as never);

    await getSupplierBalanceSummary('HOTEL');

    expect(prismaMock.supplier.findMany).toHaveBeenCalledWith({
      where: { isActive: true, type: 'HOTEL' },
      select: {
        id: true,
        code: true,
        name: true,
        type: true,
        paymentModel: true,
        isActive: true,
      },
      orderBy: { code: 'asc' },
    });
  });

  it('should return empty results for no active suppliers', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([] as never);

    const result = await getSupplierBalanceSummary();

    expect(result.summary.supplierCount).toBe(0);
    expect(result.summary.totalDeposits).toBe(0);
    expect(result.summary.totalCosts).toBe(0);
    expect(result.summary.totalBalance).toBe(0);
    expect(result.data).toEqual([]);
  });

  it('should count positive and negative balances correctly', async () => {
    const mockSuppliers = [
      { id: 'sup-1', code: 'HOT-DN-ABC-0001', name: 'Hotel A', type: 'HOTEL', paymentModel: 'PREPAID', isActive: true },
      { id: 'sup-2', code: 'RES-HN-XYZ-0001', name: 'Restaurant B', type: 'RESTAURANT', paymentModel: 'CREDIT', isActive: true },
      { id: 'sup-3', code: 'TRA-HN-DEF-0001', name: 'Transport C', type: 'TRANSPORT', paymentModel: 'PAY_PER_USE', isActive: true },
    ];

    prismaMock.supplier.findMany.mockResolvedValue(mockSuppliers as never);

    // Supplier 1: positive balance (2M deposits, 1M costs = 1M balance)
    prismaMock.supplierTransaction.groupBy
      .mockResolvedValueOnce([{ type: 'DEPOSIT', _sum: { amount: 2000000 }, _count: { _all: 1 } }] as never)
      // Supplier 2: negative balance (1M deposits, 3M costs = -2M balance)
      .mockResolvedValueOnce([{ type: 'DEPOSIT', _sum: { amount: 1000000 }, _count: { _all: 1 } }] as never)
      // Supplier 3: zero balance
      .mockResolvedValueOnce([] as never);

    prismaMock.operator.aggregate
      .mockResolvedValueOnce({ _sum: { totalCost: 1000000 }, _count: { _all: 1 }, _avg: {}, _min: {}, _max: {} } as never)
      .mockResolvedValueOnce({ _sum: { totalCost: 3000000 }, _count: { _all: 1 }, _avg: {}, _min: {}, _max: {} } as never)
      .mockResolvedValueOnce({ _sum: { totalCost: null }, _count: { _all: 0 }, _avg: {}, _min: {}, _max: {} } as never);

    const result = await getSupplierBalanceSummary();

    expect(result.summary.positiveBalance).toBe(1); // Only sup-1
    expect(result.summary.negativeBalance).toBe(1); // Only sup-2
    // sup-3 has 0 balance, not counted in either
  });
});
</file>

<file path="src/app/(dashboard)/operators/create/page.tsx">
'use client';

import { Suspense } from 'react';
import { useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { ArrowLeft, ClipboardList } from 'lucide-react';
import { OperatorForm } from '@/components/operators/operator-form';

function CreateOperatorContent() {
  const searchParams = useSearchParams();
  const requestId = searchParams.get('requestId') || undefined;

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="icon" asChild>
          <Link href="/operators">
            <ArrowLeft className="h-5 w-5" />
          </Link>
        </Button>
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <ClipboardList className="h-6 w-6" />
            Thêm dịch vụ mới
          </h1>
          <p className="text-muted-foreground">
            Tạo chi phí dịch vụ cho Booking
          </p>
        </div>
      </div>

      {/* Form */}
      <OperatorForm requestId={requestId} />
    </div>
  );
}

export default function CreateOperatorPage() {
  return (
    <Suspense fallback={<div className="text-center py-10">Đang tải...</div>}>
      <CreateOperatorContent />
    </Suspense>
  );
}
</file>

<file path="src/app/(dashboard)/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import {
  TrendingUp,
  TrendingDown,
  Users,
  Briefcase,
  DollarSign,
  AlertCircle,
  Mail,
  Calendar,
  ArrowRight,
  Clock,
  Phone,
  MailOpen,
} from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { FollowUpWidget } from '@/components/dashboard/follow-up-widget';

// Mock data - will be replaced with API calls
const mockStats = {
  totalRevenue: 125000000,
  totalCost: 89500000,
  newRequests: 23,
  activeBookings: 8,
  revenueChange: 12,
  costChange: 5,
  requestChange: 3,
  bookingChange: -2,
};

const mockFollowUps = [
  {
    id: '1',
    customerName: 'John Smith',
    country: 'USA',
    overdueDays: 5,
    status: 'F2',
    contact: 'john@gmail.com',
    source: 'TripAdvisor',
  },
  {
    id: '2',
    customerName: 'Mary Jane',
    country: 'UK',
    overdueDays: 3,
    status: 'F2',
    contact: 'mary@outlook.com',
    source: 'Email',
  },
  {
    id: '3',
    customerName: 'Tanaka Hiro',
    country: 'Japan',
    overdueDays: 2,
    status: 'F3',
    contact: 'tanaka@yahoo.jp',
    source: 'Agent',
  },
];

const mockEmails = [
  {
    id: '1',
    from: 'john@gmail.com',
    subject: 'Question about visa requirements',
    date: new Date(Date.now() - 2 * 60 * 60 * 1000),
    isRead: false,
    customerName: 'John Smith',
  },
  {
    id: '2',
    from: 'mary@outlook.com',
    subject: 'Booking confirmation needed',
    date: new Date(Date.now() - 5 * 60 * 60 * 1000),
    isRead: true,
    customerName: 'Mary Jane',
  },
  {
    id: '3',
    from: 'peter@yahoo.com',
    subject: 'Re: Itinerary update',
    date: new Date(Date.now() - 24 * 60 * 60 * 1000),
    isRead: true,
    customerName: 'Peter Parker',
  },
];

const mockActions = [
  { label: '5 khách quá hạn follow-up', type: 'warning', count: 5 },
  { label: '3 khoản cần thanh toán NCC', type: 'danger', count: 3 },
  { label: '2 email chưa reply (>24h)', type: 'info', count: 2 },
];

function formatCurrency(value: number): string {
  return new Intl.NumberFormat('vi-VN').format(value);
}

function formatTimeAgo(date: Date): string {
  const now = new Date();
  const diff = now.getTime() - date.getTime();
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const days = Math.floor(hours / 24);

  if (days > 0) return `${days} ngày trước`;
  if (hours > 0) return `${hours} giờ trước`;
  return 'Vừa xong';
}

function getGreeting(): string {
  const hour = new Date().getHours();
  if (hour < 12) return 'Chào buổi sáng';
  if (hour < 18) return 'Chào buổi chiều';
  return 'Chào buổi tối';
}

function formatCurrentDate(): string {
  return new Date().toLocaleDateString('vi-VN', {
    weekday: 'long',
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  });
}

export default function DashboardPage() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    setMounted(true);
  }, []);

  // Compute date only after mount to avoid hydration mismatch
  const displayDate = mounted ? formatCurrentDate() : '';

  return (
    <div className="space-y-6">
      {/* Greeting */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">
            {getGreeting()}, Minh!
          </h1>
          <p className="text-muted-foreground">
            Tổng quan hoạt động kinh doanh của bạn
          </p>
        </div>
        <div className="flex items-center gap-2 text-muted-foreground">
          <Calendar className="h-4 w-4" />
          <span className="text-sm">{displayDate}</span>
        </div>
      </div>

      {/* Stats Grid */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">
              Doanh thu tháng này
            </CardTitle>
            <DollarSign className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {formatCurrency(mockStats.totalRevenue)}
            </div>
            <div className="flex items-center gap-1 text-sm">
              {mockStats.revenueChange > 0 ? (
                <>
                  <TrendingUp className="h-4 w-4 text-green-500" />
                  <span className="text-green-500">+{mockStats.revenueChange}%</span>
                </>
              ) : (
                <>
                  <TrendingDown className="h-4 w-4 text-red-500" />
                  <span className="text-red-500">{mockStats.revenueChange}%</span>
                </>
              )}
              <span className="text-muted-foreground">so với tháng trước</span>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">
              Chi phí tháng này
            </CardTitle>
            <TrendingUp className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {formatCurrency(mockStats.totalCost)}
            </div>
            <div className="flex items-center gap-1 text-sm">
              <TrendingUp className="h-4 w-4 text-orange-500" />
              <span className="text-orange-500">+{mockStats.costChange}%</span>
              <span className="text-muted-foreground">so với tháng trước</span>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">
              Request mới (7 ngày)
            </CardTitle>
            <Users className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{mockStats.newRequests}</div>
            <div className="flex items-center gap-1 text-sm">
              {mockStats.requestChange > 0 ? (
                <>
                  <TrendingUp className="h-4 w-4 text-green-500" />
                  <span className="text-green-500">+{mockStats.requestChange}</span>
                </>
              ) : (
                <>
                  <TrendingDown className="h-4 w-4 text-red-500" />
                  <span className="text-red-500">{mockStats.requestChange}</span>
                </>
              )}
              <span className="text-muted-foreground">so với tuần trước</span>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">
              Booking đang hoạt động
            </CardTitle>
            <Briefcase className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{mockStats.activeBookings}</div>
            <div className="flex items-center gap-1 text-sm">
              {mockStats.bookingChange > 0 ? (
                <>
                  <TrendingUp className="h-4 w-4 text-green-500" />
                  <span className="text-green-500">+{mockStats.bookingChange}</span>
                </>
              ) : (
                <>
                  <TrendingDown className="h-4 w-4 text-red-500" />
                  <span className="text-red-500">{mockStats.bookingChange}</span>
                </>
              )}
              <span className="text-muted-foreground">so với tuần trước</span>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Follow-up Widget & Action Items & Recent Emails */}
      <div className="grid gap-6 lg:grid-cols-3">
        {/* Follow-up Widget */}
        <FollowUpWidget limit={5} />

        {/* Action Items */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <AlertCircle className="h-5 w-5 text-orange-500" />
              Cần hành động ngay
            </CardTitle>
            <CardDescription>
              Các việc cần xử lý ưu tiên cao
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-3">
            {mockActions.map((action, index) => (
              <div
                key={index}
                className="flex items-center justify-between p-3 rounded-lg bg-muted/50 hover:bg-muted cursor-pointer transition-colors"
              >
                <div className="flex items-center gap-3">
                  <Badge
                    variant={
                      action.type === 'danger'
                        ? 'destructive'
                        : action.type === 'warning'
                        ? 'default'
                        : 'secondary'
                    }
                    className="h-6 w-6 p-0 flex items-center justify-center rounded-full"
                  >
                    {action.count}
                  </Badge>
                  <span className="text-sm">{action.label}</span>
                </div>
                <ArrowRight className="h-4 w-4 text-muted-foreground" />
              </div>
            ))}
            <Separator />
            <Button variant="link" className="w-full" asChild>
              <Link href="/requests?filter=overdue">
                Xem tất cả <ArrowRight className="ml-2 h-4 w-4" />
              </Link>
            </Button>
          </CardContent>
        </Card>

        {/* Recent Emails */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Mail className="h-5 w-5 text-blue-500" />
              Email gần đây
            </CardTitle>
            <CardDescription>
              Từ info@myvivatour.com
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-3">
            {mockEmails.map((email) => (
              <div
                key={email.id}
                className="flex items-start gap-3 p-3 rounded-lg bg-muted/50 hover:bg-muted cursor-pointer transition-colors"
              >
                <div
                  className={`p-2 rounded-full ${
                    email.isRead ? 'bg-gray-200' : 'bg-blue-100'
                  }`}
                >
                  {email.isRead ? (
                    <MailOpen className="h-4 w-4 text-gray-500" />
                  ) : (
                    <Mail className="h-4 w-4 text-blue-500" />
                  )}
                </div>
                <div className="flex-1 min-w-0">
                  <div className="flex items-center justify-between gap-2">
                    <p className="text-sm font-medium truncate">
                      {email.customerName}
                    </p>
                    <span className="text-xs text-muted-foreground whitespace-nowrap">
                      {formatTimeAgo(email.date)}
                    </span>
                  </div>
                  <p className="text-sm text-muted-foreground truncate">
                    {email.subject}
                  </p>
                </div>
                {!email.isRead && (
                  <Badge variant="default" className="text-xs">
                    Mới
                  </Badge>
                )}
              </div>
            ))}
            <Separator />
            <Button variant="link" className="w-full">
              Xem tất cả <ArrowRight className="ml-2 h-4 w-4" />
            </Button>
          </CardContent>
        </Card>
      </div>

      {/* Follow-up List */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Clock className="h-5 w-5 text-red-500" />
            Khách cần follow-up
          </CardTitle>
          <CardDescription>
            Khách hàng quá hạn chăm sóc
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {mockFollowUps.map((customer) => (
              <Card key={customer.id} className="border-l-4 border-l-red-500">
                <CardContent className="p-4">
                  <div className="flex items-start justify-between mb-3">
                    <div>
                      <h4 className="font-semibold">{customer.customerName}</h4>
                      <p className="text-sm text-muted-foreground">
                        {customer.country} • {customer.source}
                      </p>
                    </div>
                    <Badge variant="destructive" className="text-xs">
                      +{customer.overdueDays} ngày
                    </Badge>
                  </div>
                  <div className="flex items-center gap-2">
                    <Badge variant="outline">{customer.status}</Badge>
                    <span className="text-xs text-muted-foreground">
                      {customer.contact}
                    </span>
                  </div>
                  <div className="flex gap-2 mt-4">
                    <Button size="sm" variant="outline" className="flex-1">
                      <Mail className="h-4 w-4 mr-1" />
                      Email
                    </Button>
                    <Button size="sm" variant="outline" className="flex-1">
                      <Phone className="h-4 w-4 mr-1" />
                      Gọi
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
          <Separator className="my-4" />
          <Button variant="link" className="w-full" asChild>
            <Link href="/requests?filter=followup">
              Xem tất cả khách cần follow-up <ArrowRight className="ml-2 h-4 w-4" />
            </Link>
          </Button>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/suppliers/[id]/page.tsx">
'use client';

import { useState, useEffect, useCallback, use } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Building2, ArrowDownCircle, ArrowUpCircle, Wallet, History } from 'lucide-react';
import { TransactionForm } from '@/components/suppliers/transaction-form';
import { EditSupplierModal } from '@/components/suppliers/edit-supplier-modal';
import type { Supplier, SupplierTransaction, SupplierBalance } from '@/types';

interface SupplierDetailData extends Omit<Supplier, 'balance'>, SupplierBalance {
  transactions: SupplierTransaction[];
}

export default function SupplierDetailPage({ params }: { params: Promise<{ id: string }> }) {
  const { id } = use(params);
  const [supplier, setSupplier] = useState<SupplierDetailData | null>(null);
  const [loading, setLoading] = useState(true);

  const fetchSupplier = useCallback(async () => {
    const res = await fetch(`/api/suppliers/${id}`);
    const data = await res.json();
    if (data.success) {
      setSupplier(data.data);
    }
    setLoading(false);
  }, [id]);

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    fetchSupplier();
  }, [fetchSupplier]);

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('vi-VN').format(value);
  };

  const formatDate = (date: Date | string) => {
    return new Date(date).toLocaleDateString('vi-VN');
  };

  const getPaymentModelLabel = (model: string) => {
    switch (model) {
      case 'PREPAID': return 'Trả trước (Deposit pool)';
      case 'PAY_PER_USE': return 'Thanh toán theo đơn';
      case 'CREDIT': return 'Công nợ';
      default: return model;
    }
  };

  const getTransactionTypeLabel = (type: string) => {
    switch (type) {
      case 'DEPOSIT': return { label: 'Nạp tiền', color: 'text-green-600' };
      case 'REFUND': return { label: 'Hoàn tiền', color: 'text-blue-600' };
      case 'ADJUSTMENT': return { label: 'Điều chỉnh', color: 'text-orange-600' };
      case 'FEE': return { label: 'Phí', color: 'text-red-600' };
      default: return { label: type, color: '' };
    }
  };

  if (loading) {
    return <div className="text-center py-10">Đang tải...</div>;
  }

  if (!supplier) {
    return <div className="text-center py-10">Không tìm thấy NCC</div>;
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <Building2 className="h-6 w-6" />
            {supplier.name}
          </h1>
          <p className="text-muted-foreground">Mã: {supplier.code}</p>
        </div>
        <div className="flex gap-2">
          <TransactionForm supplierId={id} onSuccess={fetchSupplier} />
          <EditSupplierModal supplier={supplier} onSuccess={fetchSupplier} />
        </div>
      </div>

      {/* Balance Summary */}
      <div className="grid grid-cols-4 gap-4">
        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-2">
              <ArrowDownCircle className="h-5 w-5 text-green-500" />
              <span className="text-sm text-muted-foreground">Tổng nạp</span>
            </div>
            <p className="text-2xl font-bold text-green-600 mt-2">
              {formatCurrency(supplier.deposits)}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-2">
              <ArrowUpCircle className="h-5 w-5 text-red-500" />
              <span className="text-sm text-muted-foreground">Đã chi (Operator)</span>
            </div>
            <p className="text-2xl font-bold text-red-600 mt-2">
              {formatCurrency(supplier.costs)}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="pt-6">
            <div className="flex items-center gap-2">
              <History className="h-5 w-5 text-blue-500" />
              <span className="text-sm text-muted-foreground">Hoàn tiền</span>
            </div>
            <p className="text-2xl font-bold text-blue-600 mt-2">
              {formatCurrency(supplier.refunds)}
            </p>
          </CardContent>
        </Card>

        <Card className={supplier.balance >= 0 ? 'bg-green-50' : 'bg-red-50'}>
          <CardContent className="pt-6">
            <div className="flex items-center gap-2">
              <Wallet className={`h-5 w-5 ${supplier.balance >= 0 ? 'text-green-500' : 'text-red-500'}`} />
              <span className="text-sm text-muted-foreground">Số dư</span>
            </div>
            <p className={`text-2xl font-bold mt-2 ${supplier.balance >= 0 ? 'text-green-600' : 'text-red-600'}`}>
              {formatCurrency(supplier.balance)}
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Supplier Info */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin NCC</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <p className="text-sm text-muted-foreground">Loại NCC</p>
              <p className="font-medium">{supplier.type}</p>
            </div>
            <div>
              <p className="text-sm text-muted-foreground">Hình thức thanh toán</p>
              <p className="font-medium">{getPaymentModelLabel(supplier.paymentModel)}</p>
            </div>
            {supplier.contactName && (
              <div>
                <p className="text-sm text-muted-foreground">Người liên hệ</p>
                <p className="font-medium">{supplier.contactName}</p>
              </div>
            )}
            {supplier.contactPhone && (
              <div>
                <p className="text-sm text-muted-foreground">Số điện thoại</p>
                <p className="font-medium">{supplier.contactPhone}</p>
              </div>
            )}
            {supplier.contactEmail && (
              <div>
                <p className="text-sm text-muted-foreground">Email</p>
                <p className="font-medium">{supplier.contactEmail}</p>
              </div>
            )}
            {supplier.bankAccount && (
              <div>
                <p className="text-sm text-muted-foreground">Tài khoản NH</p>
                <p className="font-medium">{supplier.bankAccount}</p>
              </div>
            )}
            <div>
              <p className="text-sm text-muted-foreground">Trạng thái</p>
              <Badge variant={supplier.isActive ? 'default' : 'secondary'}>
                {supplier.isActive ? 'Hoạt động' : 'Ngừng'}
              </Badge>
            </div>
          </div>
          {supplier.notes && (
            <div className="mt-4">
              <p className="text-sm text-muted-foreground">Ghi chú</p>
              <p className="mt-1">{supplier.notes}</p>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Recent Transactions */}
      <Card>
        <CardHeader>
          <CardTitle>Giao dịch gần đây</CardTitle>
        </CardHeader>
        <CardContent>
          {supplier.transactions?.length === 0 ? (
            <p className="text-center py-6 text-muted-foreground">Chưa có giao dịch</p>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Ngày</TableHead>
                  <TableHead>Loại</TableHead>
                  <TableHead>Mô tả</TableHead>
                  <TableHead className="text-right">Số tiền</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {supplier.transactions?.map((tx) => {
                  const typeInfo = getTransactionTypeLabel(tx.type);
                  return (
                    <TableRow key={tx.id}>
                      <TableCell>{formatDate(tx.transactionDate)}</TableCell>
                      <TableCell>
                        <Badge variant="outline" className={typeInfo.color}>
                          {typeInfo.label}
                        </Badge>
                      </TableCell>
                      <TableCell>{tx.description || '-'}</TableCell>
                      <TableCell className={`text-right font-medium ${typeInfo.color}`}>
                        {formatCurrency(Number(tx.amount))}
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/suppliers/create/page.tsx">
import { SupplierForm } from '@/components/suppliers/supplier-form';
import { Building2 } from 'lucide-react';

export default function CreateSupplierPage() {
  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-2xl font-bold flex items-center gap-2">
          <Building2 className="h-6 w-6" />
          Thêm NCC mới
        </h1>
        <p className="text-muted-foreground">Tạo nhà cung cấp mới</p>
      </div>

      <SupplierForm />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/suppliers/page.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import Link from 'next/link';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Plus, Search, Building2 } from 'lucide-react';
import {
  SUPPLIER_TYPES,
  SUPPLIER_TYPE_KEYS,
  SUPPLIER_LOCATIONS,
  PAYMENT_MODELS,
  type SupplierLocationKey,
} from '@/config/supplier-config';

interface SupplierListItem {
  id: string;
  code: string;
  name: string;
  type: string;
  location: string | null;
  paymentModel: string;
  isActive: boolean;
  balance?: number;
}

export default function SuppliersPage() {
  const [suppliers, setSuppliers] = useState<SupplierListItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [search, setSearch] = useState('');
  const [typeFilter, setTypeFilter] = useState('');

  const fetchSuppliers = useCallback(async () => {
    setLoading(true);
    const params = new URLSearchParams();
    if (search) params.set('search', search);
    if (typeFilter && typeFilter !== 'all') params.set('type', typeFilter);
    params.set('includeBalance', 'true');

    const res = await fetch(`/api/suppliers?${params}`);
    const data = await res.json();
    if (data.success) {
      setSuppliers(data.data);
    }
    setLoading(false);
  }, [search, typeFilter]);

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    fetchSuppliers();
  }, [fetchSuppliers]);

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('vi-VN').format(value);
  };

  const getPaymentModelLabel = (model: string) => {
    return PAYMENT_MODELS[model as keyof typeof PAYMENT_MODELS]?.label || model;
  };

  const getTypeLabel = (type: string) => {
    return SUPPLIER_TYPES[type as keyof typeof SUPPLIER_TYPES]?.label || type;
  };

  const getLocationLabel = (location: string | null) => {
    if (!location) return '-';
    const loc = SUPPLIER_LOCATIONS[location as SupplierLocationKey];
    return loc?.label || location;
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <Building2 className="h-6 w-6" />
            Quản lý NCC
          </h1>
          <p className="text-muted-foreground">Danh sách nhà cung cấp</p>
        </div>
        <Button asChild>
          <Link href="/suppliers/create">
            <Plus className="mr-2 h-4 w-4" /> Thêm NCC
          </Link>
        </Button>
      </div>

      {/* Filters */}
      <Card>
        <CardContent className="pt-6">
          <div className="flex gap-4">
            <div className="flex-1 relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Tìm theo mã hoặc tên NCC..."
                value={search}
                onChange={(e) => setSearch(e.target.value)}
                className="pl-10"
              />
            </div>
            <Select value={typeFilter} onValueChange={setTypeFilter}>
              <SelectTrigger className="w-48">
                <SelectValue placeholder="Loại NCC" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">Tất cả</SelectItem>
                {SUPPLIER_TYPE_KEYS.map((key) => (
                  <SelectItem key={key} value={key}>
                    {SUPPLIER_TYPES[key].label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <CardHeader>
          <CardTitle>Danh sách NCC ({suppliers.length})</CardTitle>
        </CardHeader>
        <CardContent>
          {loading ? (
            <div className="text-center py-10 text-muted-foreground">
              Đang tải...
            </div>
          ) : suppliers.length === 0 ? (
            <div className="text-center py-10 text-muted-foreground">
              Chưa có nhà cung cấp nào
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Mã NCC</TableHead>
                  <TableHead>Tên NCC</TableHead>
                  <TableHead>Loại</TableHead>
                  <TableHead>Địa phương</TableHead>
                  <TableHead>Hình thức TT</TableHead>
                  <TableHead className="text-right">Số dư</TableHead>
                  <TableHead>Trạng thái</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {suppliers.map((supplier) => (
                  <TableRow key={supplier.id}>
                    <TableCell>
                      <Link
                        href={`/suppliers/${supplier.id}`}
                        className="font-medium text-primary hover:underline font-mono"
                      >
                        {supplier.code}
                      </Link>
                    </TableCell>
                    <TableCell>{supplier.name}</TableCell>
                    <TableCell>
                      <Badge variant="outline">{getTypeLabel(supplier.type)}</Badge>
                    </TableCell>
                    <TableCell className="text-muted-foreground">
                      {getLocationLabel(supplier.location)}
                    </TableCell>
                    <TableCell>{getPaymentModelLabel(supplier.paymentModel)}</TableCell>
                    <TableCell className={`text-right font-medium ${
                      (supplier.balance ?? 0) >= 0 ? 'text-green-600' : 'text-red-600'
                    }`}>
                      {formatCurrency(supplier.balance ?? 0)}
                    </TableCell>
                    <TableCell>
                      <Badge variant={supplier.isActive ? 'default' : 'secondary'}>
                        {supplier.isActive ? 'Hoạt động' : 'Ngừng'}
                      </Badge>
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/suppliers/reports/page.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { ArrowUpCircle, ArrowDownCircle, Wallet, Building2 } from 'lucide-react';
import { SUPPLIER_TYPES, SUPPLIER_TYPE_KEYS } from '@/config/supplier-config';
import Link from 'next/link';

interface SupplierBalanceData {
  id: string;
  code: string;
  name: string;
  type: string;
  deposits: number;
  costs: number;
  refunds: number;
  balance: number;
}

interface Summary {
  supplierCount: number;
  totalDeposits: number;
  totalCosts: number;
  totalRefunds: number;
  totalBalance: number;
  positiveBalance: number;
  negativeBalance: number;
}

export default function SupplierReportsPage() {
  const [data, setData] = useState<SupplierBalanceData[]>([]);
  const [summary, setSummary] = useState<Summary | null>(null);
  const [loading, setLoading] = useState(true);
  const [typeFilter, setTypeFilter] = useState('');

  const fetchReport = useCallback(async () => {
    setLoading(true);
    const params = new URLSearchParams();
    if (typeFilter && typeFilter !== 'all') params.set('type', typeFilter);

    const res = await fetch(`/api/reports/supplier-balance?${params}`);
    const result = await res.json();
    if (result.success) {
      setData(result.data);
      setSummary(result.summary);
    }
    setLoading(false);
  }, [typeFilter]);

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    fetchReport();
  }, [fetchReport]);

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('vi-VN').format(value);
  };

  if (loading) {
    return <div className="text-center py-10">Đang tải báo cáo...</div>;
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold">Báo cáo Công nợ NCC</h1>
          <p className="text-muted-foreground">Tổng hợp số dư các nhà cung cấp</p>
        </div>
        <Select value={typeFilter} onValueChange={setTypeFilter}>
          <SelectTrigger className="w-48">
            <SelectValue placeholder="Tất cả loại NCC" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Tất cả</SelectItem>
            {SUPPLIER_TYPE_KEYS.map((key) => (
              <SelectItem key={key} value={key}>{SUPPLIER_TYPES[key].label}</SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Summary Cards */}
      {summary && (
        <div className="grid grid-cols-4 gap-4">
          <Card>
            <CardContent className="pt-6">
              <div className="flex items-center gap-2">
                <Building2 className="h-5 w-5 text-muted-foreground" />
                <span className="text-sm text-muted-foreground">Số NCC</span>
              </div>
              <p className="text-2xl font-bold mt-2">{summary.supplierCount}</p>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="pt-6">
              <div className="flex items-center gap-2">
                <ArrowDownCircle className="h-5 w-5 text-green-500" />
                <span className="text-sm text-muted-foreground">Tổng nạp</span>
              </div>
              <p className="text-2xl font-bold text-green-600 mt-2">
                {formatCurrency(summary.totalDeposits)}
              </p>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="pt-6">
              <div className="flex items-center gap-2">
                <ArrowUpCircle className="h-5 w-5 text-red-500" />
                <span className="text-sm text-muted-foreground">Tổng chi</span>
              </div>
              <p className="text-2xl font-bold text-red-600 mt-2">
                {formatCurrency(summary.totalCosts)}
              </p>
            </CardContent>
          </Card>

          <Card className={summary.totalBalance >= 0 ? 'bg-green-50' : 'bg-red-50'}>
            <CardContent className="pt-6">
              <div className="flex items-center gap-2">
                <Wallet className={`h-5 w-5 ${summary.totalBalance >= 0 ? 'text-green-500' : 'text-red-500'}`} />
                <span className="text-sm text-muted-foreground">Tổng số dư</span>
              </div>
              <p className={`text-2xl font-bold mt-2 ${summary.totalBalance >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                {formatCurrency(summary.totalBalance)}
              </p>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Balance Status Cards */}
      {summary && (
        <div className="grid grid-cols-2 gap-4">
          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-sm text-green-600">Số dư dương (Có credit)</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-3xl font-bold text-green-600">{summary.positiveBalance}</p>
              <p className="text-sm text-muted-foreground">nhà cung cấp</p>
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="pb-2">
              <CardTitle className="text-sm text-red-600">Số dư âm (Cần thanh toán)</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-3xl font-bold text-red-600">{summary.negativeBalance}</p>
              <p className="text-sm text-muted-foreground">nhà cung cấp</p>
            </CardContent>
          </Card>
        </div>
      )}

      {/* Detail Table */}
      <Card>
        <CardHeader>
          <CardTitle>Chi tiết theo NCC</CardTitle>
        </CardHeader>
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Mã NCC</TableHead>
                <TableHead>Tên NCC</TableHead>
                <TableHead>Loại</TableHead>
                <TableHead className="text-right">Tổng nạp</TableHead>
                <TableHead className="text-right">Đã chi</TableHead>
                <TableHead className="text-right">Hoàn tiền</TableHead>
                <TableHead className="text-right">Số dư</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.map((supplier) => (
                <TableRow key={supplier.id}>
                  <TableCell>
                    <Link href={`/suppliers/${supplier.id}`} className="font-medium text-primary hover:underline">
                      {supplier.code}
                    </Link>
                  </TableCell>
                  <TableCell>{supplier.name}</TableCell>
                  <TableCell>
                    <Badge variant="outline">{supplier.type}</Badge>
                  </TableCell>
                  <TableCell className="text-right text-green-600">
                    {formatCurrency(supplier.deposits)}
                  </TableCell>
                  <TableCell className="text-right text-red-600">
                    {formatCurrency(supplier.costs)}
                  </TableCell>
                  <TableCell className="text-right text-blue-600">
                    {formatCurrency(supplier.refunds)}
                  </TableCell>
                  <TableCell className={`text-right font-bold ${supplier.balance >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                    {formatCurrency(supplier.balance)}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/api/config/follow-up/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

// GET /api/config/follow-up - List all follow-up configs
export async function GET() {
  try {
    const configs = await prisma.configFollowUp.findMany({
      orderBy: { stage: 'asc' },
    });

    return NextResponse.json({ success: true, data: configs });
  } catch (error) {
    console.error('Error fetching follow-up configs:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải cấu hình follow-up: ${message}` },
      { status: 500 }
    );
  }
}

// POST /api/config/follow-up - Create/update config (upsert by stage)
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate required fields
    if (!body.stage || body.daysToWait === undefined) {
      return NextResponse.json(
        { success: false, error: 'Thiếu thông tin bắt buộc: stage, daysToWait' },
        { status: 400 }
      );
    }

    // Validate stage is valid
    const validStages = ['F1', 'F2', 'F3', 'F4'];
    if (!validStages.includes(body.stage)) {
      return NextResponse.json(
        { success: false, error: 'Stage không hợp lệ. Chỉ chấp nhận: F1, F2, F3, F4' },
        { status: 400 }
      );
    }

    const config = await prisma.configFollowUp.upsert({
      where: { stage: body.stage },
      update: {
        daysToWait: body.daysToWait,
        isActive: body.isActive ?? true,
      },
      create: {
        stage: body.stage,
        daysToWait: body.daysToWait,
        isActive: body.isActive ?? true,
      },
    });

    return NextResponse.json({ success: true, data: config });
  } catch (error) {
    console.error('Error upserting follow-up config:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi lưu cấu hình follow-up: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/[id]/approve/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createOperatorHistory } from '@/lib/operator-history';

// POST /api/operators/[id]/approve
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();

    const operator = await prisma.operator.findUnique({ where: { id } });

    if (!operator) {
      return NextResponse.json(
        { success: false, error: 'Dịch vụ không tồn tại' },
        { status: 404 }
      );
    }

    if (operator.isLocked) {
      return NextResponse.json(
        { success: false, error: 'Dịch vụ đã khóa' },
        { status: 403 }
      );
    }

    if (operator.paymentStatus === 'PAID') {
      return NextResponse.json(
        { success: false, error: 'Dịch vụ đã được thanh toán' },
        { status: 400 }
      );
    }

    const paymentDate = body.paymentDate ? new Date(body.paymentDate) : new Date();
    const userId = body.userId || 'system';

    const updated = await prisma.operator.update({
      where: { id },
      data: {
        paymentStatus: 'PAID',
        paymentDate,
      },
    });

    await createOperatorHistory({
      operatorId: id,
      action: 'APPROVE',
      changes: {
        paymentStatus: { before: operator.paymentStatus, after: 'PAID' },
        paymentDate: { before: operator.paymentDate, after: paymentDate },
      },
      userId,
    });

    return NextResponse.json({ success: true, data: updated });
  } catch (error) {
    console.error('Error approving operator:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi duyệt: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/reports/operator-costs/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { SERVICE_TYPES, SERVICE_TYPE_KEYS } from '@/config/operator-config';

// Date format validation regex (YYYY-MM-DD)
const DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;

// Validate date string format
function isValidDate(dateStr: string): boolean {
  if (!DATE_REGEX.test(dateStr)) return false;
  const date = new Date(dateStr);
  return !isNaN(date.getTime());
}

// GET /api/reports/operator-costs
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const fromDate = searchParams.get('fromDate');
    const toDate = searchParams.get('toDate');
    const serviceType = searchParams.get('serviceType');
    const supplierId = searchParams.get('supplierId');

    // Validate date inputs
    if (fromDate && !isValidDate(fromDate)) {
      return NextResponse.json(
        { success: false, error: 'Ngày bắt đầu không hợp lệ (YYYY-MM-DD)' },
        { status: 400 }
      );
    }
    if (toDate && !isValidDate(toDate)) {
      return NextResponse.json(
        { success: false, error: 'Ngày kết thúc không hợp lệ (YYYY-MM-DD)' },
        { status: 400 }
      );
    }

    // Validate serviceType against enum
    if (serviceType && !SERVICE_TYPE_KEYS.includes(serviceType as never)) {
      return NextResponse.json(
        { success: false, error: 'Loại dịch vụ không hợp lệ' },
        { status: 400 }
      );
    }

    // Build where clause
    const where: Record<string, unknown> = {};

    if (fromDate || toDate) {
      where.serviceDate = {};
      if (fromDate) (where.serviceDate as Record<string, Date>).gte = new Date(fromDate);
      if (toDate) (where.serviceDate as Record<string, Date>).lte = new Date(toDate);
    }

    if (serviceType) where.serviceType = serviceType;
    if (supplierId) where.supplierId = supplierId;

    // Get all matching operators
    const operators = await prisma.operator.findMany({
      where,
      select: {
        id: true,
        serviceType: true,
        supplierId: true,
        supplier: true,
        serviceDate: true,
        totalCost: true,
        supplierRef: { select: { name: true } },
        request: { select: { code: true } },
      },
    });

    // By service type
    const byServiceType = Object.keys(SERVICE_TYPES).map((type) => {
      const items = operators.filter((op) => op.serviceType === type);
      return {
        type,
        label: SERVICE_TYPES[type as keyof typeof SERVICE_TYPES].label,
        total: items.reduce((sum, op) => sum + Number(op.totalCost), 0),
        count: items.length,
      };
    }).filter((t) => t.count > 0);

    // By supplier
    const supplierMap = new Map<string, { name: string; total: number; count: number }>();
    operators.forEach((op) => {
      const key = op.supplierId || 'no-supplier';
      const name = op.supplierRef?.name || op.supplier || 'Không có NCC';

      if (!supplierMap.has(key)) {
        supplierMap.set(key, { name, total: 0, count: 0 });
      }
      const entry = supplierMap.get(key)!;
      entry.total += Number(op.totalCost);
      entry.count += 1;
    });

    const bySupplier = Array.from(supplierMap.entries())
      .map(([supplierId, data]) => ({
        supplierId: supplierId === 'no-supplier' ? null : supplierId,
        supplierName: data.name,
        total: data.total,
        count: data.count,
      }))
      .sort((a, b) => b.total - a.total);

    // By month
    const monthMap = new Map<string, { total: number; count: number }>();
    operators.forEach((op) => {
      const date = new Date(op.serviceDate);
      const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

      if (!monthMap.has(key)) {
        monthMap.set(key, { total: 0, count: 0 });
      }
      const entry = monthMap.get(key)!;
      entry.total += Number(op.totalCost);
      entry.count += 1;
    });

    const byMonth = Array.from(monthMap.entries())
      .map(([month, data]) => ({
        month,
        total: data.total,
        count: data.count,
      }))
      .sort((a, b) => a.month.localeCompare(b.month));

    // Summary
    const totalCost = operators.reduce((sum, op) => sum + Number(op.totalCost), 0);
    const summary = {
      totalCost,
      totalCount: operators.length,
      avgCost: operators.length > 0 ? Math.round(totalCost / operators.length) : 0,
    };

    return NextResponse.json({
      success: true,
      data: {
        byServiceType,
        bySupplier,
        byMonth,
        summary,
      },
    });
  } catch (error) {
    console.error('Error generating cost report:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo báo cáo: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/reports/operator-payments/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

// Month format validation regex (YYYY-MM)
const MONTH_REGEX = /^\d{4}-(0[1-9]|1[0-2])$/;

// GET /api/reports/operator-payments
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const month = searchParams.get('month'); // YYYY-MM for filtering

    // Validate month format
    if (month && !MONTH_REGEX.test(month)) {
      return NextResponse.json(
        { success: false, error: 'Định dạng tháng không hợp lệ (YYYY-MM)' },
        { status: 400 }
      );
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const weekEnd = new Date(today);
    weekEnd.setDate(weekEnd.getDate() + 7);

    // Month filter
    let monthStart: Date | undefined;
    let monthEnd: Date | undefined;
    if (month) {
      const [year, m] = month.split('-').map(Number);
      monthStart = new Date(year, m - 1, 1);
      monthEnd = new Date(year, m, 0, 23, 59, 59, 999);
    }

    // Current month for "paid this month"
    const currentMonthStart = new Date(today.getFullYear(), today.getMonth(), 1);
    const currentMonthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0, 23, 59, 59, 999);

    // Pending payments
    const pendingWhere: Record<string, unknown> = {
      paymentStatus: { in: ['PENDING', 'PARTIAL'] },
    };
    if (monthStart && monthEnd) {
      pendingWhere.serviceDate = { gte: monthStart, lte: monthEnd };
    }

    const pending = await prisma.operator.aggregate({
      where: pendingWhere,
      _count: { id: true },
      _sum: { totalCost: true },
    });

    // Due this week
    const dueThisWeek = await prisma.operator.aggregate({
      where: {
        paymentStatus: { in: ['PENDING', 'PARTIAL'] },
        paymentDeadline: { gte: today, lt: weekEnd },
      },
      _count: { id: true },
      _sum: { totalCost: true },
    });

    // Overdue
    const overdue = await prisma.operator.aggregate({
      where: {
        paymentStatus: { in: ['PENDING', 'PARTIAL'] },
        paymentDeadline: { lt: today },
      },
      _count: { id: true },
      _sum: { totalCost: true },
    });

    // Paid this month
    const paidThisMonth = await prisma.operator.aggregate({
      where: {
        paymentStatus: 'PAID',
        paymentDate: { gte: currentMonthStart, lte: currentMonthEnd },
      },
      _count: { id: true },
      _sum: { totalCost: true },
    });

    return NextResponse.json({
      success: true,
      data: {
        pending: {
          count: pending._count.id,
          total: Number(pending._sum.totalCost || 0),
        },
        dueThisWeek: {
          count: dueThisWeek._count.id,
          total: Number(dueThisWeek._sum.totalCost || 0),
        },
        overdue: {
          count: overdue._count.id,
          total: Number(overdue._sum.totalCost || 0),
        },
        paidThisMonth: {
          count: paidThisMonth._count.id,
          total: Number(paidThisMonth._sum.totalCost || 0),
        },
      },
    });
  } catch (error) {
    console.error('Error generating payment report:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo báo cáo: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/reports/supplier-balance/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getSupplierBalanceSummary } from '@/lib/supplier-balance';

// GET /api/reports/supplier-balance - Get balance summary for all suppliers
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const type = searchParams.get('type') || undefined;

    const result = await getSupplierBalanceSummary(type);

    return NextResponse.json({
      success: true,
      ...result,
    });
  } catch (error) {
    console.error('Error fetching supplier balance report:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch balance report' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/supplier-transactions/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET /api/supplier-transactions/[id] - Get transaction detail
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;

    const transaction = await prisma.supplierTransaction.findUnique({
      where: { id },
      include: {
        supplier: true,
      },
    });

    if (!transaction) {
      return NextResponse.json(
        { success: false, error: 'Transaction not found' },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: transaction });
  } catch (error) {
    console.error('Error fetching transaction:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch transaction' },
      { status: 500 }
    );
  }
}

// PUT /api/supplier-transactions/[id] - Update transaction
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const body = await request.json();

    // Check transaction exists
    const existing = await prisma.supplierTransaction.findUnique({
      where: { id },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Transaction not found' },
        { status: 404 }
      );
    }

    // Validate amount if provided
    if (body.amount !== undefined && body.amount <= 0) {
      return NextResponse.json(
        { success: false, error: 'Amount must be positive' },
        { status: 400 }
      );
    }

    // Validate type if provided
    if (body.type) {
      const validTypes = ['DEPOSIT', 'REFUND', 'ADJUSTMENT', 'FEE'];
      if (!validTypes.includes(body.type)) {
        return NextResponse.json(
          { success: false, error: `Invalid type. Must be one of: ${validTypes.join(', ')}` },
          { status: 400 }
        );
      }
    }

    // Update transaction
    const transaction = await prisma.supplierTransaction.update({
      where: { id },
      data: {
        type: body.type ?? existing.type,
        amount: body.amount !== undefined ? Number(body.amount) : undefined,
        transactionDate: body.transactionDate
          ? new Date(body.transactionDate)
          : existing.transactionDate,
        description: body.description ?? existing.description,
        proofLink: body.proofLink ?? existing.proofLink,
        relatedBookingCode: body.relatedBookingCode ?? existing.relatedBookingCode,
      },
      include: {
        supplier: {
          select: { code: true, name: true },
        },
      },
    });

    return NextResponse.json({ success: true, data: transaction });
  } catch (error) {
    console.error('Error updating transaction:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to update transaction' },
      { status: 500 }
    );
  }
}

// DELETE /api/supplier-transactions/[id] - Delete transaction
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;

    // Check transaction exists
    const existing = await prisma.supplierTransaction.findUnique({
      where: { id },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Transaction not found' },
        { status: 404 }
      );
    }

    // Delete transaction
    await prisma.supplierTransaction.delete({
      where: { id },
    });

    return NextResponse.json({ success: true, message: 'Transaction deleted' });
  } catch (error) {
    console.error('Error deleting transaction:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to delete transaction' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/suppliers/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { calculateSupplierBalance } from '@/lib/supplier-balance';

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET /api/suppliers/[id] - Get supplier detail with balance
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;

    const supplier = await prisma.supplier.findUnique({
      where: { id },
      include: {
        transactions: {
          orderBy: { transactionDate: 'desc' },
          take: 10, // Recent transactions
        },
      },
    });

    if (!supplier) {
      return NextResponse.json(
        { success: false, error: 'Supplier not found' },
        { status: 404 }
      );
    }

    // Calculate balance
    const balance = await calculateSupplierBalance(id);

    return NextResponse.json({
      success: true,
      data: {
        ...supplier,
        ...balance,
      },
    });
  } catch (error) {
    console.error('Error fetching supplier:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch supplier' },
      { status: 500 }
    );
  }
}

// PUT /api/suppliers/[id] - Update supplier
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const body = await request.json();

    // Check supplier exists
    const existing = await prisma.supplier.findUnique({
      where: { id },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Supplier not found' },
        { status: 404 }
      );
    }

    // Check for duplicate code if code is being changed
    if (body.code && body.code !== existing.code) {
      const duplicate = await prisma.supplier.findUnique({
        where: { code: body.code },
      });
      if (duplicate) {
        return NextResponse.json(
          { success: false, error: 'Supplier code already exists' },
          { status: 400 }
        );
      }
    }

    // Update supplier
    const supplier = await prisma.supplier.update({
      where: { id },
      data: {
        code: body.code ?? existing.code,
        name: body.name ?? existing.name,
        type: body.type ?? existing.type,
        paymentModel: body.paymentModel ?? existing.paymentModel,
        creditLimit: body.creditLimit !== undefined
          ? (body.creditLimit ? Number(body.creditLimit) : null)
          : undefined,
        paymentTermDays: body.paymentTermDays ?? existing.paymentTermDays,
        contactName: body.contactName ?? existing.contactName,
        contactPhone: body.contactPhone ?? existing.contactPhone,
        contactEmail: body.contactEmail ?? existing.contactEmail,
        bankAccount: body.bankAccount ?? existing.bankAccount,
        isActive: body.isActive ?? existing.isActive,
        notes: body.notes ?? existing.notes,
      },
    });

    return NextResponse.json({ success: true, data: supplier });
  } catch (error) {
    console.error('Error updating supplier:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to update supplier' },
      { status: 500 }
    );
  }
}

// DELETE /api/suppliers/[id] - Soft delete (deactivate) supplier
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;

    // Check supplier exists
    const existing = await prisma.supplier.findUnique({
      where: { id },
      include: {
        _count: {
          select: { operators: true },
        },
      },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Supplier not found' },
        { status: 404 }
      );
    }

    // Warn if supplier has linked operators
    if (existing._count.operators > 0) {
      // Soft delete - just deactivate
      await prisma.supplier.update({
        where: { id },
        data: { isActive: false },
      });

      return NextResponse.json({
        success: true,
        message: `Supplier deactivated. Has ${existing._count.operators} linked operators.`,
      });
    }

    // Hard delete if no linked records
    await prisma.supplier.delete({
      where: { id },
    });

    return NextResponse.json({ success: true, message: 'Supplier deleted' });
  } catch (error) {
    console.error('Error deleting supplier:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to delete supplier' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/suppliers/generate-code/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import {
  generateSupplierCode,
  SUPPLIER_TYPES,
  type SupplierTypeKey,
  type SupplierLocationKey,
} from '@/config/supplier-config';

// GET /api/suppliers/generate-code?type=HOTEL&name=An Khanh&location=DA_NANG
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const type = searchParams.get('type') as SupplierTypeKey;
    const name = searchParams.get('name') || '';
    const location = searchParams.get('location') as SupplierLocationKey | null;

    // Validate required fields
    if (!type || !name) {
      return NextResponse.json(
        { success: false, error: 'Cần có loại NCC và tên để tạo mã' },
        { status: 400 }
      );
    }

    // Validate type is valid
    if (!(type in SUPPLIER_TYPES)) {
      return NextResponse.json(
        { success: false, error: `Loại NCC không hợp lệ: ${type}` },
        { status: 400 }
      );
    }

    // Generate base code with sequence 1
    const baseCode = generateSupplierCode(type, name, location, 1);
    const codePrefix = baseCode.substring(0, baseCode.lastIndexOf('-'));

    // Find existing suppliers with same prefix
    const existingSuppliers = await prisma.supplier.findMany({
      where: {
        code: { startsWith: codePrefix },
      },
      orderBy: { code: 'desc' },
      take: 1,
    });

    let nextSequence = 1;
    if (existingSuppliers.length > 0) {
      const lastCode = existingSuppliers[0].code;
      const lastSequence = parseInt(lastCode.split('-').pop() || '0', 10);
      nextSequence = lastSequence + 1;
    }

    const generatedCode = generateSupplierCode(type, name, location, nextSequence);

    return NextResponse.json({
      success: true,
      data: {
        code: generatedCode,
        prefix: codePrefix,
        sequence: nextSequence,
      },
    });
  } catch (error) {
    console.error('Error generating supplier code:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo mã NCC: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/suppliers/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { calculateSupplierBalance } from '@/lib/supplier-balance';
import {
  generateSupplierCode,
  SUPPLIER_TYPES,
  type SupplierTypeKey,
  type SupplierLocationKey,
} from '@/config/supplier-config';

// GET /api/suppliers - List suppliers with optional filters
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const search = searchParams.get('search') || '';
    const type = searchParams.get('type') || '';
    const location = searchParams.get('location') || '';
    const paymentModel = searchParams.get('paymentModel') || '';
    const isActive = searchParams.get('isActive');
    const includeBalance = searchParams.get('includeBalance') === 'true';

    // Build where clause
    const where: Record<string, unknown> = {};

    if (search) {
      where.OR = [
        { code: { contains: search, mode: 'insensitive' } },
        { name: { contains: search, mode: 'insensitive' } },
      ];
    }

    if (type) where.type = type;
    if (location) where.location = location;
    if (paymentModel) where.paymentModel = paymentModel;
    if (isActive !== null && isActive !== '') {
      where.isActive = isActive === 'true';
    }

    const suppliers = await prisma.supplier.findMany({
      where,
      orderBy: { code: 'asc' },
    });

    // Include balance if requested
    let result = suppliers;
    if (includeBalance) {
      result = await Promise.all(
        suppliers.map(async (supplier) => {
          const balance = await calculateSupplierBalance(supplier.id);
          return { ...supplier, balance: balance.balance };
        })
      );
    }

    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    console.error('Error fetching suppliers:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Failed to fetch suppliers: ${message}` },
      { status: 500 }
    );
  }
}

// POST /api/suppliers - Create new supplier
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate required fields
    if (!body.name || !body.type) {
      return NextResponse.json(
        { success: false, error: 'Thiếu thông tin bắt buộc: Tên NCC và Loại NCC' },
        { status: 400 }
      );
    }

    // Validate type is valid
    if (!(body.type in SUPPLIER_TYPES)) {
      return NextResponse.json(
        { success: false, error: `Loại NCC không hợp lệ: ${body.type}` },
        { status: 400 }
      );
    }

    // Generate code if not provided or generate next sequence
    let code = body.code;
    if (!code) {
      // Find existing suppliers with similar prefix to get next sequence
      const typeKey = body.type as SupplierTypeKey;
      const locationKey = body.location as SupplierLocationKey | null;

      // Generate base code with sequence 1
      const baseCode = generateSupplierCode(typeKey, body.name, locationKey, 1);
      const codePrefix = baseCode.substring(0, baseCode.lastIndexOf('-'));

      // Find existing suppliers with same prefix
      const existingSuppliers = await prisma.supplier.findMany({
        where: {
          code: { startsWith: codePrefix },
        },
        orderBy: { code: 'desc' },
        take: 1,
      });

      let nextSequence = 1;
      if (existingSuppliers.length > 0) {
        const lastCode = existingSuppliers[0].code;
        const lastSequence = parseInt(lastCode.split('-').pop() || '0', 10);
        nextSequence = lastSequence + 1;
      }

      code = generateSupplierCode(typeKey, body.name, locationKey, nextSequence);
    }

    // Check for duplicate code
    const existing = await prisma.supplier.findUnique({
      where: { code },
    });

    if (existing) {
      return NextResponse.json(
        { success: false, error: `Mã NCC đã tồn tại: ${code}` },
        { status: 400 }
      );
    }

    // Create supplier
    const supplier = await prisma.supplier.create({
      data: {
        code,
        name: body.name.trim(),
        type: body.type,
        location: body.location || null,
        paymentModel: body.paymentModel || 'PREPAID',
        creditLimit: body.creditLimit ? Number(body.creditLimit) : null,
        paymentTermDays: body.paymentTermDays ? Number(body.paymentTermDays) : null,
        contactName: body.contactName?.trim() || null,
        contactPhone: body.contactPhone?.trim() || null,
        contactEmail: body.contactEmail?.trim() || null,
        bankAccount: body.bankAccount?.trim() || null,
        isActive: body.isActive ?? true,
        notes: body.notes?.trim() || null,
      },
    });

    return NextResponse.json({ success: true, data: supplier }, { status: 201 });
  } catch (error) {
    console.error('Error creating supplier:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo NCC: ${message}` },
      { status: 500 }
    );
  }
}

// GET /api/suppliers/generate-code - Generate supplier code preview
export async function generateCodePreview(
  type: SupplierTypeKey,
  name: string,
  location?: SupplierLocationKey | null
): Promise<string> {
  const baseCode = generateSupplierCode(type, name, location, 1);
  const codePrefix = baseCode.substring(0, baseCode.lastIndexOf('-'));

  const existingSuppliers = await prisma.supplier.findMany({
    where: {
      code: { startsWith: codePrefix },
    },
    orderBy: { code: 'desc' },
    take: 1,
  });

  let nextSequence = 1;
  if (existingSuppliers.length > 0) {
    const lastCode = existingSuppliers[0].code;
    const lastSequence = parseInt(lastCode.split('-').pop() || '0', 10);
    nextSequence = lastSequence + 1;
  }

  return generateSupplierCode(type, name, location, nextSequence);
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --radius-2xl: calc(var(--radius) + 8px);
  --radius-3xl: calc(var(--radius) + 12px);
  --radius-4xl: calc(var(--radius) + 16px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(0.98 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.55 0.25 270);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { Toaster } from "sonner";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
        <Toaster position="top-right" richColors />
      </body>
    </html>
  );
}
</file>

<file path="src/components/dashboard/follow-up-widget.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { formatDate } from '@/lib/utils';
import type { Request } from '@/types';

interface FollowUpWidgetProps {
  limit?: number;
}

export function FollowUpWidget({ limit = 5 }: FollowUpWidgetProps) {
  const router = useRouter();
  const [requests, setRequests] = useState<{
    overdue: Request[];
    today: Request[];
    upcoming: Request[];
  }>({ overdue: [], today: [], upcoming: [] });
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function fetchFollowUps() {
      setLoading(true);
      try {
        const [overdueRes, todayRes, upcomingRes] = await Promise.all([
          fetch(`/api/requests?followup=overdue&limit=${limit}`),
          fetch(`/api/requests?followup=today&limit=${limit}`),
          fetch(`/api/requests?followup=upcoming&limit=${limit}`),
        ]);

        const [overdueData, todayData, upcomingData] = await Promise.all([
          overdueRes.json(),
          todayRes.json(),
          upcomingRes.json(),
        ]);

        setRequests({
          overdue: overdueData.success ? overdueData.data : [],
          today: todayData.success ? todayData.data : [],
          upcoming: upcomingData.success ? upcomingData.data : [],
        });
      } catch (err) {
        console.error('Error fetching follow-ups:', err);
      } finally {
        setLoading(false);
      }
    }
    fetchFollowUps();
  }, [limit]);

  if (loading) {
    return (
      <Card>
        <CardContent className="py-8 text-center text-muted-foreground">
          Đang tải...
        </CardContent>
      </Card>
    );
  }

  const totalCount = requests.overdue.length + requests.today.length + requests.upcoming.length;

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle className="flex items-center gap-2">
          <Clock className="w-5 h-5" />
          Follow-up
        </CardTitle>
        <Button
          variant="ghost"
          size="sm"
          onClick={() => router.push('/requests?tab=followup')}
        >
          Xem tất cả
        </Button>
      </CardHeader>
      <CardContent className="space-y-4">
        {totalCount === 0 ? (
          <div className="text-center py-4 text-muted-foreground">
            <CheckCircle className="w-8 h-8 mx-auto mb-2 text-green-500" />
            Không có follow-up nào
          </div>
        ) : (
          <>
            {/* Overdue Section */}
            {requests.overdue.length > 0 && (
              <div className="space-y-2">
                <div className="flex items-center gap-2 text-red-600">
                  <AlertCircle className="w-4 h-4" />
                  <span className="font-medium">Quá hạn ({requests.overdue.length})</span>
                </div>
                {requests.overdue.map((req) => (
                  <FollowUpItem
                    key={req.id}
                    request={req}
                    variant="overdue"
                    onClick={() => router.push(`/requests/${req.id}`)}
                  />
                ))}
              </div>
            )}

            {/* Today Section */}
            {requests.today.length > 0 && (
              <div className="space-y-2">
                <div className="flex items-center gap-2 text-yellow-600">
                  <Clock className="w-4 h-4" />
                  <span className="font-medium">Hôm nay ({requests.today.length})</span>
                </div>
                {requests.today.map((req) => (
                  <FollowUpItem
                    key={req.id}
                    request={req}
                    variant="today"
                    onClick={() => router.push(`/requests/${req.id}`)}
                  />
                ))}
              </div>
            )}

            {/* Upcoming Section */}
            {requests.upcoming.length > 0 && (
              <div className="space-y-2">
                <div className="flex items-center gap-2 text-green-600">
                  <Clock className="w-4 h-4" />
                  <span className="font-medium">Sắp tới ({requests.upcoming.length})</span>
                </div>
                {requests.upcoming.map((req) => (
                  <FollowUpItem
                    key={req.id}
                    request={req}
                    variant="upcoming"
                    onClick={() => router.push(`/requests/${req.id}`)}
                  />
                ))}
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
}

function FollowUpItem({
  request,
  variant,
  onClick,
}: {
  request: Request;
  variant: 'overdue' | 'today' | 'upcoming';
  onClick: () => void;
}) {
  const colors = {
    overdue: 'bg-red-50 hover:bg-red-100 border-red-200',
    today: 'bg-yellow-50 hover:bg-yellow-100 border-yellow-200',
    upcoming: 'bg-green-50 hover:bg-green-100 border-green-200',
  };

  return (
    <div
      className={`p-3 rounded-lg border cursor-pointer transition-colors ${colors[variant]}`}
      onClick={onClick}
    >
      <div className="flex justify-between items-start">
        <div>
          <p className="font-medium">{request.customerName}</p>
          <p className="text-sm text-muted-foreground">
            {request.rqid} • {request.country}
          </p>
        </div>
        <Badge variant="outline" className="text-xs">
          {request.status}
        </Badge>
      </div>
      {request.nextFollowUp && (
        <p className="text-xs mt-1 text-muted-foreground">
          {formatDate(request.nextFollowUp)}
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/components/layout/AIAssistant.tsx">
'use client';

import { useState } from 'react';
import { Bot, X, Send, Minimize2, Maximize2, Copy, Mail, MessageSquare } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { cn } from '@/lib/utils';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  actions?: {
    label: string;
    icon: React.ReactNode;
    onClick: () => void;
  }[];
}

export function AIAssistant() {
  const [isOpen, setIsOpen] = useState(false);
  const [isMinimized, setIsMinimized] = useState(false);
  const [input, setInput] = useState('');
  const [messages, setMessages] = useState<Message[]>([
    {
      id: '1',
      role: 'assistant',
      content: 'Xin chào! Tôi là AI Assistant của MyVivaTour. Tôi có thể giúp bạn soạn email, trả lời khách hàng, hoặc tìm kiếm thông tin từ Knowledge Base. Bạn cần hỗ trợ gì?',
      timestamp: new Date(),
    },
  ]);
  const [isLoading, setIsLoading] = useState(false);

  const handleSend = async () => {
    if (!input.trim()) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      role: 'user',
      content: input,
      timestamp: new Date(),
    };

    setMessages((prev) => [...prev, userMessage]);
    setInput('');
    setIsLoading(true);

    // Simulate AI response (will be replaced with actual API call)
    setTimeout(() => {
      const aiResponse: Message = {
        id: (Date.now() + 1).toString(),
        role: 'assistant',
        content: 'Dựa trên Knowledge Base của công ty, đây là gợi ý trả lời:\n\n"Dear Customer,\n\nThank you for your interest in Vietnam tours. Our visa policy for US citizens is as follows:\n\n1. E-visa (recommended): Apply online at https://evisa.xuatnhapcanh.gov.vn\n2. Processing time: 3 working days\n3. Cost: $25 USD\n\nWe can assist you with the application process if needed.\n\nBest regards,\nMyVivaTour Team"',
        timestamp: new Date(),
        actions: [
          {
            label: 'Copy',
            icon: <Copy className="h-4 w-4" />,
            onClick: () => navigator.clipboard.writeText('...'),
          },
          {
            label: 'Gửi Email',
            icon: <Mail className="h-4 w-4" />,
            onClick: () => console.log('Send email'),
          },
          {
            label: 'Gửi Zalo',
            icon: <MessageSquare className="h-4 w-4" />,
            onClick: () => console.log('Send Zalo'),
          },
        ],
      };
      setMessages((prev) => [...prev, aiResponse]);
      setIsLoading(false);
    }, 1500);
  };

  if (!isOpen) {
    return (
      <Button
        onClick={() => setIsOpen(true)}
        className="fixed bottom-6 right-6 h-14 w-14 rounded-full shadow-lg"
        size="icon"
      >
        <Bot className="h-6 w-6" />
      </Button>
    );
  }

  return (
    <Card
      className={cn(
        'fixed bottom-6 right-6 shadow-2xl transition-all duration-300 z-50',
        isMinimized ? 'w-80 h-14' : 'w-96 h-[500px]'
      )}
    >
      <CardHeader className="flex flex-row items-center justify-between p-3 border-b">
        <CardTitle className="text-sm font-medium flex items-center gap-2">
          <Bot className="h-5 w-5 text-primary" />
          AI Assistant
        </CardTitle>
        <div className="flex items-center gap-1">
          <Button
            variant="ghost"
            size="icon"
            className="h-7 w-7"
            onClick={() => setIsMinimized(!isMinimized)}
          >
            {isMinimized ? (
              <Maximize2 className="h-4 w-4" />
            ) : (
              <Minimize2 className="h-4 w-4" />
            )}
          </Button>
          <Button
            variant="ghost"
            size="icon"
            className="h-7 w-7"
            onClick={() => setIsOpen(false)}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      </CardHeader>

      {!isMinimized && (
        <>
          <CardContent className="flex-1 overflow-y-auto p-3 space-y-3 h-[380px]">
            {messages.map((message) => (
              <div
                key={message.id}
                className={cn(
                  'flex flex-col gap-1',
                  message.role === 'user' ? 'items-end' : 'items-start'
                )}
              >
                <div
                  className={cn(
                    'rounded-lg px-3 py-2 max-w-[85%] text-sm',
                    message.role === 'user'
                      ? 'bg-primary text-primary-foreground'
                      : 'bg-muted'
                  )}
                >
                  <p className="whitespace-pre-wrap">{message.content}</p>
                </div>
                {message.actions && (
                  <div className="flex gap-1 mt-1">
                    {message.actions.map((action, idx) => (
                      <Button
                        key={idx}
                        variant="outline"
                        size="sm"
                        className="h-7 text-xs"
                        onClick={action.onClick}
                      >
                        {action.icon}
                        <span className="ml-1">{action.label}</span>
                      </Button>
                    ))}
                  </div>
                )}
              </div>
            ))}
            {isLoading && (
              <div className="flex items-start">
                <div className="bg-muted rounded-lg px-3 py-2">
                  <div className="flex gap-1">
                    <span className="w-2 h-2 bg-primary rounded-full animate-bounce" />
                    <span className="w-2 h-2 bg-primary rounded-full animate-bounce delay-100" />
                    <span className="w-2 h-2 bg-primary rounded-full animate-bounce delay-200" />
                  </div>
                </div>
              </div>
            )}
          </CardContent>

          <div className="p-3 border-t">
            <form
              onSubmit={(e) => {
                e.preventDefault();
                handleSend();
              }}
              className="flex gap-2"
            >
              <Input
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder="Nhập câu hỏi..."
                className="flex-1"
                disabled={isLoading}
              />
              <Button type="submit" size="icon" disabled={isLoading || !input.trim()}>
                <Send className="h-4 w-4" />
              </Button>
            </form>
          </div>
        </>
      )}
    </Card>
  );
}
</file>

<file path="src/components/layout/Header.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Bell, User, Settings, LogOut, Menu } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';

const navigation = [
  { name: 'Dashboard', href: '/' },
  { name: 'Yêu cầu', href: '/requests' },
  { name: 'Operator', href: '/operators' },
  { name: 'Duyệt TT', href: '/operators/approvals', showBadge: true },
  { name: 'NCC', href: '/suppliers' },
  { name: 'Revenue', href: '/revenue' },
];

export function Header() {
  const pathname = usePathname();
  const [overdueCount, setOverdueCount] = useState(0);

  useEffect(() => {
    fetch('/api/operators/pending-payments?filter=overdue')
      .then((res) => res.json())
      .then((data) => {
        if (data.success) {
          setOverdueCount(data.data?.length || 0);
        }
      })
      .catch(() => {
        // Silent fail for badge
      });
  }, []);

  return (
    <header className="sticky top-0 z-50 w-full border-b bg-white shadow-sm">
      <div className="flex h-16 items-center justify-between px-4 md:px-6">
        {/* Logo & Navigation */}
        <div className="flex items-center gap-6">
          {/* Mobile menu button */}
          <Button variant="ghost" size="icon" className="md:hidden">
            <Menu className="h-5 w-5" />
          </Button>

          {/* Logo */}
          <Link href="/" className="flex items-center gap-2">
            <span className="text-2xl">🌴</span>
            <span className="hidden font-bold text-xl text-primary md:block">
              MyVivaTour
            </span>
          </Link>

          {/* Navigation */}
          <nav className="hidden md:flex items-center gap-1">
            {navigation.map((item) => {
              const isActive = pathname === item.href ||
                (item.href !== '/' && pathname.startsWith(item.href));
              const showBadge = 'showBadge' in item && item.showBadge && overdueCount > 0;
              return (
                <Link
                  key={item.name}
                  href={item.href}
                  className={cn(
                    'px-4 py-2 rounded-lg text-sm font-medium transition-colors flex items-center gap-1.5',
                    isActive
                      ? 'bg-primary text-primary-foreground'
                      : 'text-muted-foreground hover:bg-muted hover:text-foreground'
                  )}
                >
                  {item.name}
                  {showBadge && (
                    <Badge variant="destructive" className="h-5 px-1.5 text-xs">
                      {overdueCount}
                    </Badge>
                  )}
                </Link>
              );
            })}
          </nav>
        </div>

        {/* Right side */}
        <div className="flex items-center gap-3">
          {/* Notifications */}
          <Button variant="ghost" size="icon" className="relative">
            <Bell className="h-5 w-5" />
            <Badge
              variant="destructive"
              className="absolute -top-1 -right-1 h-5 w-5 p-0 flex items-center justify-center text-xs"
            >
              3
            </Badge>
          </Button>

          {/* User Menu */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="flex items-center gap-2 px-2">
                <Avatar className="h-8 w-8">
                  <AvatarFallback className="bg-primary text-primary-foreground text-sm">
                    M
                  </AvatarFallback>
                </Avatar>
                <div className="hidden md:block text-left">
                  <p className="text-sm font-medium">Minh</p>
                  <p className="text-xs text-muted-foreground">Admin</p>
                </div>
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-48">
              <DropdownMenuItem>
                <User className="mr-2 h-4 w-4" />
                Tài khoản
              </DropdownMenuItem>
              <DropdownMenuItem asChild>
                <Link href="/settings">
                  <Settings className="mr-2 h-4 w-4" />
                  Cài đặt
                </Link>
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem className="text-destructive">
                <LogOut className="mr-2 h-4 w-4" />
                Đăng xuất
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="src/components/operators/approval-summary-cards.tsx">
'use client';

import { Card, CardContent } from '@/components/ui/card';
import { Clock, AlertCircle, CalendarCheck, CalendarDays } from 'lucide-react';

interface Summary {
  total?: number;
  totalAmount?: number;
  overdue?: number;
  overdueAmount?: number;
  dueToday?: number;
  dueThisWeek?: number;
}

interface Props {
  summary: Summary;
}

const formatCurrency = (value: number) => {
  return new Intl.NumberFormat('vi-VN').format(value);
};

export function ApprovalSummaryCards({ summary }: Props) {
  const cards = [
    {
      title: 'Tổng chờ duyệt',
      value: summary.total || 0,
      subValue: `${formatCurrency(summary.totalAmount || 0)} ₫`,
      icon: Clock,
      color: 'text-blue-600',
      bgColor: 'bg-blue-50',
    },
    {
      title: 'Quá hạn',
      value: summary.overdue || 0,
      subValue: `${formatCurrency(summary.overdueAmount || 0)} ₫`,
      icon: AlertCircle,
      color: 'text-red-600',
      bgColor: 'bg-red-50',
    },
    {
      title: 'Đến hạn hôm nay',
      value: summary.dueToday || 0,
      icon: CalendarCheck,
      color: 'text-yellow-600',
      bgColor: 'bg-yellow-50',
    },
    {
      title: 'Trong tuần này',
      value: summary.dueThisWeek || 0,
      icon: CalendarDays,
      color: 'text-green-600',
      bgColor: 'bg-green-50',
    },
  ];

  return (
    <div className="grid gap-4 md:grid-cols-4">
      {cards.map((card, i) => (
        <Card key={i}>
          <CardContent className="pt-6">
            <div className="flex items-center gap-4">
              <div className={`p-3 rounded-lg ${card.bgColor}`}>
                <card.icon className={`h-6 w-6 ${card.color}`} />
              </div>
              <div>
                <p className="text-sm text-muted-foreground">{card.title}</p>
                <p className="text-2xl font-bold">{card.value}</p>
                {card.subValue && (
                  <p className={`text-sm font-medium ${card.color}`}>{card.subValue}</p>
                )}
              </div>
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
</file>

<file path="src/components/operators/lock-indicator.tsx">
import { Lock, Unlock } from 'lucide-react';
import { Badge } from '@/components/ui/badge';

interface Props {
  isLocked: boolean;
  lockedAt?: Date | string | null;
  lockedBy?: string | null;
}

function formatDate(date: Date | string | null): string {
  if (!date) return 'N/A';
  return new Date(date).toLocaleString('vi-VN');
}

export function LockIndicator({ isLocked, lockedAt, lockedBy }: Props) {
  if (!isLocked) {
    return (
      <Badge variant="outline" className="text-gray-500">
        <Unlock className="h-3 w-3 mr-1" />
        Chưa khóa
      </Badge>
    );
  }

  const tooltipText = `Khóa lúc: ${formatDate(lockedAt ?? null)}\nBởi: ${lockedBy || 'N/A'}`;

  return (
    <Badge
      variant="secondary"
      className="text-amber-700 bg-amber-50 cursor-help"
      title={tooltipText}
    >
      <Lock className="h-3 w-3 mr-1" />
      Đã khóa
    </Badge>
  );
}
</file>

<file path="src/components/operators/reports/cost-by-service-chart.tsx">
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { formatCurrency } from '@/lib/utils';
import type { CostByServiceType } from '@/types';

interface Props {
  data: CostByServiceType[];
  totalCost: number;
}

export function CostByServiceChart({ data, totalCost }: Props) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Chi phí theo loại dịch vụ</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {data.length === 0 ? (
          <p className="text-muted-foreground text-center py-4">Không có dữ liệu</p>
        ) : (
          data.map((item) => {
            const percentage = totalCost > 0 ? (item.total / totalCost) * 100 : 0;
            return (
              <div key={item.type} className="space-y-1">
                <div className="flex justify-between text-sm">
                  <span>{item.label}</span>
                  <span className="font-medium">
                    {formatCurrency(item.total)} ₫ ({item.count})
                  </span>
                </div>
                <div className="h-2 bg-gray-100 rounded-full overflow-hidden">
                  <div
                    className="h-full bg-blue-500 rounded-full transition-all"
                    style={{ width: `${percentage}%` }}
                  />
                </div>
              </div>
            );
          })
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/operators/reports/cost-by-supplier-table.tsx">
'use client';

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { formatCurrency } from '@/lib/utils';
import type { CostBySupplier } from '@/types';

interface Props {
  data: CostBySupplier[];
}

export function CostBySupplierTable({ data }: Props) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Chi phí theo NCC</CardTitle>
      </CardHeader>
      <CardContent>
        {data.length === 0 ? (
          <p className="text-muted-foreground text-center py-4">Không có dữ liệu</p>
        ) : (
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>NCC</TableHead>
                <TableHead className="text-right">Số lượng</TableHead>
                <TableHead className="text-right">Tổng chi phí</TableHead>
                <TableHead className="text-right">TB/dịch vụ</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.map((item, i) => (
                <TableRow key={item.supplierId || i}>
                  <TableCell>{item.supplierName}</TableCell>
                  <TableCell className="text-right">{item.count}</TableCell>
                  <TableCell className="text-right font-medium">
                    {formatCurrency(item.total)} ₫
                  </TableCell>
                  <TableCell className="text-right text-muted-foreground">
                    {formatCurrency(item.count > 0 ? Math.round(item.total / item.count) : 0)} ₫
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/operators/reports/monthly-trend.tsx">
'use client';

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { formatCurrency } from '@/lib/utils';
import type { CostByMonth } from '@/types';

interface Props {
  data: CostByMonth[];
}

// Format YYYY-MM to Vietnamese month label
function formatMonth(month: string): string {
  const [year, m] = month.split('-');
  return `Tháng ${parseInt(m)}/${year}`;
}

export function MonthlyTrend({ data }: Props) {
  const total = data.reduce((sum, item) => sum + item.total, 0);
  const totalCount = data.reduce((sum, item) => sum + item.count, 0);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Xu hướng theo tháng</CardTitle>
      </CardHeader>
      <CardContent>
        {data.length === 0 ? (
          <p className="text-muted-foreground text-center py-4">Không có dữ liệu</p>
        ) : (
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Tháng</TableHead>
                <TableHead className="text-right">Số dịch vụ</TableHead>
                <TableHead className="text-right">Tổng chi phí</TableHead>
                <TableHead className="text-right">% Tổng</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {data.map((item) => {
                const percentage = total > 0 ? ((item.total / total) * 100).toFixed(1) : '0';
                return (
                  <TableRow key={item.month}>
                    <TableCell className="font-medium">{formatMonth(item.month)}</TableCell>
                    <TableCell className="text-right">{item.count}</TableCell>
                    <TableCell className="text-right font-medium">
                      {formatCurrency(item.total)} ₫
                    </TableCell>
                    <TableCell className="text-right text-muted-foreground">
                      {percentage}%
                    </TableCell>
                  </TableRow>
                );
              })}
              {/* Total row */}
              <TableRow className="bg-muted/50 font-semibold">
                <TableCell>Tổng cộng</TableCell>
                <TableCell className="text-right">{totalCount}</TableCell>
                <TableCell className="text-right">{formatCurrency(total)} ₫</TableCell>
                <TableCell className="text-right">100%</TableCell>
              </TableRow>
            </TableBody>
          </Table>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/operators/reports/payment-status-cards.tsx">
'use client';

import { Card, CardContent } from '@/components/ui/card';
import { formatCurrency } from '@/lib/utils';
import { Clock, AlertTriangle, CalendarCheck, CheckCircle } from 'lucide-react';
import type { PaymentStatusReport } from '@/types';

interface Props {
  data: PaymentStatusReport;
}

export function PaymentStatusCards({ data }: Props) {
  const cards = [
    {
      title: 'Chờ thanh toán',
      count: data.pending.count,
      amount: data.pending.total,
      icon: Clock,
      color: 'text-yellow-600',
      bg: 'bg-yellow-50',
    },
    {
      title: 'Quá hạn',
      count: data.overdue.count,
      amount: data.overdue.total,
      icon: AlertTriangle,
      color: 'text-red-600',
      bg: 'bg-red-50',
    },
    {
      title: 'Đến hạn tuần này',
      count: data.dueThisWeek.count,
      amount: data.dueThisWeek.total,
      icon: CalendarCheck,
      color: 'text-orange-600',
      bg: 'bg-orange-50',
    },
    {
      title: 'Đã TT tháng này',
      count: data.paidThisMonth.count,
      amount: data.paidThisMonth.total,
      icon: CheckCircle,
      color: 'text-green-600',
      bg: 'bg-green-50',
    },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {cards.map((card) => (
        <Card key={card.title} className={card.bg}>
          <CardContent className="pt-6">
            <div className="flex items-center gap-3">
              <card.icon className={`h-8 w-8 ${card.color}`} />
              <div>
                <p className="text-sm text-gray-600">{card.title}</p>
                <p className="text-2xl font-bold">{card.count}</p>
                <p className={`text-sm font-medium ${card.color}`}>
                  {formatCurrency(card.amount)} ₫
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      ))}
    </div>
  );
}
</file>

<file path="src/components/requests/request-status-badge.tsx">
'use client';

import { Badge } from '@/components/ui/badge';
import { REQUEST_STATUSES, REQUEST_STAGES } from '@/config/request-config';
import type { RequestStatus, RequestStage } from '@/types';

// Static color mapping for Tailwind JIT compiler
const COLOR_CLASSES = {
  blue: {
    stage: 'text-blue-600',
    badge: 'bg-blue-100 text-blue-700 border-blue-300',
  },
  purple: {
    stage: 'text-purple-600',
    badge: 'bg-purple-100 text-purple-700 border-purple-300',
  },
  orange: {
    stage: 'text-orange-600',
    badge: 'bg-orange-100 text-orange-700 border-orange-300',
  },
  gray: {
    stage: 'text-gray-600',
    badge: 'bg-gray-100 text-gray-700 border-gray-300',
  },
  green: {
    stage: 'text-green-600',
    badge: 'bg-green-100 text-green-700 border-green-300',
  },
  red: {
    stage: 'text-red-600',
    badge: 'bg-red-100 text-red-700 border-red-300',
  },
  yellow: {
    stage: 'text-yellow-600',
    badge: 'bg-yellow-100 text-yellow-700 border-yellow-300',
  },
} as const;

type ColorKey = keyof typeof COLOR_CLASSES;

interface RequestStatusBadgeProps {
  status: RequestStatus;
  showStage?: boolean;
}

export function RequestStatusBadge({ status, showStage = false }: RequestStatusBadgeProps) {
  const config = REQUEST_STATUSES[status];
  if (!config) {
    return (
      <Badge variant="outline" className="bg-gray-100 text-gray-700">
        {status}
      </Badge>
    );
  }

  const stageConfig = REQUEST_STAGES[config.stage as RequestStage];
  const colorClasses = COLOR_CLASSES[config.color as ColorKey] || COLOR_CLASSES.gray;
  const stageColorClasses = stageConfig
    ? COLOR_CLASSES[stageConfig.color as ColorKey] || COLOR_CLASSES.gray
    : COLOR_CLASSES.gray;

  return (
    <div className="flex items-center gap-1">
      {showStage && stageConfig && (
        <span className={`text-xs font-medium ${stageColorClasses.stage}`}>
          {stageConfig.label}:
        </span>
      )}
      <Badge variant="outline" className={colorClasses.badge}>
        {config.label}
      </Badge>
    </div>
  );
}
</file>

<file path="src/components/requests/request-table.tsx">
'use client';

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { RequestStatusBadge } from './request-status-badge';
import { formatDate } from '@/lib/utils';
import type { Request, RequestStatus } from '@/types';

interface RequestTableProps {
  requests: Request[];
  onRowClick?: (request: Request) => void;
  isLoading?: boolean;
}

export function RequestTable({ requests, onRowClick, isLoading = false }: RequestTableProps) {
  if (isLoading) {
    return <div className="p-8 text-center text-muted-foreground">Đang tải...</div>;
  }

  return (
    <Table>
      <TableHeader>
        <TableRow>
          <TableHead>RQID</TableHead>
          <TableHead>Khách hàng</TableHead>
          <TableHead>Pax</TableHead>
          <TableHead>Quốc gia</TableHead>
          <TableHead>Nguồn</TableHead>
          <TableHead>Trạng thái</TableHead>
          <TableHead>Follow-up</TableHead>
          <TableHead>Seller</TableHead>
          <TableHead>Ngày nhận</TableHead>
        </TableRow>
      </TableHeader>
      <TableBody>
        {requests.length === 0 ? (
          <TableRow>
            <TableCell colSpan={9} className="text-center py-8 text-muted-foreground">
              Không có yêu cầu nào
            </TableCell>
          </TableRow>
        ) : (
          requests.map((req) => (
            <TableRow
              key={req.id}
              onClick={() => onRowClick?.(req)}
              className={onRowClick ? 'cursor-pointer hover:bg-muted/50' : ''}
            >
              <TableCell className="font-mono">{req.rqid || req.code}</TableCell>
              <TableCell className="font-medium">{req.customerName}</TableCell>
              <TableCell>{req.pax}</TableCell>
              <TableCell>{req.country}</TableCell>
              <TableCell>{req.source}</TableCell>
              <TableCell>
                <RequestStatusBadge status={req.status as RequestStatus} />
              </TableCell>
              <TableCell>
                <FollowUpIndicator date={req.nextFollowUp} />
              </TableCell>
              <TableCell>{req.seller?.name || '-'}</TableCell>
              <TableCell>{formatDate(req.receivedDate)}</TableCell>
            </TableRow>
          ))
        )}
      </TableBody>
    </Table>
  );
}

// Helper component for follow-up indicator
function FollowUpIndicator({ date }: { date: Date | null }) {
  if (!date) return <span className="text-muted-foreground">-</span>;

  const now = new Date();
  const followUp = new Date(date);
  const diffDays = Math.ceil((followUp.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

  let color = 'text-green-600';
  let label = formatDate(date);

  if (diffDays < 0) {
    color = 'text-red-600';
    label = `Quá hạn ${Math.abs(diffDays)} ngày`;
  } else if (diffDays === 0) {
    color = 'text-yellow-600';
    label = 'Hôm nay';
  } else if (diffDays <= 3) {
    color = 'text-orange-600';
  }

  return <span className={`${color} text-sm font-medium`}>{label}</span>;
}
</file>

<file path="src/components/suppliers/edit-supplier-modal.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Edit } from 'lucide-react';
import { toast } from 'sonner';
import {
  SUPPLIER_TYPES,
  SUPPLIER_TYPE_KEYS,
  SUPPLIER_LOCATIONS,
  SUPPLIER_LOCATION_KEYS,
  PAYMENT_MODELS,
  CUSTOM_LOCATION,
} from '@/config/supplier-config';
import type { Supplier, PaymentModel } from '@/types';

interface EditSupplierModalProps {
  supplier: Supplier;
  onSuccess: () => void;
}

interface FormData {
  name: string;
  type: string;
  location: string;
  paymentModel: PaymentModel;
  creditLimit: string;
  paymentTermDays: string;
  contactName: string;
  contactPhone: string;
  contactEmail: string;
  bankAccount: string;
  isActive: boolean;
  notes: string;
}

export function EditSupplierModal({ supplier, onSuccess }: EditSupplierModalProps) {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);

  // Initialize form data from supplier
  const getInitialFormData = useCallback((): FormData => ({
    name: supplier.name,
    type: supplier.type,
    location: supplier.location || '',
    paymentModel: supplier.paymentModel,
    creditLimit: supplier.creditLimit?.toString() || '',
    paymentTermDays: supplier.paymentTermDays?.toString() || '',
    contactName: supplier.contactName || '',
    contactPhone: supplier.contactPhone || '',
    contactEmail: supplier.contactEmail || '',
    bankAccount: supplier.bankAccount || '',
    isActive: supplier.isActive,
    notes: supplier.notes || '',
  }), [supplier]);

  const [formData, setFormData] = useState<FormData>(getInitialFormData);

  // Reset form when dialog opens with fresh supplier data
  useEffect(() => {
    if (open) {
      setFormData(getInitialFormData());
    }
  }, [open, getInitialFormData]);

  const updateField = (field: keyof FormData, value: string | boolean) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();

    // Client-side validation
    if (!formData.name.trim()) {
      toast.error('Tên NCC không được để trống');
      return;
    }
    if (!formData.type) {
      toast.error('Vui lòng chọn loại NCC');
      return;
    }

    setLoading(true);
    try {
      const res = await fetch(`/api/suppliers/${supplier.id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          name: formData.name.trim(),
          type: formData.type,
          location: formData.location || null,
          paymentModel: formData.paymentModel,
          creditLimit: formData.creditLimit ? parseInt(formData.creditLimit, 10) : null,
          paymentTermDays: formData.paymentTermDays ? parseInt(formData.paymentTermDays, 10) : null,
          contactName: formData.contactName.trim() || null,
          contactPhone: formData.contactPhone.trim() || null,
          contactEmail: formData.contactEmail.trim() || null,
          bankAccount: formData.bankAccount.trim() || null,
          isActive: formData.isActive,
          notes: formData.notes.trim() || null,
        }),
      });

      const data = await res.json();

      if (!data.success) {
        toast.error(data.error || 'Có lỗi xảy ra');
        return;
      }

      toast.success('Cập nhật NCC thành công');
      setOpen(false);
      onSuccess();
    } catch {
      toast.error('Có lỗi xảy ra khi lưu dữ liệu');
    } finally {
      setLoading(false);
    }
  }

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button variant="outline">
          <Edit className="mr-2 h-4 w-4" /> Sửa
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[600px] max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Sửa thông tin NCC</DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Basic Info */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="name">Tên NCC *</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => updateField('name', e.target.value)}
                placeholder="VD: An Khánh Hotel"
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="type">Loại NCC *</Label>
              <Select
                value={formData.type}
                onValueChange={(v) => updateField('type', v)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Chọn loại NCC" />
                </SelectTrigger>
                <SelectContent>
                  {SUPPLIER_TYPE_KEYS.map((key) => (
                    <SelectItem key={key} value={key}>
                      {SUPPLIER_TYPES[key].label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Location & Payment */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="location">Địa phương</Label>
              <Select
                value={formData.location || 'none'}
                onValueChange={(v) => updateField('location', v === 'none' ? '' : v)}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Chọn địa phương" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="none">-- Không chọn --</SelectItem>
                  {SUPPLIER_LOCATION_KEYS.map((key) => (
                    <SelectItem key={key} value={key}>
                      {SUPPLIER_LOCATIONS[key].label}
                    </SelectItem>
                  ))}
                  <SelectItem value={CUSTOM_LOCATION}>Khác</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label htmlFor="paymentModel">Hình thức thanh toán *</Label>
              <Select
                value={formData.paymentModel}
                onValueChange={(v) => updateField('paymentModel', v as PaymentModel)}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {Object.entries(PAYMENT_MODELS).map(([key, value]) => (
                    <SelectItem key={key} value={key}>
                      {value.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Credit fields - conditional */}
          {formData.paymentModel === 'CREDIT' && (
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="creditLimit">Hạn mức công nợ</Label>
                <Input
                  id="creditLimit"
                  type="number"
                  value={formData.creditLimit}
                  onChange={(e) => updateField('creditLimit', e.target.value)}
                  placeholder="100000000"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="paymentTermDays">Số ngày thanh toán</Label>
                <Input
                  id="paymentTermDays"
                  type="number"
                  value={formData.paymentTermDays}
                  onChange={(e) => updateField('paymentTermDays', e.target.value)}
                  placeholder="30"
                />
              </div>
            </div>
          )}

          {/* Contact Info */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="contactName">Người liên hệ</Label>
              <Input
                id="contactName"
                value={formData.contactName}
                onChange={(e) => updateField('contactName', e.target.value)}
                placeholder="Nguyễn Văn A"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="contactPhone">Số điện thoại</Label>
              <Input
                id="contactPhone"
                value={formData.contactPhone}
                onChange={(e) => updateField('contactPhone', e.target.value)}
                placeholder="0901234567"
              />
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="contactEmail">Email</Label>
              <Input
                id="contactEmail"
                type="email"
                value={formData.contactEmail}
                onChange={(e) => updateField('contactEmail', e.target.value)}
                placeholder="contact@supplier.com"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="bankAccount">Tài khoản ngân hàng</Label>
              <Input
                id="bankAccount"
                value={formData.bankAccount}
                onChange={(e) => updateField('bankAccount', e.target.value)}
                placeholder="0123456789 - Vietcombank"
              />
            </div>
          </div>

          {/* Status */}
          <div className="space-y-2">
            <Label htmlFor="isActive">Trạng thái</Label>
            <Select
              value={formData.isActive ? 'true' : 'false'}
              onValueChange={(v) => updateField('isActive', v === 'true')}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="true">Đang hoạt động</SelectItem>
                <SelectItem value="false">Ngừng hoạt động</SelectItem>
              </SelectContent>
            </Select>
          </div>

          {/* Notes */}
          <div className="space-y-2">
            <Label htmlFor="notes">Ghi chú</Label>
            <Textarea
              id="notes"
              value={formData.notes}
              onChange={(e) => updateField('notes', e.target.value)}
              placeholder="Ghi chú về NCC..."
              rows={2}
            />
          </div>

          {/* Actions */}
          <div className="flex justify-end gap-2 pt-4">
            <Button type="button" variant="outline" onClick={() => setOpen(false)}>
              Hủy
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? 'Đang lưu...' : 'Lưu thay đổi'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/suppliers/supplier-form.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import {
  SUPPLIER_TYPES,
  SUPPLIER_TYPE_KEYS,
  SUPPLIER_LOCATIONS,
  SUPPLIER_LOCATION_KEYS,
  PAYMENT_MODELS,
  CUSTOM_LOCATION,
  generateSupplierCode,
  type SupplierTypeKey,
  type SupplierLocationKey,
} from '@/config/supplier-config';
import type { Supplier, PaymentModel } from '@/types';

interface SupplierFormProps {
  supplier?: Supplier;
  onSuccess?: () => void;
}

export function SupplierForm({ supplier, onSuccess }: SupplierFormProps) {
  const router = useRouter();
  const isEditing = !!supplier;

  const [formData, setFormData] = useState({
    code: supplier?.code || '',
    name: supplier?.name || '',
    type: supplier?.type || '',
    location: supplier?.location || '',
    customLocation: '',
    paymentModel: supplier?.paymentModel || 'PREPAID' as PaymentModel,
    creditLimit: supplier?.creditLimit?.toString() || '',
    paymentTermDays: supplier?.paymentTermDays?.toString() || '',
    contactName: supplier?.contactName || '',
    contactPhone: supplier?.contactPhone || '',
    contactEmail: supplier?.contactEmail || '',
    bankAccount: supplier?.bankAccount || '',
    isActive: supplier?.isActive ?? true,
    notes: supplier?.notes || '',
  });

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [generatedCode, setGeneratedCode] = useState('');

  // Check if location is custom (not in predefined list)
  const isCustomLocation = formData.location === CUSTOM_LOCATION ||
    (formData.location && !(formData.location in SUPPLIER_LOCATIONS));

  // Generate code when type, name, or location changes
  const fetchGeneratedCode = useCallback(async () => {
    if (!formData.type || !formData.name || isEditing) return;

    try {
      const locationParam = isCustomLocation ? '' : formData.location;
      const params = new URLSearchParams({
        type: formData.type,
        name: formData.name,
        ...(locationParam && { location: locationParam }),
      });

      const res = await fetch(`/api/suppliers/generate-code?${params}`);
      const data = await res.json();

      if (data.success) {
        setGeneratedCode(data.data.code);
      }
    } catch (err) {
      console.error('Error generating code:', err);
      // Fallback to client-side generation
      const code = generateSupplierCode(
        formData.type as SupplierTypeKey,
        formData.name,
        isCustomLocation ? null : formData.location as SupplierLocationKey,
        1
      );
      setGeneratedCode(code);
    }
  }, [formData.type, formData.name, formData.location, isCustomLocation, isEditing]);

  useEffect(() => {
    const debounce = setTimeout(() => {
      fetchGeneratedCode();
    }, 300);
    return () => clearTimeout(debounce);
  }, [fetchGeneratedCode]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const url = isEditing ? `/api/suppliers/${supplier.id}` : '/api/suppliers';
      const method = isEditing ? 'PUT' : 'POST';

      // Determine final location value
      let finalLocation: string | undefined = formData.location || undefined;
      if (formData.location === CUSTOM_LOCATION && formData.customLocation) {
        finalLocation = formData.customLocation;
      } else if (!formData.location || formData.location === 'none') {
        finalLocation = undefined;
      }

      const body = {
        code: isEditing ? formData.code : generatedCode, // Use generated code for new suppliers
        name: formData.name,
        type: formData.type,
        location: finalLocation,
        paymentModel: formData.paymentModel,
        creditLimit: formData.creditLimit ? parseInt(formData.creditLimit) : null,
        paymentTermDays: formData.paymentTermDays ? parseInt(formData.paymentTermDays) : null,
        contactName: formData.contactName,
        contactPhone: formData.contactPhone,
        contactEmail: formData.contactEmail,
        bankAccount: formData.bankAccount,
        isActive: formData.isActive,
        notes: formData.notes,
      };

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });

      const data = await res.json();

      if (!data.success) {
        setError(data.error || 'Có lỗi xảy ra');
        return;
      }

      if (onSuccess) {
        onSuccess();
      } else {
        router.push(`/suppliers/${data.data.id}`);
      }
    } catch {
      setError('Có lỗi xảy ra khi lưu dữ liệu');
    } finally {
      setLoading(false);
    }
  };

  const updateField = (field: string, value: string | boolean) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="bg-red-50 text-red-600 p-4 rounded-lg">
          {error}
        </div>
      )}

      {/* Basic Info */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin cơ bản</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Type and Name row */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="type">Loại NCC *</Label>
              <Select
                value={formData.type}
                onValueChange={(v) => updateField('type', v)}
                disabled={isEditing}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Chọn loại NCC" />
                </SelectTrigger>
                <SelectContent>
                  {SUPPLIER_TYPE_KEYS.map((key) => (
                    <SelectItem key={key} value={key}>
                      {SUPPLIER_TYPES[key].label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label htmlFor="name">Tên NCC *</Label>
              <Input
                id="name"
                value={formData.name}
                onChange={(e) => updateField('name', e.target.value)}
                placeholder="VD: An Khánh Hotel"
                required
              />
            </div>
          </div>

          {/* Location row */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="location">Địa phương</Label>
              <Select
                value={formData.location || 'none'}
                onValueChange={(v) => {
                  updateField('location', v === 'none' ? '' : v);
                  if (v !== CUSTOM_LOCATION) {
                    updateField('customLocation', '');
                  }
                }}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Chọn địa phương (tùy chọn)" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="none">-- Không chọn --</SelectItem>
                  {SUPPLIER_LOCATION_KEYS.map((key) => (
                    <SelectItem key={key} value={key}>
                      {SUPPLIER_LOCATIONS[key].label}
                    </SelectItem>
                  ))}
                  <SelectItem value={CUSTOM_LOCATION}>Khác (nhập tay)</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Custom location input */}
            {formData.location === CUSTOM_LOCATION && (
              <div className="space-y-2">
                <Label htmlFor="customLocation">Địa phương khác</Label>
                <Input
                  id="customLocation"
                  value={formData.customLocation}
                  onChange={(e) => updateField('customLocation', e.target.value)}
                  placeholder="Nhập tên địa phương"
                />
              </div>
            )}

            {/* Generated Code Display */}
            {!isEditing && formData.location !== CUSTOM_LOCATION && (
              <div className="space-y-2">
                <Label>Mã NCC (tự động)</Label>
                <Input
                  value={generatedCode || 'Nhập loại và tên để tạo mã...'}
                  readOnly
                  className="bg-gray-100 font-mono"
                />
              </div>
            )}
          </div>

          {/* Show code for editing or after custom location */}
          {(isEditing || formData.location === CUSTOM_LOCATION) && (
            <div className="space-y-2">
              <Label>Mã NCC {isEditing ? '' : '(tự động)'}</Label>
              <Input
                value={isEditing ? formData.code : (generatedCode || 'Nhập loại và tên để tạo mã...')}
                readOnly
                className="bg-gray-100 font-mono"
              />
            </div>
          )}

          {/* Payment model row */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="paymentModel">Hình thức thanh toán *</Label>
              <Select
                value={formData.paymentModel}
                onValueChange={(v) => updateField('paymentModel', v)}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {Object.entries(PAYMENT_MODELS).map(([key, value]) => (
                    <SelectItem key={key} value={key}>
                      {value.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {formData.paymentModel === 'CREDIT' && (
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="creditLimit">Hạn mức công nợ</Label>
                <Input
                  id="creditLimit"
                  type="number"
                  value={formData.creditLimit}
                  onChange={(e) => updateField('creditLimit', e.target.value)}
                  placeholder="100000000"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="paymentTermDays">Số ngày thanh toán</Label>
                <Input
                  id="paymentTermDays"
                  type="number"
                  value={formData.paymentTermDays}
                  onChange={(e) => updateField('paymentTermDays', e.target.value)}
                  placeholder="30"
                />
              </div>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Contact Info */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin liên hệ</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="contactName">Người liên hệ</Label>
              <Input
                id="contactName"
                value={formData.contactName}
                onChange={(e) => updateField('contactName', e.target.value)}
                placeholder="Nguyễn Văn A"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="contactPhone">Số điện thoại</Label>
              <Input
                id="contactPhone"
                value={formData.contactPhone}
                onChange={(e) => updateField('contactPhone', e.target.value)}
                placeholder="0901234567"
              />
            </div>
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="contactEmail">Email</Label>
              <Input
                id="contactEmail"
                type="email"
                value={formData.contactEmail}
                onChange={(e) => updateField('contactEmail', e.target.value)}
                placeholder="contact@supplier.com"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="bankAccount">Tài khoản ngân hàng</Label>
              <Input
                id="bankAccount"
                value={formData.bankAccount}
                onChange={(e) => updateField('bankAccount', e.target.value)}
                placeholder="0123456789 - Vietcombank"
              />
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Status & Notes */}
      <Card>
        <CardHeader>
          <CardTitle>Trạng thái</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="isActive">Trạng thái</Label>
            <Select
              value={formData.isActive ? 'true' : 'false'}
              onValueChange={(v) => updateField('isActive', v === 'true')}
            >
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="true">Đang hoạt động</SelectItem>
                <SelectItem value="false">Ngừng hoạt động</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="notes">Ghi chú</Label>
            <Textarea
              id="notes"
              value={formData.notes}
              onChange={(e) => updateField('notes', e.target.value)}
              placeholder="Ghi chú về NCC..."
              rows={3}
            />
          </div>
        </CardContent>
      </Card>

      {/* Actions */}
      <div className="flex gap-4">
        <Button type="submit" disabled={loading || (!isEditing && !generatedCode)}>
          {loading ? 'Đang lưu...' : isEditing ? 'Cập nhật' : 'Tạo NCC'}
        </Button>
        <Button type="button" variant="outline" onClick={() => router.back()}>
          Hủy
        </Button>
      </div>
    </form>
  );
}
</file>

<file path="src/components/suppliers/supplier-selector.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';

interface Supplier {
  id: string;
  code: string;
  name: string;
  type: string;
}

interface SupplierSelectorProps {
  value?: string;
  onChange: (supplierId: string) => void;
  filterByType?: string;
  placeholder?: string;
  disabled?: boolean;
}

export function SupplierSelector({
  value,
  onChange,
  filterByType,
  placeholder = 'Chọn NCC',
  disabled = false,
}: SupplierSelectorProps) {
  const [suppliers, setSuppliers] = useState<Supplier[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchSuppliers = useCallback(async () => {
    setLoading(true);
    const params = new URLSearchParams();
    params.set('isActive', 'true');
    if (filterByType) params.set('type', filterByType);

    const res = await fetch(`/api/suppliers?${params}`);
    const data = await res.json();
    if (data.success) {
      setSuppliers(data.data);
    }
    setLoading(false);
  }, [filterByType]);

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect
    fetchSuppliers();
  }, [fetchSuppliers]);

  if (loading) {
    return (
      <Select disabled>
        <SelectTrigger>
          <SelectValue placeholder="Đang tải..." />
        </SelectTrigger>
      </Select>
    );
  }

  return (
    <Select value={value} onValueChange={onChange} disabled={disabled}>
      <SelectTrigger>
        <SelectValue placeholder={placeholder} />
      </SelectTrigger>
      <SelectContent>
        {suppliers.length === 0 ? (
          <div className="py-2 px-3 text-sm text-muted-foreground">
            Không có NCC
          </div>
        ) : (
          suppliers.map((supplier) => (
            <SelectItem key={supplier.id} value={supplier.id}>
              {supplier.code} - {supplier.name}
            </SelectItem>
          ))
        )}
      </SelectContent>
    </Select>
  );
}
</file>

<file path="src/components/suppliers/transaction-form.tsx">
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Plus } from 'lucide-react';
import type { TransactionType } from '@/types';

interface TransactionFormProps {
  supplierId: string;
  onSuccess: () => void;
  defaultType?: TransactionType;
}

export function TransactionForm({ supplierId, onSuccess, defaultType = 'DEPOSIT' }: TransactionFormProps) {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const [formData, setFormData] = useState({
    type: defaultType,
    amount: '',
    transactionDate: new Date().toISOString().split('T')[0],
    description: '',
    proofLink: '',
    relatedBookingCode: '',
  });

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      const res = await fetch('/api/supplier-transactions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          supplierId,
          ...formData,
          amount: parseInt(formData.amount),
        }),
      });

      const data = await res.json();

      if (!data.success) {
        setError(data.error || 'Có lỗi xảy ra');
        return;
      }

      // Reset form and close
      setFormData({
        type: defaultType,
        amount: '',
        transactionDate: new Date().toISOString().split('T')[0],
        description: '',
        proofLink: '',
        relatedBookingCode: '',
      });
      setOpen(false);
      onSuccess();
    } catch {
      setError('Có lỗi xảy ra khi lưu dữ liệu');
    } finally {
      setLoading(false);
    }
  };

  const updateField = (field: string, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  const getTypeLabel = (type: string) => {
    switch (type) {
      case 'DEPOSIT': return 'Nạp tiền';
      case 'REFUND': return 'Hoàn tiền';
      case 'ADJUSTMENT': return 'Điều chỉnh';
      case 'FEE': return 'Phí dịch vụ';
      default: return type;
    }
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button>
          <Plus className="mr-2 h-4 w-4" /> Thêm giao dịch
        </Button>
      </DialogTrigger>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>Thêm giao dịch mới</DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="space-y-4">
          {error && (
            <div className="bg-red-50 text-red-600 p-3 rounded-lg text-sm">
              {error}
            </div>
          )}

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="type">Loại giao dịch *</Label>
              <Select value={formData.type} onValueChange={(v) => updateField('type', v)}>
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="DEPOSIT">{getTypeLabel('DEPOSIT')}</SelectItem>
                  <SelectItem value="REFUND">{getTypeLabel('REFUND')}</SelectItem>
                  <SelectItem value="ADJUSTMENT">{getTypeLabel('ADJUSTMENT')}</SelectItem>
                  <SelectItem value="FEE">{getTypeLabel('FEE')}</SelectItem>
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label htmlFor="amount">Số tiền (VND) *</Label>
              <Input
                id="amount"
                type="number"
                value={formData.amount}
                onChange={(e) => updateField('amount', e.target.value)}
                placeholder="10000000"
                required
              />
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="transactionDate">Ngày giao dịch *</Label>
            <Input
              id="transactionDate"
              type="date"
              value={formData.transactionDate}
              onChange={(e) => updateField('transactionDate', e.target.value)}
              required
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="description">Mô tả</Label>
            <Textarea
              id="description"
              value={formData.description}
              onChange={(e) => updateField('description', e.target.value)}
              placeholder="Nạp tiền tháng 1/2026..."
              rows={2}
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="proofLink">Link chứng từ</Label>
              <Input
                id="proofLink"
                value={formData.proofLink}
                onChange={(e) => updateField('proofLink', e.target.value)}
                placeholder="https://..."
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="relatedBookingCode">Mã booking (nếu có)</Label>
              <Input
                id="relatedBookingCode"
                value={formData.relatedBookingCode}
                onChange={(e) => updateField('relatedBookingCode', e.target.value)}
                placeholder="260101-JOHN"
              />
            </div>
          </div>

          <div className="flex justify-end gap-2 pt-4">
            <Button type="button" variant="outline" onClick={() => setOpen(false)}>
              Hủy
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? 'Đang lưu...' : 'Lưu giao dịch'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-full border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react"
import {
  DayPicker,
  getDefaultClassNames,
  type DayButton,
} from "react-day-picker"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"]
}) {
  const defaultClassNames = getDefaultClassNames()

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "bg-background group/calendar p-3 [--cell-size:--spacing(8)] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "flex gap-4 flex-col md:flex-row relative",
          defaultClassNames.months
        ),
        month: cn("flex flex-col w-full gap-4", defaultClassNames.month),
        nav: cn(
          "flex items-center gap-1 w-full absolute top-0 inset-x-0 justify-between",
          defaultClassNames.nav
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_previous
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "size-(--cell-size) aria-disabled:opacity-50 p-0 select-none",
          defaultClassNames.button_next
        ),
        month_caption: cn(
          "flex items-center justify-center h-(--cell-size) w-full px-(--cell-size)",
          defaultClassNames.month_caption
        ),
        dropdowns: cn(
          "w-full flex items-center text-sm font-medium justify-center h-(--cell-size) gap-1.5",
          defaultClassNames.dropdowns
        ),
        dropdown_root: cn(
          "relative has-focus:border-ring border border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] rounded-md",
          defaultClassNames.dropdown_root
        ),
        dropdown: cn(
          "absolute bg-popover inset-0 opacity-0",
          defaultClassNames.dropdown
        ),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "rounded-md pl-2 pr-1 flex items-center gap-1 text-sm h-8 [&>svg]:text-muted-foreground [&>svg]:size-3.5",
          defaultClassNames.caption_label
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground rounded-md flex-1 font-normal text-[0.8rem] select-none",
          defaultClassNames.weekday
        ),
        week: cn("flex w-full mt-2", defaultClassNames.week),
        week_number_header: cn(
          "select-none w-(--cell-size)",
          defaultClassNames.week_number_header
        ),
        week_number: cn(
          "text-[0.8rem] select-none text-muted-foreground",
          defaultClassNames.week_number
        ),
        day: cn(
          "relative w-full h-full p-0 text-center [&:last-child[data-selected=true]_button]:rounded-r-md group/day aspect-square select-none",
          props.showWeekNumber
            ? "[&:nth-child(2)[data-selected=true]_button]:rounded-l-md"
            : "[&:first-child[data-selected=true]_button]:rounded-l-md",
          defaultClassNames.day
        ),
        range_start: cn(
          "rounded-l-md bg-accent",
          defaultClassNames.range_start
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("rounded-r-md bg-accent", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          )
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            )
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            )
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          )
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-(--cell-size) items-center justify-center text-center">
                {children}
              </div>
            </td>
          )
        },
        ...components,
      }}
      {...props}
    />
  )
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames()

  const ref = React.useRef<HTMLButtonElement>(null)
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus()
  }, [modifiers.focused])

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 dark:hover:text-accent-foreground flex aspect-square size-auto w-full min-w-(--cell-size) flex-col gap-1 leading-none font-normal group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] data-[range-end=true]:rounded-md data-[range-end=true]:rounded-r-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md data-[range-start=true]:rounded-l-md [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className
      )}
      {...props}
    />
  )
}

export { Calendar, CalendarDayButton }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="src/components/ui/checkbox.tsx">
'use client';

import * as React from 'react';
import * as CheckboxPrimitive from '@radix-ui/react-checkbox';
import { Check } from 'lucide-react';

import { cn } from '@/lib/utils';

const Checkbox = React.forwardRef<
  React.ComponentRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      'peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground',
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn('flex items-center justify-center text-current')}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/command.tsx">
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  className,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
  className?: string
  showCloseButton?: boolean
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent
        className={cn("overflow-hidden p-0", className)}
        showCloseButton={showCloseButton}
      >
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 outline-none sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="src/components/ui/form.tsx">
"use client"

import * as React from "react"
import type * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "item-aligned",
  align = "center",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        align={align}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span
        data-slot="select-item-indicator"
        className="absolute right-2 flex size-3.5 items-center justify-center"
      >
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src/components/ui/sonner.tsx">
"use client"

import {
  CircleCheckIcon,
  InfoIcon,
  Loader2Icon,
  OctagonXIcon,
  TriangleAlertIcon,
} from "lucide-react"
import { useTheme } from "next-themes"
import { Toaster as Sonner, type ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      icons={{
        success: <CircleCheckIcon className="size-4" />,
        info: <InfoIcon className="size-4" />,
        warning: <TriangleAlertIcon className="size-4" />,
        error: <OctagonXIcon className="size-4" />,
        loading: <Loader2Icon className="size-4 animate-spin" />,
      }}
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
          "--border-radius": "var(--radius)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="src/components/ui/table.tsx">
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="src/config/request-config.ts">
// ============================================
// Request Module Configuration
// Status workflow: 4 stages, 14 statuses
// ============================================

// Stage definitions
export const REQUEST_STAGES = {
  LEAD: { label: 'Lead', color: 'blue' },
  QUOTE: { label: 'Báo giá', color: 'purple' },
  FOLLOWUP: { label: 'Follow-up', color: 'orange' },
  OUTCOME: { label: 'Kết quả', color: 'gray' },
} as const;

// Status definitions grouped by stage
export const REQUEST_STATUSES = {
  // LEAD stage
  DANG_LL_CHUA_TL: { label: 'Đang LL - chưa trả lời', stage: 'LEAD', color: 'blue' },
  DANG_LL_DA_TL: { label: 'Đang LL - đã trả lời', stage: 'LEAD', color: 'cyan' },
  // QUOTE stage
  DA_BAO_GIA: { label: 'Đã báo giá', stage: 'QUOTE', color: 'purple' },
  DANG_XAY_TOUR: { label: 'Đang xây Tour', stage: 'QUOTE', color: 'violet' },
  // FOLLOWUP stage
  F1: { label: 'Follow-up 1', stage: 'FOLLOWUP', color: 'orange' },
  F2: { label: 'Follow-up 2', stage: 'FOLLOWUP', color: 'amber' },
  F3: { label: 'Follow-up 3', stage: 'FOLLOWUP', color: 'yellow' },
  F4: { label: 'Lần cuối', stage: 'FOLLOWUP', color: 'red' },
  // OUTCOME stage
  BOOKING: { label: 'Booking', stage: 'OUTCOME', color: 'green' },
  KHACH_HOAN: { label: 'Khách hoãn', stage: 'OUTCOME', color: 'slate' },
  KHACH_SUY_NGHI: { label: 'Đang suy nghĩ', stage: 'OUTCOME', color: 'gray' },
  KHONG_DU_TC: { label: 'Không đủ TC', stage: 'OUTCOME', color: 'rose' },
  DA_KET_THUC: { label: 'Đã kết thúc', stage: 'OUTCOME', color: 'neutral' },
  CANCEL: { label: 'Cancel', stage: 'OUTCOME', color: 'red' },
} as const;

// Type exports
export type RequestStage = keyof typeof REQUEST_STAGES;
export type RequestStatus = keyof typeof REQUEST_STATUSES;

// Keys for iteration
export const REQUEST_STAGE_KEYS = Object.keys(REQUEST_STAGES) as RequestStage[];
export const REQUEST_STATUS_KEYS = Object.keys(REQUEST_STATUSES) as RequestStatus[];

// Follow-up statuses for checking
export const FOLLOWUP_STATUSES: RequestStatus[] = ['F1', 'F2', 'F3', 'F4'];

// Helper: Get statuses by stage
export function getStatusesByStage(stage: RequestStage): RequestStatus[] {
  return REQUEST_STATUS_KEYS.filter(s => REQUEST_STATUSES[s].stage === stage);
}

// Helper: Get stage from status
export function getStageFromStatus(status: RequestStatus): RequestStage {
  return REQUEST_STATUSES[status].stage as RequestStage;
}

// Helper: Check if status is a follow-up status
export function isFollowUpStatus(status: RequestStatus): boolean {
  return FOLLOWUP_STATUSES.includes(status);
}

// Helper: Get status label
export function getStatusLabel(status: RequestStatus): string {
  return REQUEST_STATUSES[status]?.label ?? status;
}

// Helper: Get stage label
export function getStageLabel(stage: RequestStage): string {
  return REQUEST_STAGES[stage]?.label ?? stage;
}

// Helper: Get status color (for badges)
export function getStatusColor(status: RequestStatus): string {
  return REQUEST_STATUSES[status]?.color ?? 'gray';
}

// Helper: Get statuses grouped by stage for dropdowns
export function getStatusesGroupedByStage(): Record<RequestStage, { status: RequestStatus; label: string }[]> {
  const grouped = {} as Record<RequestStage, { status: RequestStatus; label: string }[]>;

  for (const stage of REQUEST_STAGE_KEYS) {
    grouped[stage] = getStatusesByStage(stage).map(status => ({
      status,
      label: REQUEST_STATUSES[status].label,
    }));
  }

  return grouped;
}
</file>

<file path="src/config/supplier-config.ts">
// Supplier configuration - centralized constants for easy modification
// NCC = Nhà Cung Cấp (Supplier)

// Supplier types with display labels and code prefixes
export const SUPPLIER_TYPES = {
  HOTEL: { label: 'Khách sạn', prefix: 'HOT' },
  RESTAURANT: { label: 'Nhà hàng', prefix: 'RES' },
  TRANSPORT: { label: 'Vận chuyển', prefix: 'TRA' },
  GUIDE: { label: 'Hướng dẫn viên', prefix: 'GUI' },
  VISA: { label: 'Visa', prefix: 'VIS' },
  VMB: { label: 'Vé máy bay', prefix: 'VMB' },
  CRUISE: { label: 'Du thuyền', prefix: 'CRU' },
  ACTIVITY: { label: 'Hoạt động/Tour', prefix: 'ACT' },
  OTHER: { label: 'Khác', prefix: 'OTH' },
} as const;

export type SupplierTypeKey = keyof typeof SUPPLIER_TYPES;

// Get array of type keys for iteration
export const SUPPLIER_TYPE_KEYS = Object.keys(SUPPLIER_TYPES) as SupplierTypeKey[];

// Locations with code prefixes (2 characters)
export const SUPPLIER_LOCATIONS = {
  'HA_NOI': { label: 'Hà Nội', prefix: 'HN' },
  'HA_LONG': { label: 'Hạ Long', prefix: 'HL' },
  'NINH_BINH': { label: 'Ninh Bình', prefix: 'NB' },
  'HUE': { label: 'Huế', prefix: 'HU' },
  'DA_NANG': { label: 'Đà Nẵng', prefix: 'DN' },
  'HOI_AN': { label: 'Hội An', prefix: 'HA' },
  'NHA_TRANG': { label: 'Nha Trang', prefix: 'NT' },
  'PHAN_THIET': { label: 'Phan Thiết', prefix: 'PT' },
  'TUY_HOA': { label: 'Tuy Hòa', prefix: 'TH' },
  'PHAN_RANG': { label: 'Phan Rang', prefix: 'PR' },
  'HO_CHI_MINH': { label: 'Hồ Chí Minh', prefix: 'HCM' },
  'CU_CHI': { label: 'Củ Chi', prefix: 'CC' },
  'MIEN_TAY': { label: 'Miền Tây', prefix: 'MT' },
  'PHU_QUOC': { label: 'Phú Quốc', prefix: 'PQ' },
  'CAN_THO': { label: 'Cần Thơ', prefix: 'CT' },
  'THAI_LAN': { label: 'Thái Lan', prefix: 'TL' },
  'CAMBODIA': { label: 'Cambodia', prefix: 'CB' },
  'LAO': { label: 'Lào', prefix: 'LA' },
} as const;

export type SupplierLocationKey = keyof typeof SUPPLIER_LOCATIONS;

// Get array of location keys for iteration
export const SUPPLIER_LOCATION_KEYS = Object.keys(SUPPLIER_LOCATIONS) as SupplierLocationKey[];

// Special value for custom location input
export const CUSTOM_LOCATION = 'OTHER';

// Payment model options
export const PAYMENT_MODELS = {
  PREPAID: { label: 'Trả trước (Deposit pool)', description: 'Nạp tiền trước, trừ dần theo đơn' },
  PAY_PER_USE: { label: 'Thanh toán theo đơn', description: 'Thanh toán riêng từng đơn' },
  CREDIT: { label: 'Công nợ', description: 'Ghi nợ, thanh toán theo kỳ' },
} as const;

export type PaymentModelKey = keyof typeof PAYMENT_MODELS;

// Helper: Generate supplier code
// Format: [3 chữ Loại]-[2 chữ ĐịaPhương]-[3 chữ Tên]-[4 số thứ tự]
// Example: HOT-DN-ANK-0002
export function generateSupplierCode(
  type: SupplierTypeKey,
  name: string,
  location?: SupplierLocationKey | null,
  sequenceNumber: number = 1
): string {
  // Get type prefix (3 chars)
  const typePrefix = SUPPLIER_TYPES[type]?.prefix || 'OTH';

  // Get location prefix (2 chars) or XX if no location
  const locationPrefix = location && SUPPLIER_LOCATIONS[location]
    ? SUPPLIER_LOCATIONS[location].prefix
    : 'XX';

  // Get name prefix (3 chars from first word, uppercase, remove diacritics)
  const namePrefix = getNamePrefix(name);

  // Format sequence number (4 digits)
  const sequence = sequenceNumber.toString().padStart(4, '0');

  return `${typePrefix}-${locationPrefix}-${namePrefix}-${sequence}`;
}

// Helper: Extract 3-char prefix from supplier name
function getNamePrefix(name: string): string {
  if (!name) return 'XXX';

  // Remove Vietnamese diacritics
  const normalized = removeDiacritics(name.trim().toUpperCase());

  // Get first word and take first 3 chars
  const firstWord = normalized.split(/\s+/)[0] || '';
  return firstWord.substring(0, 3).padEnd(3, 'X');
}

// Helper: Remove Vietnamese diacritics
function removeDiacritics(str: string): string {
  const diacriticsMap: Record<string, string> = {
    'À': 'A', 'Á': 'A', 'Ả': 'A', 'Ã': 'A', 'Ạ': 'A',
    'Ă': 'A', 'Ằ': 'A', 'Ắ': 'A', 'Ẳ': 'A', 'Ẵ': 'A', 'Ặ': 'A',
    'Â': 'A', 'Ầ': 'A', 'Ấ': 'A', 'Ẩ': 'A', 'Ẫ': 'A', 'Ậ': 'A',
    'È': 'E', 'É': 'E', 'Ẻ': 'E', 'Ẽ': 'E', 'Ẹ': 'E',
    'Ê': 'E', 'Ề': 'E', 'Ế': 'E', 'Ể': 'E', 'Ễ': 'E', 'Ệ': 'E',
    'Ì': 'I', 'Í': 'I', 'Ỉ': 'I', 'Ĩ': 'I', 'Ị': 'I',
    'Ò': 'O', 'Ó': 'O', 'Ỏ': 'O', 'Õ': 'O', 'Ọ': 'O',
    'Ô': 'O', 'Ồ': 'O', 'Ố': 'O', 'Ổ': 'O', 'Ỗ': 'O', 'Ộ': 'O',
    'Ơ': 'O', 'Ờ': 'O', 'Ớ': 'O', 'Ở': 'O', 'Ỡ': 'O', 'Ợ': 'O',
    'Ù': 'U', 'Ú': 'U', 'Ủ': 'U', 'Ũ': 'U', 'Ụ': 'U',
    'Ư': 'U', 'Ừ': 'U', 'Ứ': 'U', 'Ử': 'U', 'Ữ': 'U', 'Ự': 'U',
    'Ỳ': 'Y', 'Ý': 'Y', 'Ỷ': 'Y', 'Ỹ': 'Y', 'Ỵ': 'Y',
    'Đ': 'D',
  };

  return str.split('').map(char => diacriticsMap[char] || char).join('');
}

// Export for API use
export { removeDiacritics, getNamePrefix };
</file>

<file path="src/lib/__mocks__/db.ts">
import { PrismaClient } from '@prisma/client';
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended';

// Create a mock Prisma client
export const prismaMock = mockDeep<PrismaClient>();

// Reset mocks before each test
beforeEach(() => {
  mockReset(prismaMock);
});

// Export the mock as the default prisma instance
export const prisma = prismaMock;
export default prismaMock;

// Type for the mocked Prisma client
export type MockPrismaClient = DeepMockProxy<PrismaClient>;
</file>

<file path="src/lib/db.ts">
import { PrismaClient } from '@prisma/client';
import { PrismaPg } from '@prisma/adapter-pg';

// Prisma 7.x requires driver adapter for database connections
const adapter = new PrismaPg({ connectionString: process.env.DATABASE_URL });

// Prisma Client singleton for Next.js hot-reloading
const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    adapter,
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
</file>

<file path="src/lib/operator-validation.ts">
// Operator validation schemas using Zod
import { z } from 'zod';

/**
 * Schema for creating/updating an operator
 */
export const operatorFormSchema = z.object({
  requestId: z.string().min(1, 'Vui lòng chọn Booking'),
  supplierId: z.string().optional().nullable(),
  supplier: z.string().optional().nullable(),
  serviceDate: z.string().min(1, 'Vui lòng chọn ngày dịch vụ'),
  serviceType: z.string().min(1, 'Vui lòng chọn loại dịch vụ'),
  serviceName: z.string().min(1, 'Vui lòng nhập tên dịch vụ'),
  costBeforeTax: z.number().min(0, 'Chi phí phải >= 0'),
  vat: z.number().min(0).optional().nullable(),
  totalCost: z.number().min(0, 'Tổng chi phí phải >= 0'),
  paymentDeadline: z.string().optional().nullable(),
  bankAccount: z.string().optional().nullable(),
  notes: z.string().optional().nullable(),
}).refine(
  (data) => data.supplierId || data.supplier,
  { message: 'Vui lòng chọn NCC hoặc nhập tên NCC', path: ['supplier'] }
);

export type OperatorFormValues = z.infer<typeof operatorFormSchema>;

/**
 * Schema for batch payment approval (Phase 2)
 */
export const approvePaymentSchema = z.object({
  operatorIds: z.array(z.string()).min(1, 'Chọn ít nhất 1 dịch vụ'),
  paymentDate: z.string().min(1, 'Vui lòng chọn ngày thanh toán'),
});

/**
 * Schema for lock period (Phase 3)
 */
export const lockPeriodSchema = z.object({
  month: z.string().regex(/^\d{4}-\d{2}$/, 'Định dạng: YYYY-MM'),
});
</file>

<file path="src/lib/request-utils.ts">
// ============================================
// Request Module Utilities
// ID generation, date calculations, follow-up logic
// ============================================

import { prisma } from '@/lib/db';

/**
 * Generate RQID: RQ-YYMMDD-0001
 * Sequential counter resets daily
 */
export async function generateRQID(): Promise<string> {
  const now = new Date();
  const year = String(now.getFullYear()).slice(-2);
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const dateStr = `${year}${month}${day}`;
  const prefix = `RQ-${dateStr}-`;

  // Get today's count
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
  const todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);

  const count = await prisma.request.count({
    where: {
      createdAt: { gte: todayStart, lte: todayEnd },
    },
  });

  const seq = String(count + 1).padStart(4, '0');
  return `${prefix}${seq}`;
}

/**
 * Generate Booking Code: YYYYMMDD + SellerCode + Seq
 * Example: 20260201L0005
 *
 * Fallback: If no sellerCode, use first letter of seller name
 */
export async function generateBookingCode(
  startDate: Date,
  sellerId: string
): Promise<string> {
  // Get seller code or fallback to name initial
  const config = await prisma.configUser.findUnique({
    where: { userId: sellerId },
    include: { user: { select: { name: true } } },
  });

  let code: string;

  if (config?.sellerCode) {
    code = config.sellerCode;
  } else if (config?.user?.name) {
    // Fallback: first letter of name, uppercase
    code = config.user.name.charAt(0).toUpperCase();
  } else {
    // Ultimate fallback
    code = 'X';
  }

  const year = startDate.getFullYear();
  const month = String(startDate.getMonth() + 1).padStart(2, '0');
  const day = String(startDate.getDate()).padStart(2, '0');
  const dateStr = `${year}${month}${day}`;
  const prefix = `${dateStr}${code}`;

  // Get max sequence for this prefix
  const existing = await prisma.request.findMany({
    where: { bookingCode: { startsWith: prefix } },
    orderBy: { bookingCode: 'desc' },
    take: 1,
    select: { bookingCode: true },
  });

  let seq = 1;
  if (existing.length > 0 && existing[0].bookingCode) {
    // Extract sequence from existing code (last 4 digits)
    const lastSeq = parseInt(existing[0].bookingCode.slice(-4), 10);
    seq = lastSeq + 1;
  }

  return `${prefix}${String(seq).padStart(4, '0')}`;
}

/**
 * Calculate end date from start + tourDays
 * End date is inclusive (startDate + tourDays - 1)
 */
export function calculateEndDate(startDate: Date, tourDays: number): Date {
  const end = new Date(startDate);
  end.setDate(end.getDate() + tourDays - 1);
  return end;
}

/**
 * Calculate next follow-up date based on ConfigFollowUp
 */
export async function calculateNextFollowUp(
  stage: string,
  lastContactDate: Date
): Promise<Date | null> {
  const config = await prisma.configFollowUp.findUnique({
    where: { stage },
  });

  if (!config || !config.isActive) return null;

  const next = new Date(lastContactDate);
  next.setDate(next.getDate() + config.daysToWait);
  return next;
}

/**
 * Get seller code from ConfigUser
 */
export async function getSellerCode(userId: string): Promise<string | null> {
  const config = await prisma.configUser.findUnique({
    where: { userId },
    select: { sellerCode: true },
  });
  return config?.sellerCode ?? null;
}

/**
 * Check if user can view all requests
 */
export async function canUserViewAll(userId: string): Promise<boolean> {
  const config = await prisma.configUser.findUnique({
    where: { userId },
    select: { canViewAll: true },
  });
  return config?.canViewAll ?? false;
}

/**
 * Get follow-up date boundaries for queries
 */
export function getFollowUpDateBoundaries(): {
  todayStart: Date;
  todayEnd: Date;
  threeDaysLater: Date;
} {
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
  const todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59, 999);
  const threeDaysLater = new Date(todayStart);
  threeDaysLater.setDate(threeDaysLater.getDate() + 3);

  return { todayStart, todayEnd, threeDaysLater };
}
</file>

<file path="src/lib/supplier-balance.ts">
import { prisma } from './db';
import type { SupplierBalance } from '@/types';

/**
 * Calculate balance for a single supplier
 * Balance = deposits + refunds + adjustments - fees - operator costs
 */
export async function calculateSupplierBalance(supplierId: string): Promise<SupplierBalance> {
  // Get transaction totals by type
  const transactionSums = await prisma.supplierTransaction.groupBy({
    by: ['type'],
    where: { supplierId },
    _sum: { amount: true },
  });

  // Get total operator costs linked to this supplier
  const costSum = await prisma.operator.aggregate({
    where: { supplierId },
    _sum: { totalCost: true },
  });

  // Extract amounts by type
  const deposits = Number(transactionSums.find(t => t.type === 'DEPOSIT')?._sum.amount ?? 0);
  const refunds = Number(transactionSums.find(t => t.type === 'REFUND')?._sum.amount ?? 0);
  const adjustments = Number(transactionSums.find(t => t.type === 'ADJUSTMENT')?._sum.amount ?? 0);
  const fees = Number(transactionSums.find(t => t.type === 'FEE')?._sum.amount ?? 0);
  const costs = Number(costSum._sum.totalCost ?? 0);

  // Calculate balance: deposits + refunds + adjustments - fees - costs
  const balance = deposits + refunds + adjustments - fees - costs;

  return {
    deposits,
    refunds,
    adjustments,
    fees,
    costs,
    balance,
  };
}

/**
 * Get balance summary for all suppliers with optional type filter
 */
export async function getSupplierBalanceSummary(typeFilter?: string) {
  // Get all active suppliers
  const whereClause: Record<string, unknown> = { isActive: true };
  if (typeFilter) {
    whereClause.type = typeFilter;
  }

  const suppliers = await prisma.supplier.findMany({
    where: whereClause,
    select: {
      id: true,
      code: true,
      name: true,
      type: true,
      paymentModel: true,
      isActive: true,
    },
    orderBy: { code: 'asc' },
  });

  // Calculate balance for each supplier
  const results = await Promise.all(
    suppliers.map(async (supplier) => {
      const balance = await calculateSupplierBalance(supplier.id);
      return {
        ...supplier,
        deposits: balance.deposits,
        costs: balance.costs,
        refunds: balance.refunds,
        balance: balance.balance,
      };
    })
  );

  // Calculate summary totals
  const summary = {
    supplierCount: results.length,
    totalDeposits: results.reduce((sum, s) => sum + s.deposits, 0),
    totalCosts: results.reduce((sum, s) => sum + s.costs, 0),
    totalRefunds: results.reduce((sum, s) => sum + s.refunds, 0),
    totalBalance: results.reduce((sum, s) => sum + s.balance, 0),
    positiveBalance: results.filter(s => s.balance > 0).length,
    negativeBalance: results.filter(s => s.balance < 0).length,
  };

  return { data: results, summary };
}
</file>

<file path="src/lib/sync/__tests__/write-back-queue.test.ts">
/**
 * Tests for SyncQueue Management Utilities
 */

import { prisma } from "@/lib/db";
import { mockReset, DeepMockProxy } from "jest-mock-extended";
import { Prisma } from "@prisma/client";
import {
  enqueue,
  dequeue,
  markComplete,
  markFailed,
  resetStuck,
  cleanupCompleted,
  getQueueStats,
  getFailedItems,
  retryFailed,
  deleteQueueItem,
  type EnqueueParams,
} from "../write-back-queue";

// Mock Prisma client - use require to lazy-load mockDeep
jest.mock("@/lib/db", () => {
  const { mockDeep } = require("jest-mock-extended");
  return {
    prisma: mockDeep(),
  };
});

const mockPrisma = prisma as unknown as DeepMockProxy<typeof prisma>;

describe("SyncQueue Management Utilities", () => {
  beforeEach(() => {
    mockReset(mockPrisma);
  });

  describe("enqueue", () => {
    it("creates a queue entry with correct data", async () => {
      const params: EnqueueParams = {
        action: "UPDATE",
        model: "Request",
        recordId: "test-id-123",
        sheetRowIndex: 5,
        payload: { customerName: "Test Customer" },
      };

      mockPrisma.syncQueue.create.mockResolvedValue({
        id: "queue-id-1",
        action: params.action,
        model: params.model,
        recordId: params.recordId,
        sheetRowIndex: params.sheetRowIndex!,
        payload: params.payload as Prisma.JsonObject,
        status: "PENDING",
        retries: 0,
        maxRetries: 3,
        lastError: null,
        createdAt: new Date(),
        processedAt: null,
      });

      await enqueue(params);

      expect(mockPrisma.syncQueue.create).toHaveBeenCalledWith({
        data: {
          action: "UPDATE",
          model: "Request",
          recordId: "test-id-123",
          sheetRowIndex: 5,
          payload: { customerName: "Test Customer" },
          status: "PENDING",
          retries: 0,
          maxRetries: 3,
        },
      });
    });

    it("handles null sheetRowIndex for CREATE action", async () => {
      const params: EnqueueParams = {
        action: "CREATE",
        model: "Operator",
        recordId: "op-123",
        payload: { serviceName: "Hotel ABC" },
      };

      mockPrisma.syncQueue.create.mockResolvedValue({
        id: "queue-id-2",
        action: params.action,
        model: params.model,
        recordId: params.recordId,
        sheetRowIndex: null,
        payload: params.payload as Prisma.JsonObject,
        status: "PENDING",
        retries: 0,
        maxRetries: 3,
        lastError: null,
        createdAt: new Date(),
        processedAt: null,
      });

      await enqueue(params);

      expect(mockPrisma.syncQueue.create).toHaveBeenCalledWith({
        data: expect.objectContaining({
          sheetRowIndex: null,
        }),
      });
    });

    it("logs error but does not throw on failure", async () => {
      const consoleSpy = jest.spyOn(console, "error").mockImplementation();

      mockPrisma.syncQueue.create.mockRejectedValue(new Error("DB error"));

      await enqueue({
        action: "UPDATE",
        model: "Request",
        recordId: "test",
        payload: {},
      });

      expect(consoleSpy).toHaveBeenCalledWith(
        "[SyncQueue] Enqueue failed:",
        expect.any(Error)
      );
      consoleSpy.mockRestore();
    });
  });

  describe("dequeue", () => {
    it("returns pending items and marks them as processing", async () => {
      const mockItems = [
        {
          id: "q1",
          action: "UPDATE",
          model: "Request",
          recordId: "r1",
          sheetRowIndex: 5,
          payload: { field: "value" },
        },
        {
          id: "q2",
          action: "CREATE",
          model: "Operator",
          recordId: "o1",
          sheetRowIndex: null,
          payload: {},
        },
      ];

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (mockPrisma.$transaction as jest.Mock).mockImplementation(async (fn: any) => {
        const txMock = {
          syncQueue: {
            findMany: jest.fn().mockResolvedValue(mockItems),
            updateMany: jest.fn().mockResolvedValue({ count: 2 }),
          },
        };
        return fn(txMock);
      });

      const result = await dequeue(25);

      expect(result).toHaveLength(2);
      expect(result[0].id).toBe("q1");
      expect(result[1].id).toBe("q2");
    });

    it("returns empty array when no pending items", async () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (mockPrisma.$transaction as jest.Mock).mockImplementation(async (fn: any) => {
        const txMock = {
          syncQueue: {
            findMany: jest.fn().mockResolvedValue([]),
          },
        };
        return fn(txMock);
      });

      const result = await dequeue(25);

      expect(result).toHaveLength(0);
    });

    it("respects batch size parameter", async () => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (mockPrisma.$transaction as jest.Mock).mockImplementation(async (fn: any) => {
        const txMock = {
          syncQueue: {
            findMany: jest.fn().mockResolvedValue([]),
            updateMany: jest.fn(),
          },
        };
        return fn(txMock);
      });

      await dequeue(10);

      // Verify findMany was called with correct take parameter
      expect(mockPrisma.$transaction).toHaveBeenCalled();
    });
  });

  describe("markComplete", () => {
    it("updates status to COMPLETED with timestamp", async () => {
      const itemId = "queue-123";

      mockPrisma.syncQueue.update.mockResolvedValue({
        id: itemId,
        action: "UPDATE",
        model: "Request",
        recordId: "r1",
        sheetRowIndex: 5,
        payload: {},
        status: "COMPLETED",
        retries: 0,
        maxRetries: 3,
        lastError: null,
        createdAt: new Date(),
        processedAt: new Date(),
      });

      await markComplete(itemId);

      expect(mockPrisma.syncQueue.update).toHaveBeenCalledWith({
        where: { id: itemId },
        data: {
          status: "COMPLETED",
          processedAt: expect.any(Date),
        },
      });
    });
  });

  describe("markFailed", () => {
    it("sets status to PENDING when retries remaining", async () => {
      const itemId = "queue-123";

      mockPrisma.syncQueue.findUnique.mockResolvedValue({
        id: itemId,
        action: "UPDATE",
        model: "Request",
        recordId: "r1",
        sheetRowIndex: 5,
        payload: {},
        status: "PROCESSING",
        retries: 1,
        maxRetries: 3,
        lastError: null,
        createdAt: new Date(),
        processedAt: null,
      });

      mockPrisma.syncQueue.update.mockResolvedValue({
        id: itemId,
        action: "UPDATE",
        model: "Request",
        recordId: "r1",
        sheetRowIndex: 5,
        payload: {},
        status: "PENDING",
        retries: 2,
        maxRetries: 3,
        lastError: "API error",
        createdAt: new Date(),
        processedAt: null,
      });

      await markFailed(itemId, "API error");

      expect(mockPrisma.syncQueue.update).toHaveBeenCalledWith({
        where: { id: itemId },
        data: {
          status: "PENDING", // Back to pending for retry
          retries: { increment: 1 },
          lastError: "API error",
        },
      });
    });

    it("sets status to FAILED when max retries reached", async () => {
      const itemId = "queue-123";

      mockPrisma.syncQueue.findUnique.mockResolvedValue({
        id: itemId,
        action: "UPDATE",
        model: "Request",
        recordId: "r1",
        sheetRowIndex: 5,
        payload: {},
        status: "PROCESSING",
        retries: 2, // Already at 2, max is 3
        maxRetries: 3,
        lastError: null,
        createdAt: new Date(),
        processedAt: null,
      });

      mockPrisma.syncQueue.update.mockResolvedValue({
        id: itemId,
        action: "UPDATE",
        model: "Request",
        recordId: "r1",
        sheetRowIndex: 5,
        payload: {},
        status: "FAILED",
        retries: 3,
        maxRetries: 3,
        lastError: "Final error",
        createdAt: new Date(),
        processedAt: null,
      });

      await markFailed(itemId, "Final error");

      expect(mockPrisma.syncQueue.update).toHaveBeenCalledWith({
        where: { id: itemId },
        data: {
          status: "FAILED",
          retries: { increment: 1 },
          lastError: "Final error",
        },
      });
    });

    it("does nothing when item not found", async () => {
      mockPrisma.syncQueue.findUnique.mockResolvedValue(null);

      await markFailed("non-existent", "error");

      expect(mockPrisma.syncQueue.update).not.toHaveBeenCalled();
    });
  });

  describe("resetStuck", () => {
    it("resets PROCESSING items older than threshold", async () => {
      mockPrisma.syncQueue.updateMany.mockResolvedValue({ count: 3 });

      const result = await resetStuck(10);

      expect(result).toBe(3);
      expect(mockPrisma.syncQueue.updateMany).toHaveBeenCalledWith({
        where: {
          status: "PROCESSING",
          createdAt: { lt: expect.any(Date) },
        },
        data: { status: "PENDING" },
      });
    });

    it("uses default 10 minutes threshold", async () => {
      mockPrisma.syncQueue.updateMany.mockResolvedValue({ count: 0 });

      await resetStuck();

      const call = mockPrisma.syncQueue.updateMany.mock.calls[0][0];
      const createdAtFilter = call?.where?.createdAt as { lt: Date };
      const threshold = createdAtFilter?.lt;
      const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);

      // Threshold should be approximately 10 minutes ago
      expect(Math.abs(threshold.getTime() - tenMinutesAgo.getTime())).toBeLessThan(1000);
    });
  });

  describe("cleanupCompleted", () => {
    it("deletes COMPLETED items older than threshold", async () => {
      mockPrisma.syncQueue.deleteMany.mockResolvedValue({ count: 50 });

      const result = await cleanupCompleted(7);

      expect(result).toBe(50);
      expect(mockPrisma.syncQueue.deleteMany).toHaveBeenCalledWith({
        where: {
          status: "COMPLETED",
          processedAt: { lt: expect.any(Date) },
        },
      });
    });

    it("uses default 7 days threshold", async () => {
      mockPrisma.syncQueue.deleteMany.mockResolvedValue({ count: 0 });

      await cleanupCompleted();

      const call = mockPrisma.syncQueue.deleteMany.mock.calls[0][0];
      const processedAtFilter = call?.where?.processedAt as { lt: Date };
      const threshold = processedAtFilter?.lt;
      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

      // Threshold should be approximately 7 days ago
      expect(Math.abs(threshold.getTime() - sevenDaysAgo.getTime())).toBeLessThan(1000);
    });
  });

  describe("getQueueStats", () => {
    it("returns counts by status", async () => {
      mockPrisma.syncQueue.groupBy.mockResolvedValue([
        { status: "PENDING", _count: 10 },
        { status: "PROCESSING", _count: 2 },
        { status: "COMPLETED", _count: 100 },
        { status: "FAILED", _count: 5 },
      ] as never);

      const stats = await getQueueStats();

      expect(stats).toEqual({
        pending: 10,
        processing: 2,
        completed: 100,
        failed: 5,
      });
    });

    it("returns 0 for missing statuses", async () => {
      mockPrisma.syncQueue.groupBy.mockResolvedValue([
        { status: "PENDING", _count: 5 },
      ] as never);

      const stats = await getQueueStats();

      expect(stats).toEqual({
        pending: 5,
        processing: 0,
        completed: 0,
        failed: 0,
      });
    });

    it("handles empty queue", async () => {
      mockPrisma.syncQueue.groupBy.mockResolvedValue([]);

      const stats = await getQueueStats();

      expect(stats).toEqual({
        pending: 0,
        processing: 0,
        completed: 0,
        failed: 0,
      });
    });
  });

  describe("getFailedItems", () => {
    it("returns failed items with error details", async () => {
      const mockFailed = [
        {
          id: "f1",
          model: "Request",
          action: "UPDATE",
          recordId: "r1",
          lastError: "API timeout",
          retries: 3,
          createdAt: new Date(),
        },
      ];

      mockPrisma.syncQueue.findMany.mockResolvedValue(mockFailed as never);

      const result = await getFailedItems(10);

      expect(result).toHaveLength(1);
      expect(result[0].lastError).toBe("API timeout");
      expect(mockPrisma.syncQueue.findMany).toHaveBeenCalledWith({
        where: { status: "FAILED" },
        orderBy: { createdAt: "desc" },
        take: 10,
        select: expect.any(Object),
      });
    });
  });

  describe("retryFailed", () => {
    it("resets status and retries for failed item", async () => {
      mockPrisma.syncQueue.update.mockResolvedValue({} as never);

      await retryFailed("failed-id");

      expect(mockPrisma.syncQueue.update).toHaveBeenCalledWith({
        where: { id: "failed-id" },
        data: {
          status: "PENDING",
          retries: 0,
          lastError: null,
        },
      });
    });
  });

  describe("deleteQueueItem", () => {
    it("deletes queue item by id", async () => {
      mockPrisma.syncQueue.delete.mockResolvedValue({} as never);

      await deleteQueueItem("item-to-delete");

      expect(mockPrisma.syncQueue.delete).toHaveBeenCalledWith({
        where: { id: "item-to-delete" },
      });
    });
  });
});
</file>

<file path="src/lib/sync/write-back-queue.ts">
/**
 * SyncQueue Management Utilities
 *
 * Handles enqueue, dequeue, status updates for write-back queue.
 * Queue enables bidirectional sync: DB changes -> Google Sheets.
 */

import { prisma } from "@/lib/db";
import { Prisma } from "@prisma/client";

export type SyncAction = "CREATE" | "UPDATE" | "DELETE";
export type QueueStatus = "PENDING" | "PROCESSING" | "COMPLETED" | "FAILED";
export type SyncModel = "Request" | "Operator" | "Revenue";

export interface EnqueueParams {
  action: SyncAction;
  model: SyncModel;
  recordId: string;
  sheetRowIndex?: number | null;
  payload: Record<string, unknown>;
}

export interface QueueItem {
  id: string;
  action: string;
  model: string;
  recordId: string;
  sheetRowIndex: number | null;
  payload: Prisma.JsonValue;
}

export interface QueueStats {
  pending: number;
  processing: number;
  completed: number;
  failed: number;
}

/**
 * Add change to sync queue (fire-and-forget)
 * Catches errors internally - queue is best-effort
 */
export async function enqueue(params: EnqueueParams): Promise<void> {
  try {
    await prisma.syncQueue.create({
      data: {
        action: params.action,
        model: params.model,
        recordId: params.recordId,
        sheetRowIndex: params.sheetRowIndex ?? null,
        payload: params.payload as Prisma.JsonObject,
        status: "PENDING",
        retries: 0,
        maxRetries: 3,
      },
    });
  } catch (error) {
    // Log but don't throw - queue is best-effort
    console.error("[SyncQueue] Enqueue failed:", error);
  }
}

/**
 * Get pending items for processing (batch)
 * Returns oldest PENDING items, marks as PROCESSING atomically
 */
export async function dequeue(batchSize: number = 25): Promise<QueueItem[]> {
  // Atomic: select + update in transaction
  return await prisma.$transaction(async (tx) => {
    const items = await tx.syncQueue.findMany({
      where: { status: "PENDING" },
      orderBy: { createdAt: "asc" },
      take: batchSize,
      select: {
        id: true,
        action: true,
        model: true,
        recordId: true,
        sheetRowIndex: true,
        payload: true,
      },
    });

    if (items.length === 0) return [];

    // Mark as processing
    await tx.syncQueue.updateMany({
      where: { id: { in: items.map((i) => i.id) } },
      data: { status: "PROCESSING" },
    });

    return items;
  });
}

/**
 * Mark item as completed
 */
export async function markComplete(id: string): Promise<void> {
  await prisma.syncQueue.update({
    where: { id },
    data: {
      status: "COMPLETED",
      processedAt: new Date(),
    },
  });
}

/**
 * Mark item as failed, increment retry counter
 * Returns to PENDING if retries remaining, else FAILED
 */
export async function markFailed(id: string, error: string): Promise<void> {
  const item = await prisma.syncQueue.findUnique({
    where: { id },
    select: { retries: true, maxRetries: true },
  });

  if (!item) return;

  const newStatus = item.retries + 1 >= item.maxRetries ? "FAILED" : "PENDING";

  await prisma.syncQueue.update({
    where: { id },
    data: {
      status: newStatus,
      retries: { increment: 1 },
      lastError: error,
    },
  });
}

/**
 * Reset stuck PROCESSING items back to PENDING
 * For items processing longer than threshold (crash recovery)
 */
export async function resetStuck(olderThanMinutes: number = 10): Promise<number> {
  const threshold = new Date(Date.now() - olderThanMinutes * 60 * 1000);

  const result = await prisma.syncQueue.updateMany({
    where: {
      status: "PROCESSING",
      createdAt: { lt: threshold },
    },
    data: { status: "PENDING" },
  });

  return result.count;
}

/**
 * Cleanup old completed items (retention policy)
 * Default: 7 days
 */
export async function cleanupCompleted(olderThanDays: number = 7): Promise<number> {
  const threshold = new Date(Date.now() - olderThanDays * 24 * 60 * 60 * 1000);

  const result = await prisma.syncQueue.deleteMany({
    where: {
      status: "COMPLETED",
      processedAt: { lt: threshold },
    },
  });

  return result.count;
}

/**
 * Get queue statistics by status
 */
export async function getQueueStats(): Promise<QueueStats> {
  const stats = await prisma.syncQueue.groupBy({
    by: ["status"],
    _count: true,
  });

  return {
    pending: stats.find((s) => s.status === "PENDING")?._count ?? 0,
    processing: stats.find((s) => s.status === "PROCESSING")?._count ?? 0,
    completed: stats.find((s) => s.status === "COMPLETED")?._count ?? 0,
    failed: stats.find((s) => s.status === "FAILED")?._count ?? 0,
  };
}

/**
 * Get failed items with error details
 */
export async function getFailedItems(
  limit: number = 10
): Promise<Array<{
  id: string;
  model: string;
  action: string;
  recordId: string;
  lastError: string | null;
  retries: number;
  createdAt: Date;
}>> {
  return prisma.syncQueue.findMany({
    where: { status: "FAILED" },
    orderBy: { createdAt: "desc" },
    take: limit,
    select: {
      id: true,
      model: true,
      action: true,
      recordId: true,
      lastError: true,
      retries: true,
      createdAt: true,
    },
  });
}

/**
 * Retry a failed item by resetting status
 */
export async function retryFailed(id: string): Promise<void> {
  await prisma.syncQueue.update({
    where: { id },
    data: {
      status: "PENDING",
      retries: 0,
      lastError: null,
    },
  });
}

/**
 * Delete a queue item (for manual cleanup)
 */
export async function deleteQueueItem(id: string): Promise<void> {
  await prisma.syncQueue.delete({
    where: { id },
  });
}
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

// Format number as Vietnamese currency (VND)
export function formatCurrency(value: number): string {
  return new Intl.NumberFormat('vi-VN').format(value);
}

// Format date as Vietnamese locale
export function formatDate(date: string | Date): string {
  return new Date(date).toLocaleDateString('vi-VN');
}
</file>

<file path="src/__tests__/config/operator-config.test.ts">
/**
 * @jest-environment node
 */

// Tests for operator configuration
// Covers: SERVICE_TYPES, PAYMENT_STATUSES, HISTORY_ACTIONS, DEFAULT_VAT_RATE

import {
  SERVICE_TYPES,
  SERVICE_TYPE_KEYS,
  PAYMENT_STATUSES,
  PAYMENT_STATUS_KEYS,
  HISTORY_ACTIONS,
  DEFAULT_VAT_RATE,
} from '@/config/operator-config';

describe('SERVICE_TYPES configuration', () => {
  it('should have 9 service types', () => {
    expect(SERVICE_TYPE_KEYS).toHaveLength(9);
  });

  it('should include all expected types', () => {
    expect(SERVICE_TYPE_KEYS).toContain('HOTEL');
    expect(SERVICE_TYPE_KEYS).toContain('RESTAURANT');
    expect(SERVICE_TYPE_KEYS).toContain('TRANSPORT');
    expect(SERVICE_TYPE_KEYS).toContain('GUIDE');
    expect(SERVICE_TYPE_KEYS).toContain('VISA');
    expect(SERVICE_TYPE_KEYS).toContain('VMB');
    expect(SERVICE_TYPE_KEYS).toContain('CRUISE');
    expect(SERVICE_TYPE_KEYS).toContain('ACTIVITY');
    expect(SERVICE_TYPE_KEYS).toContain('OTHER');
  });

  it('should have labels and icons for all types', () => {
    SERVICE_TYPE_KEYS.forEach((key) => {
      expect(SERVICE_TYPES[key].label).toBeDefined();
      expect(SERVICE_TYPES[key].icon).toBeDefined();
    });
  });

  it('should have correct Vietnamese labels', () => {
    expect(SERVICE_TYPES.HOTEL.label).toBe('Khách sạn');
    expect(SERVICE_TYPES.RESTAURANT.label).toBe('Nhà hàng');
    expect(SERVICE_TYPES.TRANSPORT.label).toBe('Vận chuyển');
    expect(SERVICE_TYPES.GUIDE.label).toBe('Hướng dẫn viên');
    expect(SERVICE_TYPES.VMB.label).toBe('Vé máy bay');
    expect(SERVICE_TYPES.CRUISE.label).toBe('Du thuyền');
    expect(SERVICE_TYPES.ACTIVITY.label).toBe('Hoạt động/Tour');
  });

  it('should have valid Lucide icon names', () => {
    const validIcons = [
      'Building2', 'UtensilsCrossed', 'Car', 'User',
      'FileText', 'Plane', 'Ship', 'Camera', 'MoreHorizontal'
    ];
    SERVICE_TYPE_KEYS.forEach((key) => {
      expect(validIcons).toContain(SERVICE_TYPES[key].icon);
    });
  });
});

describe('PAYMENT_STATUSES configuration', () => {
  it('should have 3 payment statuses', () => {
    expect(PAYMENT_STATUS_KEYS).toHaveLength(3);
  });

  it('should include all expected statuses', () => {
    expect(PAYMENT_STATUS_KEYS).toContain('PENDING');
    expect(PAYMENT_STATUS_KEYS).toContain('PARTIAL');
    expect(PAYMENT_STATUS_KEYS).toContain('PAID');
  });

  it('should have labels and colors for all statuses', () => {
    PAYMENT_STATUS_KEYS.forEach((key) => {
      expect(PAYMENT_STATUSES[key].label).toBeDefined();
      expect(PAYMENT_STATUSES[key].color).toBeDefined();
    });
  });

  it('should have correct Vietnamese labels', () => {
    expect(PAYMENT_STATUSES.PENDING.label).toBe('Chờ thanh toán');
    expect(PAYMENT_STATUSES.PARTIAL.label).toBe('Thanh toán một phần');
    expect(PAYMENT_STATUSES.PAID.label).toBe('Đã thanh toán');
  });

  it('should have appropriate colors', () => {
    expect(PAYMENT_STATUSES.PENDING.color).toBe('yellow');
    expect(PAYMENT_STATUSES.PARTIAL.color).toBe('orange');
    expect(PAYMENT_STATUSES.PAID.color).toBe('green');
  });
});

describe('HISTORY_ACTIONS configuration', () => {
  it('should have 12 history action types (including 3-tier locks)', () => {
    // 6 base actions + 6 tier-specific lock actions
    expect(Object.keys(HISTORY_ACTIONS)).toHaveLength(12);
  });

  it('should include all expected base action types', () => {
    expect(HISTORY_ACTIONS).toHaveProperty('CREATE');
    expect(HISTORY_ACTIONS).toHaveProperty('UPDATE');
    expect(HISTORY_ACTIONS).toHaveProperty('DELETE');
    expect(HISTORY_ACTIONS).toHaveProperty('LOCK');
    expect(HISTORY_ACTIONS).toHaveProperty('UNLOCK');
    expect(HISTORY_ACTIONS).toHaveProperty('APPROVE');
  });

  it('should include 3-tier lock action types', () => {
    expect(HISTORY_ACTIONS).toHaveProperty('LOCK_KT');
    expect(HISTORY_ACTIONS).toHaveProperty('UNLOCK_KT');
    expect(HISTORY_ACTIONS).toHaveProperty('LOCK_ADMIN');
    expect(HISTORY_ACTIONS).toHaveProperty('UNLOCK_ADMIN');
    expect(HISTORY_ACTIONS).toHaveProperty('LOCK_FINAL');
    expect(HISTORY_ACTIONS).toHaveProperty('UNLOCK_FINAL');
  });

  it('should have labels and colors for all actions', () => {
    Object.values(HISTORY_ACTIONS).forEach((action) => {
      expect(action.label).toBeDefined();
      expect(action.color).toBeDefined();
    });
  });

  it('should have correct Vietnamese labels for base actions', () => {
    expect(HISTORY_ACTIONS.CREATE.label).toBe('Tạo mới');
    expect(HISTORY_ACTIONS.UPDATE.label).toBe('Cập nhật');
    expect(HISTORY_ACTIONS.DELETE.label).toBe('Xóa');
    expect(HISTORY_ACTIONS.LOCK.label).toBe('Khóa');
    expect(HISTORY_ACTIONS.UNLOCK.label).toBe('Mở khóa');
    expect(HISTORY_ACTIONS.APPROVE.label).toBe('Duyệt TT');
  });

  it('should have correct Vietnamese labels for 3-tier lock actions', () => {
    expect(HISTORY_ACTIONS.LOCK_KT.label).toBe('Khóa KT');
    expect(HISTORY_ACTIONS.UNLOCK_KT.label).toBe('Mở khóa KT');
    expect(HISTORY_ACTIONS.LOCK_ADMIN.label).toBe('Khóa Admin');
    expect(HISTORY_ACTIONS.UNLOCK_ADMIN.label).toBe('Mở khóa Admin');
    expect(HISTORY_ACTIONS.LOCK_FINAL.label).toBe('Khóa Cuối');
    expect(HISTORY_ACTIONS.UNLOCK_FINAL.label).toBe('Mở khóa Cuối');
  });

  it('should have appropriate colors for base actions', () => {
    expect(HISTORY_ACTIONS.CREATE.color).toBe('green');
    expect(HISTORY_ACTIONS.UPDATE.color).toBe('blue');
    expect(HISTORY_ACTIONS.DELETE.color).toBe('red');
    expect(HISTORY_ACTIONS.LOCK.color).toBe('amber');
    expect(HISTORY_ACTIONS.UNLOCK.color).toBe('purple');
    expect(HISTORY_ACTIONS.APPROVE.color).toBe('emerald');
  });

  it('should have appropriate colors for 3-tier lock actions', () => {
    expect(HISTORY_ACTIONS.LOCK_KT.color).toBe('amber');
    expect(HISTORY_ACTIONS.UNLOCK_KT.color).toBe('purple');
    expect(HISTORY_ACTIONS.LOCK_ADMIN.color).toBe('orange');
    expect(HISTORY_ACTIONS.UNLOCK_ADMIN.color).toBe('purple');
    expect(HISTORY_ACTIONS.LOCK_FINAL.color).toBe('red');
    expect(HISTORY_ACTIONS.UNLOCK_FINAL.color).toBe('purple');
  });
});

describe('DEFAULT_VAT_RATE constant', () => {
  it('should be 10 (percent)', () => {
    expect(DEFAULT_VAT_RATE).toBe(10);
  });

  it('should be a positive number', () => {
    expect(DEFAULT_VAT_RATE).toBeGreaterThan(0);
  });

  it('should be less than 100 (reasonable VAT rate)', () => {
    expect(DEFAULT_VAT_RATE).toBeLessThan(100);
  });
});

describe('Service types alignment with Supplier types', () => {
  // This test ensures operator service types match supplier types
  const expectedAlignedTypes = [
    'HOTEL',
    'RESTAURANT',
    'TRANSPORT',
    'GUIDE',
    'VISA',
    'VMB',
    'CRUISE',
    'ACTIVITY',
    'OTHER',
  ];

  it('should have matching service types with supplier types', () => {
    expectedAlignedTypes.forEach((type) => {
      expect(SERVICE_TYPE_KEYS).toContain(type);
    });
  });
});
</file>

<file path="src/__tests__/lib/lock-utils.test.ts">
import {
  canLock,
  canUnlock,
  canLockTier,
  canUnlockTier,
  isEditable,
  getLockFields,
  getCurrentLockTier,
  getActiveLockTiers,
  hasAnyLock,
  LOCK_TIERS,
  LOCK_TIER_ORDER,
  LOCK_PERMISSIONS,
} from '@/lib/lock-utils';
import type { Role } from '@prisma/client';

describe('Lock System Utilities', () => {
  // ============================================
  // Test: canLock / canUnlock Permissions
  // ============================================
  describe('canLock - Role permissions for locking', () => {
    it('ACCOUNTANT can lock KT tier', () => {
      expect(canLock('ACCOUNTANT', 'KT')).toBe(true);
    });

    it('ADMIN can lock KT tier', () => {
      expect(canLock('ADMIN', 'KT')).toBe(true);
    });

    it('SELLER cannot lock KT tier', () => {
      expect(canLock('SELLER', 'KT')).toBe(false);
    });

    it('OPERATOR cannot lock KT tier', () => {
      expect(canLock('OPERATOR', 'KT')).toBe(false);
    });

    it('ADMIN can lock Admin tier', () => {
      expect(canLock('ADMIN', 'Admin')).toBe(true);
    });

    it('ACCOUNTANT cannot lock Admin tier', () => {
      expect(canLock('ACCOUNTANT', 'Admin')).toBe(false);
    });

    it('ADMIN can lock Final tier', () => {
      expect(canLock('ADMIN', 'Final')).toBe(true);
    });
  });

  describe('canUnlock - Role permissions for unlocking', () => {
    it('ACCOUNTANT can unlock KT tier', () => {
      expect(canUnlock('ACCOUNTANT', 'KT')).toBe(true);
    });

    it('ADMIN can unlock all tiers', () => {
      expect(canUnlock('ADMIN', 'KT')).toBe(true);
      expect(canUnlock('ADMIN', 'Admin')).toBe(true);
      expect(canUnlock('ADMIN', 'Final')).toBe(true);
    });

    it('SELLER cannot unlock any tier', () => {
      expect(canUnlock('SELLER', 'KT')).toBe(false);
      expect(canUnlock('SELLER', 'Admin')).toBe(false);
      expect(canUnlock('SELLER', 'Final')).toBe(false);
    });
  });

  // ============================================
  // Test: canLockTier - Sequential Progression
  // ============================================
  describe('canLockTier - Sequential lock progression', () => {
    const noLocks = { lockKT: false, lockAdmin: false, lockFinal: false };
    const ktLocked = { lockKT: true, lockAdmin: false, lockFinal: false };
    const bothLocked = { lockKT: true, lockAdmin: true, lockFinal: false };
    const allLocked = { lockKT: true, lockAdmin: true, lockFinal: true };

    it('Can lock KT when no locks exist', () => {
      expect(canLockTier(noLocks, 'KT')).toBe(true);
    });

    it('Cannot lock KT when already locked', () => {
      expect(canLockTier(ktLocked, 'KT')).toBe(false);
    });

    it('Cannot lock Admin without KT lock first', () => {
      expect(canLockTier(noLocks, 'Admin')).toBe(false);
    });

    it('Can lock Admin when KT is locked', () => {
      expect(canLockTier(ktLocked, 'Admin')).toBe(true);
    });

    it('Cannot lock Final without Admin lock first', () => {
      expect(canLockTier(ktLocked, 'Final')).toBe(false);
    });

    it('Can lock Final when both KT and Admin are locked', () => {
      expect(canLockTier(bothLocked, 'Final')).toBe(true);
    });

    it('Cannot lock Final when already locked', () => {
      expect(canLockTier(allLocked, 'Final')).toBe(false);
    });
  });

  // ============================================
  // Test: canUnlockTier - Reverse Order Progression
  // ============================================
  describe('canUnlockTier - Reverse unlock progression', () => {
    const noLocks = { lockKT: false, lockAdmin: false, lockFinal: false };
    const ktLocked = { lockKT: true, lockAdmin: false, lockFinal: false };
    const bothLocked = { lockKT: true, lockAdmin: true, lockFinal: false };
    const allLocked = { lockKT: true, lockAdmin: true, lockFinal: true };

    it('Cannot unlock any tier when none are locked', () => {
      expect(canUnlockTier(noLocks, 'KT')).toBe(false);
      expect(canUnlockTier(noLocks, 'Admin')).toBe(false);
      expect(canUnlockTier(noLocks, 'Final')).toBe(false);
    });

    it('Can unlock Final when Final is locked', () => {
      expect(canUnlockTier(allLocked, 'Final')).toBe(true);
    });

    it('Cannot unlock Admin when Final is locked', () => {
      expect(canUnlockTier(allLocked, 'Admin')).toBe(false);
    });

    it('Can unlock Admin when Final is unlocked', () => {
      expect(canUnlockTier(bothLocked, 'Admin')).toBe(true);
    });

    it('Cannot unlock KT when Admin is locked', () => {
      expect(canUnlockTier(bothLocked, 'KT')).toBe(false);
    });

    it('Can unlock KT when Admin is unlocked', () => {
      expect(canUnlockTier(ktLocked, 'KT')).toBe(true);
    });
  });

  // ============================================
  // Test: isEditable
  // ============================================
  describe('isEditable - Check if record is editable', () => {
    it('Record is editable with no locks', () => {
      const state = { lockKT: false, lockAdmin: false, lockFinal: false };
      expect(isEditable(state)).toBe(true);
    });

    it('Record is not editable with KT lock', () => {
      const state = { lockKT: true, lockAdmin: false, lockFinal: false };
      expect(isEditable(state)).toBe(false);
    });

    it('Record is not editable with Admin lock', () => {
      const state = { lockKT: false, lockAdmin: true, lockFinal: false };
      expect(isEditable(state)).toBe(false);
    });

    it('Record is not editable with Final lock', () => {
      const state = { lockKT: false, lockAdmin: false, lockFinal: true };
      expect(isEditable(state)).toBe(false);
    });

    it('Record is not editable with any combination of locks', () => {
      const state = { lockKT: true, lockAdmin: true, lockFinal: true };
      expect(isEditable(state)).toBe(false);
    });
  });

  // ============================================
  // Test: getLockFields
  // ============================================
  describe('getLockFields - Generate DB update fields', () => {
    const userId = 'user-123';

    it('generates lock fields for KT tier', () => {
      const fields = getLockFields('KT', userId, true);
      expect(fields.lockKT).toBe(true);
      expect(fields.lockKTAt).toBeInstanceOf(Date);
      expect(fields.lockKTBy).toBe(userId);
    });

    it('generates lock fields for Admin tier', () => {
      const fields = getLockFields('Admin', userId, true);
      expect(fields.lockAdmin).toBe(true);
      expect(fields.lockAdminAt).toBeInstanceOf(Date);
      expect(fields.lockAdminBy).toBe(userId);
    });

    it('generates lock fields for Final tier', () => {
      const fields = getLockFields('Final', userId, true);
      expect(fields.lockFinal).toBe(true);
      expect(fields.lockFinalAt).toBeInstanceOf(Date);
      expect(fields.lockFinalBy).toBe(userId);
    });

    it('generates unlock fields (sets to false/null)', () => {
      const fields = getLockFields('KT', userId, false);
      expect(fields.lockKT).toBe(false);
      expect(fields.lockKTAt).toBeNull();
      expect(fields.lockKTBy).toBeNull();
    });

    it('sets correct timestamp for lock operations', () => {
      const before = new Date();
      const fields = getLockFields('KT', userId, true);
      const after = new Date();

      expect((fields.lockKTAt as Date).getTime()).toBeGreaterThanOrEqual(
        before.getTime()
      );
      expect((fields.lockKTAt as Date).getTime()).toBeLessThanOrEqual(
        after.getTime()
      );
    });
  });

  // ============================================
  // Test: getCurrentLockTier
  // ============================================
  describe('getCurrentLockTier - Get highest active lock tier', () => {
    it('returns null when no locks', () => {
      const state = { lockKT: false, lockAdmin: false, lockFinal: false };
      expect(getCurrentLockTier(state)).toBeNull();
    });

    it('returns KT when only KT is locked', () => {
      const state = { lockKT: true, lockAdmin: false, lockFinal: false };
      expect(getCurrentLockTier(state)).toBe('KT');
    });

    it('returns Admin when KT and Admin are locked', () => {
      const state = { lockKT: true, lockAdmin: true, lockFinal: false };
      expect(getCurrentLockTier(state)).toBe('Admin');
    });

    it('returns Final when all are locked', () => {
      const state = { lockKT: true, lockAdmin: true, lockFinal: true };
      expect(getCurrentLockTier(state)).toBe('Final');
    });

    it('prioritizes higher tiers (Final > Admin > KT)', () => {
      const state = { lockKT: true, lockAdmin: false, lockFinal: true };
      expect(getCurrentLockTier(state)).toBe('Final');
    });
  });

  // ============================================
  // Test: getActiveLockTiers
  // ============================================
  describe('getActiveLockTiers - Get all active lock tiers', () => {
    it('returns empty array when no locks', () => {
      const state = { lockKT: false, lockAdmin: false, lockFinal: false };
      expect(getActiveLockTiers(state)).toEqual([]);
    });

    it('returns [KT] when only KT is locked', () => {
      const state = { lockKT: true, lockAdmin: false, lockFinal: false };
      expect(getActiveLockTiers(state)).toEqual(['KT']);
    });

    it('returns [KT, Admin] when both are locked', () => {
      const state = { lockKT: true, lockAdmin: true, lockFinal: false };
      expect(getActiveLockTiers(state)).toEqual(['KT', 'Admin']);
    });

    it('returns all tiers when all are locked', () => {
      const state = { lockKT: true, lockAdmin: true, lockFinal: true };
      expect(getActiveLockTiers(state)).toEqual(['KT', 'Admin', 'Final']);
    });
  });

  // ============================================
  // Test: hasAnyLock
  // ============================================
  describe('hasAnyLock - Check if any lock is active', () => {
    it('returns false when no locks', () => {
      const state = { lockKT: false, lockAdmin: false, lockFinal: false };
      expect(hasAnyLock(state)).toBe(false);
    });

    it('returns true when KT is locked', () => {
      const state = { lockKT: true, lockAdmin: false, lockFinal: false };
      expect(hasAnyLock(state)).toBe(true);
    });

    it('returns true when Admin is locked', () => {
      const state = { lockKT: false, lockAdmin: true, lockFinal: false };
      expect(hasAnyLock(state)).toBe(true);
    });

    it('returns true when Final is locked', () => {
      const state = { lockKT: false, lockAdmin: false, lockFinal: true };
      expect(hasAnyLock(state)).toBe(true);
    });

    it('returns true when any combination of locks exist', () => {
      const state = { lockKT: true, lockAdmin: true, lockFinal: true };
      expect(hasAnyLock(state)).toBe(true);
    });
  });

  // ============================================
  // Test: Configuration Constants
  // ============================================
  describe('Lock configuration constants', () => {
    it('LOCK_TIERS has 3 tiers', () => {
      expect(LOCK_TIERS).toEqual(['KT', 'Admin', 'Final']);
    });

    it('LOCK_TIER_ORDER has correct progression', () => {
      expect(LOCK_TIER_ORDER.KT).toBe(1);
      expect(LOCK_TIER_ORDER.Admin).toBe(2);
      expect(LOCK_TIER_ORDER.Final).toBe(3);
    });

    it('LOCK_PERMISSIONS configured for all tiers', () => {
      expect(LOCK_PERMISSIONS.KT).toBeDefined();
      expect(LOCK_PERMISSIONS.Admin).toBeDefined();
      expect(LOCK_PERMISSIONS.Final).toBeDefined();
    });

    it('KT tier allows ACCOUNTANT and ADMIN to lock/unlock', () => {
      expect(LOCK_PERMISSIONS.KT.lock).toContain('ACCOUNTANT');
      expect(LOCK_PERMISSIONS.KT.lock).toContain('ADMIN');
      expect(LOCK_PERMISSIONS.KT.unlock).toContain('ACCOUNTANT');
      expect(LOCK_PERMISSIONS.KT.unlock).toContain('ADMIN');
    });

    it('Admin and Final tiers allow only ADMIN', () => {
      expect(LOCK_PERMISSIONS.Admin.lock).toEqual(['ADMIN']);
      expect(LOCK_PERMISSIONS.Final.lock).toEqual(['ADMIN']);
    });
  });
});
</file>

<file path="src/__tests__/lib/report-utils.test.ts">
/**
 * @jest-environment node
 */

// Tests for report utility functions
// Covers: getDateRange, getComparisonRange, formatPeriodKey, calcChangePercent

import {
  getDateRange,
  getComparisonRange,
  formatPeriodKey,
  calcChangePercent,
  type DateRangeOption
} from '@/lib/report-utils';

describe('getDateRange', () => {
  it('should return thisMonth range with correct structure', () => {
    const result = getDateRange('thisMonth');

    expect(result).toHaveProperty('startDate');
    expect(result).toHaveProperty('endDate');
    expect(result).toHaveProperty('label');

    expect(result.startDate instanceof Date).toBe(true);
    expect(result.endDate instanceof Date).toBe(true);

    // Start date should be day 1 of month
    expect(result.startDate.getDate()).toBe(1);

    // End date should be after start date
    expect(result.endDate.getTime()).toBeGreaterThan(result.startDate.getTime());

    expect(result.label).toContain('Thang');
  });

  it('should return lastMonth range with correct structure', () => {
    const result = getDateRange('lastMonth');

    expect(result).toHaveProperty('startDate');
    expect(result).toHaveProperty('endDate');
    expect(result.label).toContain('Thang');

    expect(result.endDate.getTime()).toBeGreaterThan(result.startDate.getTime());
  });

  it('should return last3Months range', () => {
    const result = getDateRange('last3Months');

    expect(result.startDate instanceof Date).toBe(true);
    expect(result.endDate instanceof Date).toBe(true);
    expect(result.label).toBe('3 thang gan day');

    const duration = result.endDate.getTime() - result.startDate.getTime();
    const threeDaysInMs = 3 * 30 * 24 * 60 * 60 * 1000; // Approximate
    expect(duration).toBeGreaterThan(threeDaysInMs * 0.8); // Allow some variance
  });

  it('should return last6Months range', () => {
    const result = getDateRange('last6Months');

    expect(result.label).toBe('6 thang gan day');
    expect(result.startDate instanceof Date).toBe(true);
    expect(result.endDate instanceof Date).toBe(true);
  });

  it('should return thisYear range', () => {
    const result = getDateRange('thisYear');

    expect(result.label).toContain('Nam');
    expect(result.startDate.getDate()).toBe(1);
    expect(result.startDate.getMonth()).toBe(0); // January
  });

  it('should return consistent label for known ranges', () => {
    const thisMonth = getDateRange('thisMonth');
    const lastMonth = getDateRange('lastMonth');
    const last3 = getDateRange('last3Months');
    const last6 = getDateRange('last6Months');
    const year = getDateRange('thisYear');

    expect(thisMonth.label).toMatch(/Thang \d+\/\d+/);
    expect(lastMonth.label).toMatch(/Thang \d+\/\d+/);
    expect(last3.label).toBe('3 thang gan day');
    expect(last6.label).toBe('6 thang gan day');
    expect(year.label).toMatch(/Nam \d+/);
  });
});

describe('getComparisonRange', () => {
  it('should return previous period with same duration as current', () => {
    const current = getDateRange('thisMonth');
    const comparison = getComparisonRange('thisMonth');

    const currentDuration = current.endDate.getTime() - current.startDate.getTime();
    const comparisonDuration = comparison.endDate.getTime() - comparison.startDate.getTime();

    // Duration should be approximately equal (within 1 second)
    expect(Math.abs(currentDuration - comparisonDuration)).toBeLessThan(1000);
  });

  it('should have label "Ky truoc"', () => {
    const result = getComparisonRange('thisMonth');
    expect(result.label).toBe('Ky truoc');
  });

  it('should return dates before current range', () => {
    const current = getDateRange('last3Months');
    const comparison = getComparisonRange('last3Months');

    expect(comparison.endDate.getTime()).toBeLessThan(current.startDate.getTime());
  });

  it('should return valid DateRange objects for all range types', () => {
    const ranges = ['thisMonth', 'lastMonth', 'last3Months', 'last6Months', 'thisYear'] as const;

    for (const range of ranges) {
      const result = getComparisonRange(range);
      expect(result).toHaveProperty('startDate');
      expect(result).toHaveProperty('endDate');
      expect(result.label).toBe('Ky truoc');
      expect(result.startDate instanceof Date).toBe(true);
      expect(result.endDate instanceof Date).toBe(true);
    }
  });

  it('should return comparison period ending before current period starts', () => {
    const ranges = ['thisMonth', 'lastMonth', 'last3Months', 'last6Months', 'thisYear'] as const;

    for (const range of ranges) {
      const current = getDateRange(range);
      const comparison = getComparisonRange(range);
      expect(comparison.endDate.getTime()).toBeLessThan(current.startDate.getTime());
    }
  });
});

describe('formatPeriodKey', () => {
  it('should format date as YYYY-MM with zero-padded month', () => {
    const date = new Date('2026-01-15');
    const result = formatPeriodKey(date);
    expect(result).toBe('2026-01');
  });

  it('should handle double-digit months', () => {
    const date = new Date('2026-12-25');
    const result = formatPeriodKey(date);
    expect(result).toBe('2026-12');
  });

  it('should pad single-digit months with zero', () => {
    const date = new Date('2025-02-28');
    const result = formatPeriodKey(date);
    expect(result).toBe('2025-02');
  });

  it('should handle different years', () => {
    const date2024 = new Date('2024-05-01');
    const date2026 = new Date('2026-05-01');

    expect(formatPeriodKey(date2024)).toBe('2024-05');
    expect(formatPeriodKey(date2026)).toBe('2026-05');
  });
});

describe('calcChangePercent', () => {
  it('should calculate positive change correctly', () => {
    const result = calcChangePercent(200, 100);
    expect(result).toBe(100); // 100% increase
  });

  it('should calculate negative change correctly', () => {
    const result = calcChangePercent(50, 100);
    expect(result).toBe(-50); // 50% decrease
  });

  it('should handle zero previous value with positive current', () => {
    const result = calcChangePercent(100, 0);
    expect(result).toBe(100); // 100% when previous is 0
  });

  it('should handle zero previous value with zero current', () => {
    const result = calcChangePercent(0, 0);
    expect(result).toBe(0); // 0% when both are 0
  });

  it('should return 0 for identical values', () => {
    const result = calcChangePercent(100, 100);
    expect(result).toBe(0); // No change
  });

  it('should round to 2 decimal places', () => {
    const result = calcChangePercent(333, 100);
    expect(result).toBe(233); // (333-100)/100 * 100 = 233%
  });

  it('should handle decimal results with rounding', () => {
    // (150 - 100) / 100 = 0.5 = 50%
    const result = calcChangePercent(150, 100);
    expect(result).toBe(50);
  });

  it('should handle fractional percentages', () => {
    // (101 - 100) / 100 = 0.01 = 1%
    const result = calcChangePercent(101, 100);
    expect(result).toBe(1);
  });

  it('should handle large numbers', () => {
    const result = calcChangePercent(1000000, 500000);
    expect(result).toBe(100); // 100% increase
  });

  it('should handle very small percentages', () => {
    const result = calcChangePercent(1001, 1000);
    expect(result).toBe(0.1); // 0.1% increase
  });
});
</file>

<file path="src/__tests__/lib/report-validation.test.ts">
/**
 * @jest-environment node
 */

// Tests for report validation schemas
// Covers: reportQuerySchema, extractReportZodErrors

import {
  reportQuerySchema,
  extractReportZodErrors,
  type ReportQueryParams,
  DATE_RANGE_OPTIONS
} from '@/lib/validations/report-validation';
import { z } from 'zod';

describe('reportQuerySchema', () => {
  it('should validate valid range options', () => {
    const validRanges = ['thisMonth', 'lastMonth', 'last3Months', 'last6Months', 'thisYear'];

    for (const range of validRanges) {
      const result = reportQuerySchema.safeParse({ range });
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.range).toBe(range);
      }
    }
  });

  it('should reject invalid range options', () => {
    const result = reportQuerySchema.safeParse({ range: 'invalidRange' });
    expect(result.success).toBe(false);

    if (!result.success) {
      expect(result.error.issues.length).toBeGreaterThan(0);
      expect(result.error.issues[0].message).toContain('Khoang thoi gian khong hop le');
    }
  });

  it('should default to thisMonth when range is not provided', () => {
    const result = reportQuerySchema.safeParse({});
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.range).toBe('thisMonth');
    }
  });

  it('should handle empty object', () => {
    const result = reportQuerySchema.safeParse({});
    expect(result.success).toBe(true);
  });

  it('should accept null range and use default', () => {
    const result = reportQuerySchema.safeParse({ range: undefined });
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data.range).toBe('thisMonth');
    }
  });

  it('should return correct type', () => {
    const result = reportQuerySchema.parse({ range: 'lastMonth' });
    const expected: ReportQueryParams = { range: 'lastMonth' };
    expect(result).toEqual(expected);
  });

  it('should validate with extra properties (ignored)', () => {
    const result = reportQuerySchema.safeParse({
      range: 'thisMonth',
      extraProp: 'ignored'
    });
    expect(result.success).toBe(true);
    if (result.success) {
      expect(result.data).toEqual({ range: 'thisMonth' });
    }
  });

  it('should reject empty string range', () => {
    const result = reportQuerySchema.safeParse({ range: '' });
    expect(result.success).toBe(false);
  });

  it('should reject null range', () => {
    const result = reportQuerySchema.safeParse({ range: null });
    expect(result.success).toBe(false);
  });

  it('should be case-sensitive for range values', () => {
    const result = reportQuerySchema.safeParse({ range: 'ThisMonth' });
    expect(result.success).toBe(false);
  });
});

describe('extractReportZodErrors', () => {
  it('should extract single field error', () => {
    const result = reportQuerySchema.safeParse({ range: 'invalid' });

    if (!result.success) {
      const errors = extractReportZodErrors(result.error);
      expect(errors).toHaveProperty('range');
      expect(errors.range).toContain('Khoang thoi gian khong hop le');
    }
  });

  it('should extract multiple field errors', () => {
    const schema = z.object({
      range: z.enum(['valid1', 'valid2']),
      other: z.string().min(5)
    });

    const result = schema.safeParse({ range: 'invalid', other: 'hi' });

    if (!result.success) {
      const errors = extractReportZodErrors(result.error);
      expect(Object.keys(errors).length).toBeGreaterThanOrEqual(1);
    }
  });

  it('should return empty object for valid data', () => {
    const result = reportQuerySchema.safeParse({ range: 'thisMonth' });

    if (result.success) {
      const errors = extractReportZodErrors(new z.ZodError([]));
      expect(errors).toEqual({});
    }
  });

  it('should handle nested field errors with dot notation', () => {
    const schema = z.object({
      nested: z.object({
        field: z.string()
      })
    });

    const result = schema.safeParse({ nested: { field: 123 } });

    if (!result.success) {
      const errors = extractReportZodErrors(result.error);
      expect(Object.keys(errors)[0]).toContain('nested');
    }
  });

  it('should not duplicate errors for same field', () => {
    const schema = z.object({
      field: z.string().min(5).max(10)
    });

    const result = schema.safeParse({ field: 'x' });

    if (!result.success) {
      const errors = extractReportZodErrors(result.error);
      // Should have only one entry for 'field', not multiple
      expect(Object.keys(errors).filter(k => k === 'field').length).toBe(1);
    }
  });

  it('should extract error message', () => {
    const schema = z.object({
      range: z.enum(['a', 'b'], {
        message: 'Custom error message'
      })
    });

    const result = schema.safeParse({ range: 'invalid' });

    if (!result.success) {
      const errors = extractReportZodErrors(result.error);
      expect(errors.range).toBeTruthy();
    }
  });
});

describe('DATE_RANGE_OPTIONS constant', () => {
  it('should have all expected date range options', () => {
    expect(DATE_RANGE_OPTIONS).toContain('thisMonth');
    expect(DATE_RANGE_OPTIONS).toContain('lastMonth');
    expect(DATE_RANGE_OPTIONS).toContain('last3Months');
    expect(DATE_RANGE_OPTIONS).toContain('last6Months');
    expect(DATE_RANGE_OPTIONS).toContain('thisYear');
  });

  it('should be readonly array', () => {
    // This test verifies the constant is const by checking if we can modify it
    // @ts-ignore - Intentionally trying to modify readonly
    expect(() => {
      const arr = DATE_RANGE_OPTIONS as any;
      arr.push('newOption');
    }).not.toThrow(); // JS doesn't prevent modification, just TS
  });

  it('should have at least 5 options', () => {
    expect(DATE_RANGE_OPTIONS.length).toBeGreaterThanOrEqual(5);
  });
});
</file>

<file path="src/app/(dashboard)/layout.tsx">
import { Header } from "@/components/layout/Header";
import { AIAssistant } from "@/components/layout/AIAssistant";
import { SessionProviderWrapper } from "@/components/providers";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <SessionProviderWrapper>
      <div className="min-h-screen bg-gray-50">
        <Header />
        <main className="container mx-auto px-4 py-6 max-w-7xl">
          {children}
        </main>
        <AIAssistant />
      </div>
    </SessionProviderWrapper>
  );
}
</file>

<file path="src/app/(dashboard)/operators/[id]/error.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /operators/[id] route.
 * Handles errors including "Operator not found" cases.
 */
export default function OperatorDetailError({ error, reset }: ErrorProps) {
  const router = useRouter();

  useEffect(() => {
    console.error("[OperatorDetailError]", error);
  }, [error]);

  const handleBack = () => {
    router.push("/operators");
  };

  // Check if error is "not found" type
  const isNotFound =
    error.message?.toLowerCase().includes("not found") ||
    error.message?.toLowerCase().includes("không tìm thấy");

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title={isNotFound ? "Không tìm thấy dịch vụ" : "Lỗi tải dịch vụ"}
        message={
          isNotFound
            ? "Dịch vụ này không tồn tại hoặc đã bị xóa."
            : "Không thể tải chi tiết dịch vụ. Vui lòng thử lại."
        }
        onRetry={isNotFound ? undefined : reset}
        onBack={handleBack}
        backLabel="Về danh sách"
        retryLabel="Thử lại"
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/operators/approvals/error.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /operators/approvals route.
 * Catches errors in the payment approval queue page.
 */
export default function ApprovalsError({ error, reset }: ErrorProps) {
  const router = useRouter();

  useEffect(() => {
    console.error("[ApprovalsError]", error);
  }, [error]);

  const handleBack = () => {
    router.push("/operators");
  };

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title="Lỗi tải danh sách duyệt"
        message="Không thể tải danh sách chờ duyệt thanh toán. Vui lòng thử lại hoặc quay lại."
        onRetry={reset}
        onBack={handleBack}
        backLabel="Quay lại"
        retryLabel="Thử lại"
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/operators/create/error.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /operators/create route.
 * Catches errors in the create operator page.
 */
export default function CreateOperatorError({ error, reset }: ErrorProps) {
  const router = useRouter();

  useEffect(() => {
    console.error("[CreateOperatorError]", error);
  }, [error]);

  const handleBack = () => {
    router.push("/operators");
  };

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title="Lỗi tạo dịch vụ"
        message="Không thể tải trang tạo dịch vụ. Vui lòng thử lại hoặc quay lại danh sách."
        onRetry={reset}
        onBack={handleBack}
        backLabel="Quay lại danh sách"
        retryLabel="Thử lại"
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/operators/error.tsx">
"use client";

import { useEffect } from "react";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /operators route.
 * Catches errors in the operators list page.
 */
export default function OperatorsError({ error, reset }: ErrorProps) {
  useEffect(() => {
    console.error("[OperatorsError]", error);
  }, [error]);

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title="Lỗi tải danh sách điều hành"
        message="Không thể tải danh sách dịch vụ điều hành. Vui lòng thử lại sau."
        onRetry={reset}
        retryLabel="Tải lại"
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/operators/reports/error.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /operators/reports route.
 * Catches errors in the operator reports page.
 */
export default function OperatorReportsError({ error, reset }: ErrorProps) {
  const router = useRouter();

  useEffect(() => {
    console.error("[OperatorReportsError]", error);
  }, [error]);

  const handleBack = () => {
    router.push("/operators");
  };

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title="Lỗi tải báo cáo"
        message="Không thể tải trang báo cáo chi phí. Vui lòng thử lại hoặc quay lại danh sách."
        onRetry={reset}
        onBack={handleBack}
        backLabel="Quay lại danh sách"
        retryLabel="Thử lại"
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/reports/page.tsx">
'use client';

import { useState } from 'react';
import { usePermission } from '@/hooks/use-permission';
import { useReports, type DateRangeOption } from '@/hooks/use-reports';
import { ErrorFallback } from '@/components/ui/error-fallback';
import { DateRangeSelector } from '@/components/reports/date-range-selector';
import { KPICards } from '@/components/reports/kpi-cards';
import { RevenueTrendChart } from '@/components/reports/revenue-trend-chart';
import { CostBreakdownChart } from '@/components/reports/cost-breakdown-chart';
import { FunnelChart } from '@/components/reports/funnel-chart';
import { BarChart3 } from 'lucide-react';

export default function ReportsPage() {
  const { isAdmin, isAccountant, isLoading: authLoading } = usePermission();
  const [dateRange, setDateRange] = useState<DateRangeOption>('last6Months');
  const { dashboard, trend, costBreakdown, funnel, loading, error, refetch } =
    useReports(dateRange);

  // Permission check
  if (authLoading) {
    return <div className="text-center py-10">Đang tải...</div>;
  }

  if (!isAdmin && !isAccountant) {
    return (
      <ErrorFallback
        title="Không có quyền truy cập"
        message="Bạn cần quyền Admin hoặc Kế toán để xem báo cáo."
      />
    );
  }

  if (error) {
    return (
      <ErrorFallback
        title="Lỗi tải báo cáo"
        message={error}
        onRetry={refetch}
        retryLabel="Tải lại"
      />
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <BarChart3 className="h-6 w-6" />
            Báo cáo Tổng quan
          </h1>
          <p className="text-muted-foreground">Phân tích hiệu suất kinh doanh</p>
        </div>
        <DateRangeSelector value={dateRange} onChange={setDateRange} />
      </div>

      {/* KPI Cards */}
      <KPICards data={dashboard} loading={loading} />

      {/* Revenue Trend */}
      <RevenueTrendChart data={trend} loading={loading} />

      {/* Cost Breakdown & Funnel */}
      <div className="grid md:grid-cols-2 gap-6">
        <CostBreakdownChart data={costBreakdown} loading={loading} />
        <FunnelChart data={funnel} loading={loading} />
      </div>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/requests/[id]/edit/error.tsx">
"use client";

import { useEffect } from "react";
import { useRouter, useParams } from "next/navigation";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /requests/[id]/edit route.
 * Handles errors when loading request for editing.
 */
export default function EditRequestError({ error, reset }: ErrorProps) {
  const router = useRouter();
  const params = useParams();

  useEffect(() => {
    // Log error to console (replace with Sentry later)
    console.error("[EditRequestError]", error);
  }, [error]);

  const handleCancel = () => {
    // Try to go back to detail page, fallback to list
    if (params?.id) {
      router.push(`/requests/${params.id}`);
    } else {
      router.push("/requests");
    }
  };

  // Check if error is "not found" type
  const isNotFound =
    error.message?.toLowerCase().includes("not found") ||
    error.message?.toLowerCase().includes("không tìm thấy");

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title={isNotFound ? "Không tìm thấy yêu cầu" : "Lỗi tải form chỉnh sửa"}
        message={
          isNotFound
            ? "Yêu cầu này không tồn tại hoặc đã bị xóa."
            : "Không thể tải dữ liệu để chỉnh sửa. Vui lòng thử lại."
        }
        onRetry={isNotFound ? undefined : reset}
        onBack={handleCancel}
        backLabel="Hủy chỉnh sửa"
        retryLabel="Thử lại"
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/requests/[id]/error.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /requests/[id] route.
 * Handles errors including "Request not found" cases.
 */
export default function RequestDetailError({ error, reset }: ErrorProps) {
  const router = useRouter();

  useEffect(() => {
    // Log error to console (replace with Sentry later)
    console.error("[RequestDetailError]", error);
  }, [error]);

  const handleBack = () => {
    router.push("/requests");
  };

  // Check if error is "not found" type
  const isNotFound =
    error.message?.toLowerCase().includes("not found") ||
    error.message?.toLowerCase().includes("không tìm thấy");

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title={isNotFound ? "Không tìm thấy yêu cầu" : "Lỗi tải yêu cầu"}
        message={
          isNotFound
            ? "Yêu cầu này không tồn tại hoặc đã bị xóa."
            : "Không thể tải chi tiết yêu cầu. Vui lòng thử lại."
        }
        onRetry={isNotFound ? undefined : reset}
        onBack={handleBack}
        backLabel="Về danh sách"
        retryLabel="Thử lại"
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/requests/create/error.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /requests/create route.
 * Catches errors in the create request page.
 */
export default function CreateRequestError({ error, reset }: ErrorProps) {
  const router = useRouter();

  useEffect(() => {
    // Log error to console (replace with Sentry later)
    console.error("[CreateRequestError]", error);
  }, [error]);

  const handleBack = () => {
    router.push("/requests");
  };

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title="Lỗi tạo yêu cầu"
        message="Không thể tải trang tạo yêu cầu. Vui lòng thử lại hoặc quay lại danh sách."
        onRetry={reset}
        onBack={handleBack}
        backLabel="Quay lại danh sách"
        retryLabel="Thử lại"
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/requests/error.tsx">
"use client";

import { useEffect } from "react";
import { ErrorFallback } from "@/components/ui/error-fallback";

interface ErrorProps {
  error: Error & { digest?: string };
  reset: () => void;
}

/**
 * Error boundary for /requests route.
 * Catches errors in the requests list page.
 */
export default function RequestsError({ error, reset }: ErrorProps) {
  useEffect(() => {
    // Log error to console (replace with Sentry later)
    console.error("[RequestsError]", error);
  }, [error]);

  return (
    <div className="flex h-full items-center justify-center p-6">
      <ErrorFallback
        title="Lỗi tải danh sách yêu cầu"
        message="Không thể tải danh sách yêu cầu. Vui lòng thử lại sau."
        onRetry={reset}
        retryLabel="Tải lại"
      />
    </div>
  );
}
</file>

<file path="src/app/api/auth/[...nextauth]/route.ts">
import { handlers } from "@/auth";

export const { GET, POST } = handlers;
</file>

<file path="src/app/api/config/follow-up-statuses/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { followUpStatusSchema } from '@/lib/validations/config-validation';

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET /api/config/follow-up-statuses/[id] - Get single follow-up status
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;

    const status = await prisma.followUpStatus.findUnique({
      where: { id },
    });

    if (!status) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy trạng thái' },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: status });
  } catch (error) {
    console.error('Error fetching follow-up status:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải trạng thái: ${message}` },
      { status: 500 }
    );
  }
}

// PUT /api/config/follow-up-statuses/[id] - Update follow-up status
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const body = await request.json();

    // Validate with Zod
    const validation = followUpStatusSchema.safeParse(body);
    if (!validation.success) {
      const firstError = validation.error.issues[0];
      return NextResponse.json(
        { success: false, error: firstError.message },
        { status: 400 }
      );
    }

    const data = validation.data;

    // Check if status exists
    const existing = await prisma.followUpStatus.findUnique({
      where: { id },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy trạng thái' },
        { status: 404 }
      );
    }

    // Check if status name is used by another entry
    if (data.status !== existing.status) {
      const existingStatus = await prisma.followUpStatus.findUnique({
        where: { status: data.status },
      });

      if (existingStatus && existingStatus.id !== id) {
        return NextResponse.json(
          { success: false, error: `Trạng thái "${data.status}" đã tồn tại` },
          { status: 400 }
        );
      }
    }

    // Update follow-up status
    const updatedStatus = await prisma.followUpStatus.update({
      where: { id },
      data: {
        status: data.status.trim(),
        aliases: data.aliases,
        daysToFollowup: data.daysToFollowup,
        sortOrder: data.sortOrder ?? existing.sortOrder,
        isActive: data.isActive ?? existing.isActive,
      },
    });

    return NextResponse.json({ success: true, data: updatedStatus });
  } catch (error) {
    console.error('Error updating follow-up status:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi cập nhật trạng thái: ${message}` },
      { status: 500 }
    );
  }
}

// DELETE /api/config/follow-up-statuses/[id] - Delete follow-up status
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;

    const existing = await prisma.followUpStatus.findUnique({
      where: { id },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy trạng thái' },
        { status: 404 }
      );
    }

    await prisma.followUpStatus.delete({
      where: { id },
    });

    return NextResponse.json({
      success: true,
      message: 'Đã xóa trạng thái thành công',
    });
  } catch (error) {
    console.error('Error deleting follow-up status:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi xóa trạng thái: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/config/follow-up-statuses/reorder/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { reorderSchema } from '@/lib/validations/config-validation';

// PUT /api/config/follow-up-statuses/reorder - Batch update sortOrder
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate with Zod
    const validation = reorderSchema.safeParse(body);
    if (!validation.success) {
      const firstError = validation.error.issues[0];
      return NextResponse.json(
        { success: false, error: firstError.message },
        { status: 400 }
      );
    }

    const { items } = validation.data;

    // Verify all IDs exist
    const ids = items.map((item) => item.id);
    const existingStatuses = await prisma.followUpStatus.findMany({
      where: { id: { in: ids } },
      select: { id: true },
    });

    if (existingStatuses.length !== ids.length) {
      return NextResponse.json(
        { success: false, error: 'Một hoặc nhiều trạng thái không tồn tại' },
        { status: 400 }
      );
    }

    // Use transaction to update all sortOrders atomically
    const updatedStatuses = await prisma.$transaction(
      items.map((item) =>
        prisma.followUpStatus.update({
          where: { id: item.id },
          data: { sortOrder: item.sortOrder },
        })
      )
    );

    return NextResponse.json({ success: true, data: updatedStatuses });
  } catch (error) {
    console.error('Error reordering follow-up statuses:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi sắp xếp lại trạng thái: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/config/follow-up-statuses/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { followUpStatusSchema } from '@/lib/validations/config-validation';

// GET /api/config/follow-up-statuses - List follow-up statuses ordered by sortOrder
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const isActive = searchParams.get('isActive');

    // Build where clause
    const where: Record<string, unknown> = {};

    if (isActive !== null && isActive !== '') {
      where.isActive = isActive === 'true';
    }

    // Get statuses ordered by sortOrder
    const statuses = await prisma.followUpStatus.findMany({
      where,
      orderBy: { sortOrder: 'asc' },
    });

    return NextResponse.json({
      success: true,
      data: statuses,
    });
  } catch (error) {
    console.error('Error fetching follow-up statuses:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải danh sách trạng thái: ${message}` },
      { status: 500 }
    );
  }
}

// POST /api/config/follow-up-statuses - Create new follow-up status
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate with Zod
    const validation = followUpStatusSchema.safeParse(body);
    if (!validation.success) {
      const firstError = validation.error.issues[0];
      return NextResponse.json(
        { success: false, error: firstError.message },
        { status: 400 }
      );
    }

    const data = validation.data;

    // Check for duplicate status name
    const existingStatus = await prisma.followUpStatus.findUnique({
      where: { status: data.status },
    });

    if (existingStatus) {
      return NextResponse.json(
        { success: false, error: `Trạng thái "${data.status}" đã tồn tại` },
        { status: 400 }
      );
    }

    // Auto-assign sortOrder if not provided (max + 1)
    let sortOrder = data.sortOrder;
    if (sortOrder === undefined) {
      const maxSortOrder = await prisma.followUpStatus.aggregate({
        _max: { sortOrder: true },
      });
      sortOrder = (maxSortOrder._max.sortOrder ?? -1) + 1;
    }

    // Create follow-up status
    const followUpStatus = await prisma.followUpStatus.create({
      data: {
        status: data.status.trim(),
        aliases: data.aliases,
        daysToFollowup: data.daysToFollowup,
        sortOrder,
        isActive: data.isActive ?? true,
      },
    });

    return NextResponse.json({ success: true, data: followUpStatus }, { status: 201 });
  } catch (error) {
    console.error('Error creating follow-up status:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo trạng thái: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/[id]/lock/route.ts">
// POST /api/operators/[id]/lock - Lock operator at specific tier
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createOperatorHistory } from '@/lib/operator-history';
import { getSessionUser, unauthorizedResponse, forbiddenResponse } from '@/lib/auth-utils';
import {
  canLock,
  canLockTier,
  getLockFields,
  getLockHistoryAction,
  type LockTier,
  LOCK_TIERS,
} from '@/lib/lock-utils';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const { id } = await params;
    const body = await request.json();
    const tier = (body.tier as LockTier) || 'KT';

    // Validate tier
    if (!LOCK_TIERS.includes(tier)) {
      return NextResponse.json(
        { success: false, error: `Tier khóa không hợp lệ: ${tier}` },
        { status: 400 }
      );
    }

    // Check permission for this tier
    if (!canLock(user.role, tier)) {
      return forbiddenResponse(`Không có quyền khóa tier: ${tier}`);
    }

    // Get current operator state
    const operator = await prisma.operator.findUnique({
      where: { id },
      select: {
        id: true,
        lockKT: true,
        lockAdmin: true,
        lockFinal: true,
        serviceName: true,
      },
    });

    if (!operator) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy dịch vụ' },
        { status: 404 }
      );
    }

    // Validate tier progression
    const lockState = {
      lockKT: operator.lockKT,
      lockAdmin: operator.lockAdmin,
      lockFinal: operator.lockFinal,
    };

    if (!canLockTier(lockState, tier)) {
      return NextResponse.json(
        {
          success: false,
          error: `Không thể khóa tier ${tier}. Phải theo thứ tự: KT → Admin → Final`,
          currentState: lockState,
        },
        { status: 400 }
      );
    }

    // Apply lock + sync legacy isLocked field
    const lockFields = getLockFields(tier, user.id, true);
    const updated = await prisma.operator.update({
      where: { id },
      data: {
        ...lockFields,
        isLocked: true, // Keep legacy field in sync
        lockedAt: new Date(),
        lockedBy: user.id,
      },
    });

    // Create history entry
    await createOperatorHistory({
      operatorId: id,
      action: getLockHistoryAction(tier, true),
      changes: { tier, ...lockFields },
      userId: user.id,
    });

    return NextResponse.json({
      success: true,
      data: { tier, operator: updated },
    });
  } catch (error) {
    console.error('Lock operator error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi khóa dịch vụ: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/approve/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { requirePermission } from '@/lib/auth-utils';

// POST /api/operators/approve - Batch approve (Accountant/Admin)
export async function POST(request: NextRequest) {
  try {
    // Verify permission - only operator:approve can approve
    const { user, error } = await requirePermission('operator:approve');
    if (error) return error;

    const body = await request.json();

    // Validate
    if (!body.operatorIds || !Array.isArray(body.operatorIds) || body.operatorIds.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Vui lòng chọn ít nhất 1 dịch vụ' },
        { status: 400 }
      );
    }

    if (!body.paymentDate) {
      return NextResponse.json(
        { success: false, error: 'Vui lòng chọn ngày thanh toán' },
        { status: 400 }
      );
    }

    const paymentDate = new Date(body.paymentDate);

    // Verify all operators exist and are not locked
    const operators = await prisma.operator.findMany({
      where: {
        id: { in: body.operatorIds },
      },
    });

    if (operators.length !== body.operatorIds.length) {
      return NextResponse.json(
        { success: false, error: 'Một số dịch vụ không tồn tại' },
        { status: 404 }
      );
    }

    const lockedOps = operators.filter((op) => op.isLocked);
    if (lockedOps.length > 0) {
      return NextResponse.json(
        { success: false, error: `Có ${lockedOps.length} dịch vụ đã khóa` },
        { status: 403 }
      );
    }

    // Update all in transaction
    const result = await prisma.$transaction(async (tx) => {
      const updates = await Promise.all(
        body.operatorIds.map(async (id: string) => {
          const op = operators.find((o) => o.id === id);
          const updated = await tx.operator.update({
            where: { id },
            data: {
              paymentStatus: 'PAID',
              paymentDate,
            },
          });

          // Create history
          await tx.operatorHistory.create({
            data: {
              operatorId: id,
              action: 'APPROVE',
              changes: {
                paymentStatus: { before: op?.paymentStatus || 'PENDING', after: 'PAID' },
                paymentDate: { before: op?.paymentDate, after: paymentDate },
              },
              userId: user!.id,
            },
          });

          return updated;
        })
      );

      return updates;
    });

    return NextResponse.json({
      success: true,
      data: {
        count: result.length,
        totalApproved: result.reduce((sum, op) => sum + Number(op.totalCost), 0),
      },
    });
  } catch (error) {
    console.error('Error batch approving:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi duyệt thanh toán: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/archive/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createOperatorHistory } from '@/lib/operator-history';
import { getSessionUser, unauthorizedResponse } from '@/lib/auth-utils';

/**
 * POST /api/operators/archive
 *
 * Archive operators by IDs or auto-archive completed operators.
 *
 * Input: { ids: string[] } - Archive specific operators
 * Input: { autoArchive: true } - Auto-archive completed operators
 *
 * Auto-archive logic (from MVT_WORKFLOW_MASTER.md section 5.4):
 * - endDate <= last day of previous month
 * - paidAmount >= totalCost (fully paid)
 */
export async function POST(request: NextRequest) {
  try {
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const body = await request.json();
    const { ids, autoArchive } = body;

    // Validate input
    if (!ids && !autoArchive) {
      return NextResponse.json(
        { success: false, error: 'Thiếu tham số: ids hoặc autoArchive' },
        { status: 400 }
      );
    }

    const now = new Date();
    let operatorIds: string[] = [];

    if (autoArchive) {
      // Auto-archive logic: endDate <= lastDayOfPreviousMonth && paidAmount >= totalCost
      const lastDayOfPreviousMonth = new Date(now.getFullYear(), now.getMonth(), 0);
      lastDayOfPreviousMonth.setHours(23, 59, 59, 999);

      // Find operators eligible for auto-archive
      const eligibleOperators = await prisma.operator.findMany({
        where: {
          isArchived: false,
          request: {
            endDate: { lte: lastDayOfPreviousMonth },
          },
        },
        include: {
          request: { select: { endDate: true } },
        },
      });

      // Filter for fully paid (paidAmount >= totalCost)
      operatorIds = eligibleOperators
        .filter((op) => {
          const totalCost = Number(op.totalCost) || 0;
          const paidAmount = Number(op.paidAmount) || 0;
          return paidAmount >= totalCost;
        })
        .map((op) => op.id);

      if (operatorIds.length === 0) {
        return NextResponse.json({
          success: true,
          data: { archivedCount: 0 },
          message: 'Không có dịch vụ nào đủ điều kiện tự động lưu trữ',
        });
      }
    } else {
      // Manual archive by IDs
      if (!Array.isArray(ids) || ids.length === 0) {
        return NextResponse.json(
          { success: false, error: 'Danh sách IDs không hợp lệ' },
          { status: 400 }
        );
      }
      operatorIds = ids;
    }

    // Archive operators
    const updateResult = await prisma.operator.updateMany({
      where: {
        id: { in: operatorIds },
        isArchived: false, // Only archive non-archived
      },
      data: {
        isArchived: true,
        archivedAt: now,
      },
    });

    // Create history entries for each archived operator
    await Promise.all(
      operatorIds.map((id) =>
        createOperatorHistory({
          operatorId: id,
          action: 'ARCHIVE',
          changes: {
            isArchived: { before: false, after: true },
            archivedAt: { before: null, after: now.toISOString() },
          },
          userId: user.id,
        })
      )
    );

    return NextResponse.json({
      success: true,
      data: {
        archivedCount: updateResult.count,
        ids: operatorIds,
      },
      message: `Đã lưu trữ ${updateResult.count} dịch vụ`,
    });
  } catch (error) {
    console.error('Error archiving operators:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi lưu trữ: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/pending-payments/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

// GET /api/operators/pending-payments
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const filter = searchParams.get('filter') || 'all'; // all, today, week, overdue
    const serviceType = searchParams.get('serviceType') || '';
    const supplierId = searchParams.get('supplierId') || '';

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const weekEnd = new Date(today);
    weekEnd.setDate(weekEnd.getDate() + 7);

    // Build where clause
    const where: Record<string, unknown> = {
      paymentStatus: { in: ['PENDING', 'PARTIAL'] },
      isLocked: false,
    };

    if (filter === 'today') {
      where.paymentDeadline = {
        gte: today,
        lt: new Date(today.getTime() + 24 * 60 * 60 * 1000),
      };
    } else if (filter === 'week') {
      where.paymentDeadline = {
        gte: today,
        lt: weekEnd,
      };
    } else if (filter === 'overdue') {
      where.paymentDeadline = { lt: today };
    }

    if (serviceType) where.serviceType = serviceType;
    if (supplierId) where.supplierId = supplierId;

    const operators = await prisma.operator.findMany({
      where,
      include: {
        request: { select: { code: true, customerName: true } },
        supplierRef: { select: { code: true, name: true } },
      },
      orderBy: [
        { paymentDeadline: 'asc' }, // Urgent first
        { serviceDate: 'asc' },
      ],
    });

    // Calculate overdue days and debt for each
    const data = operators.map((op) => {
      let daysOverdue = 0;
      if (op.paymentDeadline) {
        const deadline = new Date(op.paymentDeadline);
        deadline.setHours(0, 0, 0, 0);
        daysOverdue = Math.floor((today.getTime() - deadline.getTime()) / (24 * 60 * 60 * 1000));
      }
      const totalCost = Number(op.totalCost) || 0;
      const paidAmount = Number(op.paidAmount) || 0;
      const debt = totalCost - paidAmount;
      return {
        ...op,
        paidAmount,
        debt,
        daysOverdue,
        requestCode: op.request?.code,
        customerName: op.request?.customerName,
        supplierName: op.supplierRef?.name || op.supplier,
      };
    });

    // Summary with debt tracking
    const summary = {
      total: data.length,
      totalAmount: data.reduce((sum, op) => sum + Number(op.totalCost), 0),
      totalDebt: data.reduce((sum, op) => sum + op.debt, 0),
      totalPaid: data.reduce((sum, op) => sum + op.paidAmount, 0),
      overdue: data.filter((op) => op.daysOverdue > 0).length,
      overdueAmount: data
        .filter((op) => op.daysOverdue > 0)
        .reduce((sum, op) => sum + Number(op.totalCost), 0),
      overdueDebt: data
        .filter((op) => op.daysOverdue > 0)
        .reduce((sum, op) => sum + op.debt, 0),
      dueToday: data.filter((op) => op.daysOverdue === 0).length,
      dueThisWeek: data.filter((op) => op.daysOverdue <= 0 && op.daysOverdue > -7).length,
    };

    return NextResponse.json({ success: true, data, summary });
  } catch (error) {
    console.error('Error fetching pending payments:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải danh sách: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/unarchive/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createOperatorHistory } from '@/lib/operator-history';
import { requireAdmin } from '@/lib/auth-utils';

/**
 * POST /api/operators/unarchive
 *
 * Restore archived operators (Admin only).
 *
 * Input: { ids: string[] }
 */
export async function POST(request: NextRequest) {
  try {
    // Admin only
    const adminCheck = await requireAdmin();
    if (adminCheck.error) {
      return adminCheck.error;
    }
    const user = adminCheck.user!;

    const body = await request.json();
    const { ids } = body;

    if (!Array.isArray(ids) || ids.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Danh sách IDs không hợp lệ' },
        { status: 400 }
      );
    }

    // Unarchive operators
    const updateResult = await prisma.operator.updateMany({
      where: {
        id: { in: ids },
        isArchived: true, // Only unarchive archived ones
      },
      data: {
        isArchived: false,
        archivedAt: null,
      },
    });

    // Create history entries for each unarchived operator
    await Promise.all(
      ids.map((id) =>
        createOperatorHistory({
          operatorId: id,
          action: 'UNARCHIVE',
          changes: {
            isArchived: { before: true, after: false },
            archivedAt: { before: 'archived', after: null },
          },
          userId: user.id,
        })
      )
    );

    return NextResponse.json({
      success: true,
      data: {
        unarchivedCount: updateResult.count,
        ids,
      },
      message: `Đã khôi phục ${updateResult.count} dịch vụ`,
    });
  } catch (error) {
    console.error('Error unarchiving operators:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi khôi phục: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/reports/cost-breakdown/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { hasPermission, type Role } from '@/lib/permissions';
import { prisma } from '@/lib/db';
import { reportQuerySchema } from '@/lib/validations/report-validation';
import { getDateRange, type CostBreakdownResponse } from '@/lib/report-utils';

// GET /api/reports/cost-breakdown - Cost analysis by service type
export async function GET(request: NextRequest) {
  try {
    // Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chua dang nhap' },
        { status: 401 }
      );
    }

    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:view')) {
      return NextResponse.json(
        { success: false, error: 'Khong co quyen xem bao cao' },
        { status: 403 }
      );
    }

    // Parse query params
    const { searchParams } = new URL(request.url);
    const rangeParam = searchParams.get('range') || 'thisMonth';
    const validation = reportQuerySchema.safeParse({ range: rangeParam });

    if (!validation.success) {
      return NextResponse.json(
        { success: false, error: 'Khoang thoi gian khong hop le' },
        { status: 400 }
      );
    }

    const { range } = validation.data;
    const dateRange = getDateRange(range);

    // Query operators grouped by service type (exclude archived)
    const operators = await prisma.operator.findMany({
      where: {
        isArchived: false,
        serviceDate: { gte: dateRange.startDate, lte: dateRange.endDate }
      },
      select: {
        serviceType: true,
        totalCost: true,
        paymentStatus: true
      }
    });

    // Group by service type
    const typeMap = new Map<string, number>();
    let totalCost = 0;
    let paid = 0;
    let partial = 0;
    let unpaid = 0;

    for (const op of operators) {
      const cost = Number(op.totalCost);
      totalCost += cost;
      typeMap.set(op.serviceType, (typeMap.get(op.serviceType) || 0) + cost);

      // Payment status aggregation
      switch (op.paymentStatus) {
        case 'PAID':
          paid += cost;
          break;
        case 'PARTIAL':
          partial += cost;
          break;
        default:
          unpaid += cost;
      }
    }

    // Format by service type with percentage
    const byServiceType = Array.from(typeMap.entries())
      .map(([type, amount]) => ({
        type,
        amount,
        percentage: totalCost > 0 ? Math.round((amount / totalCost) * 10000) / 100 : 0
      }))
      .sort((a, b) => b.amount - a.amount);

    const response: CostBreakdownResponse = {
      byServiceType,
      paymentStatus: { paid, partial, unpaid },
      dateRange
    };

    return NextResponse.json({ success: true, data: response });
  } catch (error) {
    console.error('Error generating cost breakdown:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Loi tao bao cao chi phi: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/reports/dashboard/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { hasPermission, type Role } from '@/lib/permissions';
import { prisma } from '@/lib/db';
import { reportQuerySchema } from '@/lib/validations/report-validation';
import {
  getDateRange,
  getComparisonRange,
  calcChangePercent,
  type DashboardResponse
} from '@/lib/report-utils';

// GET /api/reports/dashboard - Main KPI dashboard
export async function GET(request: NextRequest) {
  try {
    // Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chua dang nhap' },
        { status: 401 }
      );
    }

    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:view')) {
      return NextResponse.json(
        { success: false, error: 'Khong co quyen xem bao cao' },
        { status: 403 }
      );
    }

    // Parse query params
    const { searchParams } = new URL(request.url);
    const rangeParam = searchParams.get('range') || 'thisMonth';
    const validation = reportQuerySchema.safeParse({ range: rangeParam });

    if (!validation.success) {
      return NextResponse.json(
        { success: false, error: 'Khoang thoi gian khong hop le' },
        { status: 400 }
      );
    }

    const { range } = validation.data;
    const dateRange = getDateRange(range);
    const compRange = getComparisonRange(range);

    // Parallel queries for current period
    const [bookingCount, revenueSum, costSum, activeRequests, leadCount] = await Promise.all([
      // Total bookings (requests with bookingCode)
      prisma.request.count({
        where: {
          bookingCode: { not: null },
          startDate: { gte: dateRange.startDate, lte: dateRange.endDate }
        }
      }),
      // Total revenue
      prisma.revenue.aggregate({
        where: {
          paymentDate: { gte: dateRange.startDate, lte: dateRange.endDate }
        },
        _sum: { amountVND: true }
      }),
      // Total cost (exclude archived)
      prisma.operator.aggregate({
        where: {
          isArchived: false,
          serviceDate: { gte: dateRange.startDate, lte: dateRange.endDate }
        },
        _sum: { totalCost: true }
      }),
      // Active requests (LEAD or QUOTE stage)
      prisma.request.count({
        where: {
          stage: { in: ['LEAD', 'QUOTE'] }
        }
      }),
      // Total leads for conversion rate
      prisma.request.count({
        where: {
          createdAt: { gte: dateRange.startDate, lte: dateRange.endDate }
        }
      })
    ]);

    // Comparison period queries
    const [prevBookings, prevRevenue] = await Promise.all([
      prisma.request.count({
        where: {
          bookingCode: { not: null },
          startDate: { gte: compRange.startDate, lte: compRange.endDate }
        }
      }),
      prisma.revenue.aggregate({
        where: {
          paymentDate: { gte: compRange.startDate, lte: compRange.endDate }
        },
        _sum: { amountVND: true }
      })
    ]);

    const totalRevenue = Number(revenueSum._sum.amountVND || 0);
    const totalCost = Number(costSum._sum.totalCost || 0);
    const prevRevenueVal = Number(prevRevenue._sum.amountVND || 0);
    const conversionRate = leadCount > 0
      ? Math.round((bookingCount / leadCount) * 10000) / 100
      : 0;

    const data: DashboardResponse = {
      kpiCards: {
        totalBookings: bookingCount,
        totalRevenue,
        totalProfit: totalRevenue - totalCost,
        activeRequests,
        conversionRate
      },
      comparison: {
        bookings: {
          current: bookingCount,
          previous: prevBookings,
          changePercent: calcChangePercent(bookingCount, prevBookings)
        },
        revenue: {
          current: totalRevenue,
          previous: prevRevenueVal,
          changePercent: calcChangePercent(totalRevenue, prevRevenueVal)
        }
      },
      dateRange
    };

    return NextResponse.json({ success: true, data });
  } catch (error) {
    console.error('Error generating dashboard:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Loi tao bao cao: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/reports/funnel/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { hasPermission, type Role } from '@/lib/permissions';
import { prisma } from '@/lib/db';
import { reportQuerySchema } from '@/lib/validations/report-validation';
import { getDateRange, type FunnelResponse } from '@/lib/report-utils';

// Stage order for funnel display
const STAGE_ORDER = ['LEAD', 'QUOTE', 'FOLLOWUP', 'OUTCOME'];

// GET /api/reports/funnel - Sales funnel analysis
export async function GET(request: NextRequest) {
  try {
    // Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chua dang nhap' },
        { status: 401 }
      );
    }

    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:view')) {
      return NextResponse.json(
        { success: false, error: 'Khong co quyen xem bao cao' },
        { status: 403 }
      );
    }

    // Parse query params
    const { searchParams } = new URL(request.url);
    const rangeParam = searchParams.get('range') || 'thisMonth';
    const validation = reportQuerySchema.safeParse({ range: rangeParam });

    if (!validation.success) {
      return NextResponse.json(
        { success: false, error: 'Khoang thoi gian khong hop le' },
        { status: 400 }
      );
    }

    const { range } = validation.data;
    const dateRange = getDateRange(range);

    // Count by stage using groupBy
    const stageCounts = await prisma.request.groupBy({
      by: ['stage'],
      where: {
        createdAt: { gte: dateRange.startDate, lte: dateRange.endDate }
      },
      _count: { id: true }
    });

    // Also count converted bookings (requests with bookingCode)
    const convertedCount = await prisma.request.count({
      where: {
        createdAt: { gte: dateRange.startDate, lte: dateRange.endDate },
        bookingCode: { not: null }
      }
    });

    // Build stage map
    const stageMap = new Map<string, number>();
    let totalRequests = 0;

    for (const item of stageCounts) {
      stageMap.set(item.stage, item._count.id);
      totalRequests += item._count.id;
    }

    // Format stages in order
    const stages = STAGE_ORDER.map(stage => ({
      stage,
      count: stageMap.get(stage) || 0,
      percentage: totalRequests > 0
        ? Math.round(((stageMap.get(stage) || 0) / totalRequests) * 10000) / 100
        : 0
    }));

    // Conversion rate: bookings / total requests
    const conversionRate = totalRequests > 0
      ? Math.round((convertedCount / totalRequests) * 10000) / 100
      : 0;

    const response: FunnelResponse = {
      stages,
      conversionRate,
      dateRange
    };

    return NextResponse.json({ success: true, data: response });
  } catch (error) {
    console.error('Error generating funnel report:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Loi tao bao cao pheu ban hang: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/reports/profit/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

// Date format validation regex (YYYY-MM-DD)
const DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;

// Booking code format regex (e.g., 20250308KIK)
const BOOKING_CODE_REGEX = /^\d{8}[A-Z]{3}$/;

// Max bookings to return (performance limit)
const MAX_BOOKINGS = 500;

// Validate date string format
function isValidDate(dateStr: string): boolean {
  if (!DATE_REGEX.test(dateStr)) return false;
  const date = new Date(dateStr);
  return !isNaN(date.getTime());
}

// Validate booking code format
function isValidBookingCode(code: string): boolean {
  return BOOKING_CODE_REGEX.test(code);
}

// GET /api/reports/profit
// Input: startDate, endDate, bookingCode (optional)
// Output: Array of profit per booking with summary
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const bookingCode = searchParams.get('bookingCode');

    // Validate date inputs
    if (startDate && !isValidDate(startDate)) {
      return NextResponse.json(
        { success: false, error: 'Ngày bắt đầu không hợp lệ (YYYY-MM-DD)' },
        { status: 400 }
      );
    }
    if (endDate && !isValidDate(endDate)) {
      return NextResponse.json(
        { success: false, error: 'Ngày kết thúc không hợp lệ (YYYY-MM-DD)' },
        { status: 400 }
      );
    }

    // Build where clause for requests (bookings)
    const requestWhere: Record<string, unknown> = {
      bookingCode: { not: null }, // Only bookings with code
    };

    if (startDate || endDate) {
      requestWhere.startDate = {};
      if (startDate) (requestWhere.startDate as Record<string, Date>).gte = new Date(startDate);
      if (endDate) (requestWhere.startDate as Record<string, Date>).lte = new Date(endDate);
    }

    if (bookingCode) {
      // Validate booking code format
      if (!isValidBookingCode(bookingCode)) {
        return NextResponse.json(
          { success: false, error: 'Mã booking không hợp lệ (yyyyMMddXXX)' },
          { status: 400 }
        );
      }
      requestWhere.bookingCode = bookingCode;
    }

    // Get requests with operators and revenues (limited for performance)
    const requests = await prisma.request.findMany({
      where: requestWhere,
      take: MAX_BOOKINGS,
      orderBy: { startDate: 'desc' },
      select: {
        id: true,
        bookingCode: true,
        customerName: true,
        operators: {
          select: {
            totalCost: true,
          },
        },
        revenues: {
          select: {
            amountVND: true,
          },
        },
      },
    });

    // Calculate profit per booking
    const bookings = requests
      .filter((req) => req.bookingCode) // Ensure bookingCode exists
      .map((req) => {
        const totalCost = req.operators.reduce(
          (sum, op) => sum + Number(op.totalCost),
          0
        );
        const totalRevenue = req.revenues.reduce(
          (sum, rev) => sum + Number(rev.amountVND),
          0
        );
        const profit = totalRevenue - totalCost;
        const profitMargin = totalRevenue > 0
          ? Math.round((profit / totalRevenue) * 10000) / 100 // 2 decimal places
          : 0;

        return {
          bookingCode: req.bookingCode!,
          customerName: req.customerName,
          totalCost,
          totalRevenue,
          profit,
          profitMargin,
        };
      })
      .sort((a, b) => b.profit - a.profit); // Sort by profit descending

    // Calculate summary
    const totalCost = bookings.reduce((sum, b) => sum + b.totalCost, 0);
    const totalRevenue = bookings.reduce((sum, b) => sum + b.totalRevenue, 0);
    const totalProfit = totalRevenue - totalCost;
    const avgProfitMargin = totalRevenue > 0
      ? Math.round((totalProfit / totalRevenue) * 10000) / 100
      : 0;

    const summary = {
      totalCost,
      totalRevenue,
      totalProfit,
      avgProfitMargin,
      bookingCount: bookings.length,
    };

    return NextResponse.json({
      success: true,
      data: {
        bookings,
        summary,
      },
    });
  } catch (error) {
    console.error('Error generating profit report:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo báo cáo lợi nhuận: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/reports/revenue-trend/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { hasPermission, type Role } from '@/lib/permissions';
import { prisma } from '@/lib/db';
import { reportQuerySchema } from '@/lib/validations/report-validation';
import {
  getDateRange,
  formatPeriodKey,
  type RevenueTrendResponse,
  type TrendDataPoint
} from '@/lib/report-utils';

// GET /api/reports/revenue-trend - Revenue over time
export async function GET(request: NextRequest) {
  try {
    // Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chua dang nhap' },
        { status: 401 }
      );
    }

    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:view')) {
      return NextResponse.json(
        { success: false, error: 'Khong co quyen xem bao cao' },
        { status: 403 }
      );
    }

    // Parse query params
    const { searchParams } = new URL(request.url);
    const rangeParam = searchParams.get('range') || 'thisMonth';
    const validation = reportQuerySchema.safeParse({ range: rangeParam });

    if (!validation.success) {
      return NextResponse.json(
        { success: false, error: 'Khoang thoi gian khong hop le' },
        { status: 400 }
      );
    }

    const { range } = validation.data;
    const dateRange = getDateRange(range);

    // Fetch revenues and costs
    const [revenues, costs] = await Promise.all([
      prisma.revenue.findMany({
        where: {
          paymentDate: { gte: dateRange.startDate, lte: dateRange.endDate }
        },
        select: { paymentDate: true, amountVND: true }
      }),
      prisma.operator.findMany({
        where: {
          isArchived: false,
          serviceDate: { gte: dateRange.startDate, lte: dateRange.endDate }
        },
        select: { serviceDate: true, totalCost: true }
      })
    ]);

    // Group by month
    const revenueByMonth = new Map<string, number>();
    const costByMonth = new Map<string, number>();

    for (const rev of revenues) {
      const key = formatPeriodKey(rev.paymentDate);
      revenueByMonth.set(key, (revenueByMonth.get(key) || 0) + Number(rev.amountVND));
    }

    for (const op of costs) {
      const key = formatPeriodKey(op.serviceDate);
      costByMonth.set(key, (costByMonth.get(key) || 0) + Number(op.totalCost));
    }

    // Merge periods and sort
    const periods = new Set([...revenueByMonth.keys(), ...costByMonth.keys()]);
    const data: TrendDataPoint[] = Array.from(periods)
      .sort()
      .map(period => {
        const revenue = revenueByMonth.get(period) || 0;
        const cost = costByMonth.get(period) || 0;
        return {
          period,
          revenue,
          cost,
          profit: revenue - cost
        };
      });

    // Calculate summary
    const totalRevenue = data.reduce((sum, d) => sum + d.revenue, 0);
    const totalCost = data.reduce((sum, d) => sum + d.cost, 0);

    const response: RevenueTrendResponse = {
      data,
      summary: {
        totalRevenue,
        totalCost,
        totalProfit: totalRevenue - totalCost,
        avgMonthly: data.length > 0 ? Math.round(totalRevenue / data.length) : 0
      },
      dateRange
    };

    return NextResponse.json({ success: true, data: response });
  } catch (error) {
    console.error('Error generating revenue trend:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Loi tao bao cao xu huong: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/revenues/[id]/history/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { hasPermission, type Role } from '@/lib/permissions';
import { getRevenueHistory } from '@/lib/revenue-history';
import { prisma } from '@/lib/db';

// GET /api/revenues/[id]/history - Get revenue history with user names
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chưa đăng nhập' },
        { status: 401 }
      );
    }

    // Permission check
    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:view')) {
      return NextResponse.json(
        { success: false, error: 'Không có quyền xem lịch sử' },
        { status: 403 }
      );
    }

    const { id } = await params;

    // Verify revenue exists
    const revenue = await prisma.revenue.findUnique({
      where: { id },
      select: { id: true },
    });

    if (!revenue) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy thu nhập' },
        { status: 404 }
      );
    }

    // Get history with user names
    const history = await getRevenueHistory(id);

    return NextResponse.json({
      success: true,
      data: history,
    });
  } catch (error) {
    console.error('Error fetching revenue history:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải lịch sử: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/revenues/sales/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { auth } from '@/auth';
import { hasPermission, type Role } from '@/lib/permissions';

// Max bookings to return (performance limit)
const MAX_BOOKINGS = 500;

// Regex patterns for input validation
const MONTH_REGEX = /^\d{4}-(0[1-9]|1[0-2])$/; // YYYY-MM format
const YEAR_REGEX = /^(20[0-9]{2})$/; // Years 2000-2099

// GET /api/revenues/sales - Aggregate Revenue by bookingCode
// Query params: month (YYYY-MM), year (YYYY)
export async function GET(request: NextRequest) {
  try {
    // Verify authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chua dang nhap' },
        { status: 401 }
      );
    }

    // Verify permission
    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:view')) {
      return NextResponse.json(
        { success: false, error: 'Khong co quyen xem doanh thu' },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const month = searchParams.get('month'); // YYYY-MM format
    const year = searchParams.get('year');   // YYYY format

    // Validate month format if provided
    if (month && !MONTH_REGEX.test(month)) {
      return NextResponse.json(
        { success: false, error: 'Thang khong hop le (YYYY-MM)' },
        { status: 400 }
      );
    }

    // Validate year format if provided
    if (year && !YEAR_REGEX.test(year)) {
      return NextResponse.json(
        { success: false, error: 'Nam khong hop le (2000-2099)' },
        { status: 400 }
      );
    }

    // Build date filter for requests
    const requestWhere: Record<string, unknown> = {
      bookingCode: { not: null },
    };

    // Apply date filters based on startDate
    if (month) {
      // Parse YYYY-MM to get date range
      const [yearPart, monthPart] = month.split('-').map(Number);
      const startOfMonth = new Date(yearPart, monthPart - 1, 1);
      const endOfMonth = new Date(yearPart, monthPart, 0, 23, 59, 59, 999);
      requestWhere.startDate = {
        gte: startOfMonth,
        lte: endOfMonth,
      };
    } else if (year) {
      // Filter by year only
      const yearNum = parseInt(year);
      const startOfYear = new Date(yearNum, 0, 1);
      const endOfYear = new Date(yearNum, 11, 31, 23, 59, 59, 999);
      requestWhere.startDate = {
        gte: startOfYear,
        lte: endOfYear,
      };
    }

    // Get requests with aggregated revenues and operators
    const requests = await prisma.request.findMany({
      where: requestWhere,
      take: MAX_BOOKINGS,
      orderBy: { startDate: 'desc' },
      select: {
        id: true,
        bookingCode: true,
        customerName: true,
        startDate: true,
        endDate: true,
        operators: {
          select: {
            totalCost: true,
          },
        },
        revenues: {
          select: {
            amountVND: true,
          },
        },
      },
    });

    // Calculate aggregated sales per booking
    const sales = requests
      .filter((req) => req.bookingCode) // Ensure bookingCode exists
      .map((req) => {
        const totalCost = req.operators.reduce(
          (sum, op) => sum + Number(op.totalCost),
          0
        );
        const totalRevenue = req.revenues.reduce(
          (sum, rev) => sum + Number(rev.amountVND),
          0
        );
        const profit = totalRevenue - totalCost;
        const revenueCount = req.revenues.length;

        return {
          bookingCode: req.bookingCode!,
          customerName: req.customerName,
          totalRevenue,
          totalCost,
          profit,
          revenueCount,
          startDate: req.startDate,
          endDate: req.endDate,
        };
      })
      .sort((a, b) => b.totalRevenue - a.totalRevenue); // Sort by revenue descending

    // Calculate summary statistics
    const totalRevenue = sales.reduce((sum, s) => sum + s.totalRevenue, 0);
    const totalCost = sales.reduce((sum, s) => sum + s.totalCost, 0);
    const totalProfit = totalRevenue - totalCost;

    const summary = {
      totalRevenue,
      totalCost,
      totalProfit,
      bookingCount: sales.length,
    };

    return NextResponse.json({
      success: true,
      data: {
        sales,
        summary,
      },
      hasMore: requests.length >= MAX_BOOKINGS,
    });
  } catch (error) {
    console.error('Error generating sales report:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Loi tao bao cao tong hop: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/supplier-transactions/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { getSessionUser, unauthorizedResponse } from '@/lib/auth-utils';

// GET /api/supplier-transactions - List transactions with filters
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const supplierId = searchParams.get('supplierId') || '';
    const type = searchParams.get('type') || '';
    const fromDate = searchParams.get('fromDate') || '';
    const toDate = searchParams.get('toDate') || '';
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Build where clause
    const where: Record<string, unknown> = {};

    if (supplierId) where.supplierId = supplierId;
    if (type) where.type = type;

    if (fromDate || toDate) {
      where.transactionDate = {};
      if (fromDate) (where.transactionDate as Record<string, Date>).gte = new Date(fromDate);
      if (toDate) (where.transactionDate as Record<string, Date>).lte = new Date(toDate);
    }

    const [transactions, total] = await Promise.all([
      prisma.supplierTransaction.findMany({
        where,
        include: {
          supplier: {
            select: { code: true, name: true },
          },
        },
        orderBy: { transactionDate: 'desc' },
        take: limit,
        skip: offset,
      }),
      prisma.supplierTransaction.count({ where }),
    ]);

    return NextResponse.json({
      success: true,
      data: transactions,
      total,
      hasMore: offset + transactions.length < total,
    });
  } catch (error) {
    console.error('Error fetching transactions:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch transactions' },
      { status: 500 }
    );
  }
}

// POST /api/supplier-transactions - Create new transaction
export async function POST(request: NextRequest) {
  try {
    // Verify authentication
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const body = await request.json();

    // Validate required fields
    if (!body.supplierId || !body.type || !body.amount || !body.transactionDate) {
      return NextResponse.json(
        { success: false, error: 'Missing required fields: supplierId, type, amount, transactionDate' },
        { status: 400 }
      );
    }

    // Validate amount is positive
    if (body.amount <= 0) {
      return NextResponse.json(
        { success: false, error: 'Amount must be positive' },
        { status: 400 }
      );
    }

    // Validate type
    const validTypes = ['DEPOSIT', 'REFUND', 'ADJUSTMENT', 'FEE'];
    if (!validTypes.includes(body.type)) {
      return NextResponse.json(
        { success: false, error: `Invalid type. Must be one of: ${validTypes.join(', ')}` },
        { status: 400 }
      );
    }

    // Check supplier exists
    const supplier = await prisma.supplier.findUnique({
      where: { id: body.supplierId },
    });

    if (!supplier) {
      return NextResponse.json(
        { success: false, error: 'Supplier not found' },
        { status: 404 }
      );
    }

    // Create transaction
    const transaction = await prisma.supplierTransaction.create({
      data: {
        supplierId: body.supplierId,
        type: body.type,
        amount: Number(body.amount),
        transactionDate: new Date(body.transactionDate),
        description: body.description || null,
        proofLink: body.proofLink || null,
        relatedBookingCode: body.relatedBookingCode || null,
        createdBy: user.id,
      },
      include: {
        supplier: {
          select: { code: true, name: true },
        },
      },
    });

    return NextResponse.json({ success: true, data: transaction }, { status: 201 });
  } catch (error) {
    console.error('Error creating transaction:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to create transaction' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/users/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';

// GET /api/users - List users with optional role filter
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const role = searchParams.get('role');

    // Build where clause
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const where: Record<string, any> = {};
    if (role) {
      where.role = role;
    }

    const users = await prisma.user.findMany({
      where,
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
      },
      orderBy: { name: 'asc' },
    });

    return NextResponse.json({
      success: true,
      data: users,
    });
  } catch (error) {
    console.error('Error fetching users:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải danh sách người dùng: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/forbidden/page.tsx">
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { ShieldX } from "lucide-react";

export default function ForbiddenPage() {
  return (
    <div className="flex min-h-screen flex-col items-center justify-center">
      <ShieldX className="h-16 w-16 text-red-500 mb-4" />
      <h1 className="text-2xl font-bold mb-2">Truy cập bị từ chối</h1>
      <p className="text-muted-foreground mb-6">
        Bạn không có quyền truy cập trang này.
      </p>
      <Button asChild>
        <Link href="/">Quay về Trang chủ</Link>
      </Button>
    </div>
  );
}
</file>

<file path="src/app/login/__tests__/login-validation.test.ts">
import { z } from "zod";

// Replicate the schema from login-form.tsx for testing
const loginSchema = z.object({
  email: z.string().email("Email khong hop le"),
  password: z.string().min(1, "Mat khau bat buoc"),
});

type LoginFormData = z.infer<typeof loginSchema>;

describe("Login Form Validation Schema", () => {
  describe("Email Validation", () => {
    it("accepts valid email addresses", () => {
      const validEmails = [
        "user@example.com",
        "test.user@example.co.uk",
        "admin+tag@domain.com",
      ];

      validEmails.forEach((email) => {
        const result = loginSchema.safeParse({
          email,
          password: "password123",
        });
        expect(result.success).toBe(true);
      });
    });

    it("rejects invalid email format", () => {
      const invalidEmails = [
        "not-an-email",
        "user@",
        "@example.com",
        "user@.com",
        "user name@example.com",
      ];

      invalidEmails.forEach((email) => {
        const result = loginSchema.safeParse({
          email,
          password: "password123",
        });
        expect(result.success).toBe(false);
        if (!result.success) {
          expect(result.error.issues[0].message).toBe("Email khong hop le");
        }
      });
    });

    it("rejects empty email", () => {
      const result = loginSchema.safeParse({
        email: "",
        password: "password123",
      });
      expect(result.success).toBe(false);
    });

    it("rejects missing email field", () => {
      const result = loginSchema.safeParse({
        password: "password123",
      });
      expect(result.success).toBe(false);
    });
  });

  describe("Password Validation", () => {
    it("accepts non-empty password", () => {
      const validPasswords = ["a", "password", "P@ssw0rd!", "123"];

      validPasswords.forEach((password) => {
        const result = loginSchema.safeParse({
          email: "test@example.com",
          password,
        });
        expect(result.success).toBe(true);
      });
    });

    it("rejects empty password", () => {
      const result = loginSchema.safeParse({
        email: "test@example.com",
        password: "",
      });
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues[0].message).toBe("Mat khau bat buoc");
      }
    });

    it("rejects missing password field", () => {
      const result = loginSchema.safeParse({
        email: "test@example.com",
      });
      expect(result.success).toBe(false);
    });
  });

  describe("Combined Validation", () => {
    it("accepts valid credentials", () => {
      const result = loginSchema.safeParse({
        email: "user@example.com",
        password: "securepassword123",
      });
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.email).toBe("user@example.com");
        expect(result.data.password).toBe("securepassword123");
      }
    });

    it("rejects both invalid email and empty password", () => {
      const result = loginSchema.safeParse({
        email: "invalid-email",
        password: "",
      });
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.issues.length).toBeGreaterThan(0);
      }
    });

    it("rejects extra fields in data", () => {
      const result = loginSchema.safeParse({
        email: "user@example.com",
        password: "password123",
        extraField: "should be removed",
      });
      // Zod strips extra fields by default
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data).not.toHaveProperty("extraField");
      }
    });

    it("maintains type safety of parsed data", () => {
      const result = loginSchema.safeParse({
        email: "test@example.com",
        password: "password",
      });
      expect(result.success).toBe(true);
      if (result.success) {
        const data: LoginFormData = result.data;
        expect(typeof data.email).toBe("string");
        expect(typeof data.password).toBe("string");
      }
    });
  });

  describe("Edge Cases", () => {
    it("handles very long email", () => {
      const longEmail = "a".repeat(250) + "@example.com";
      const result = loginSchema.safeParse({
        email: longEmail,
        password: "password123",
      });
      // Should accept (validation doesn't have length limit)
      expect(result.success).toBe(true);
    });

    it("handles very long password", () => {
      const longPassword = "a".repeat(1000);
      const result = loginSchema.safeParse({
        email: "test@example.com",
        password: longPassword,
      });
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.password).toBe(longPassword);
      }
    });

    it("handles unicode characters in password", () => {
      const result = loginSchema.safeParse({
        email: "test@example.com",
        password: "パスワード123",
      });
      expect(result.success).toBe(true);
    });

    it("handles whitespace in email (should fail)", () => {
      const result = loginSchema.safeParse({
        email: "user @example.com",
        password: "password123",
      });
      expect(result.success).toBe(false);
    });

    it("trims whitespace from inputs", () => {
      // Note: Zod doesn't trim by default, but string().email() normalizes
      const result = loginSchema.safeParse({
        email: "test@example.com",
        password: "  password  ", // Leading/trailing spaces
      });
      expect(result.success).toBe(true);
      if (result.success) {
        // Password is preserved as-is
        expect(result.data.password).toBe("  password  ");
      }
    });
  });
});
</file>

<file path="src/app/login/__tests__/page.test.tsx">
import { render, screen } from "@testing-library/react";
import LoginPage from "../page";
import { LoginForm } from "../login-form";

// Mock LoginForm component
jest.mock("../login-form", () => ({
  LoginForm: jest.fn(() => <div data-testid="login-form-mock">Login Form</div>),
}));

const mockLoginForm = LoginForm as jest.MockedFunction<typeof LoginForm>;

describe("LoginPage", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("Rendering", () => {
    it("renders login page without errors", () => {
      render(<LoginPage />);
      expect(screen.getByText(/MyVivaTour/i)).toBeInTheDocument();
    });

    it("displays page title", () => {
      render(<LoginPage />);
      const title = screen.getByText(/MyVivaTour/i);
      expect(title).toBeInTheDocument();
      expect(title.className).toContain("text-2xl");
      expect(title.className).toContain("font-bold");
    });

    it("displays subtitle", () => {
      render(<LoginPage />);
      expect(screen.getByText(/Dang nhap de tiep tuc/i)).toBeInTheDocument();
    });

    it("renders LoginForm component", () => {
      render(<LoginPage />);
      expect(mockLoginForm).toHaveBeenCalled();
      expect(screen.getByTestId("login-form-mock")).toBeInTheDocument();
    });

    it("applies correct styling classes", () => {
      const { container } = render(<LoginPage />);
      const outerDiv = container.querySelector(".flex");
      expect(outerDiv).toBeInTheDocument();
      expect(outerDiv).toHaveClass("min-h-screen");
      expect(outerDiv).toHaveClass("items-center");
      expect(outerDiv).toHaveClass("justify-center");
      expect(outerDiv).toHaveClass("bg-gray-50");
    });

    it("renders form container with max-width", () => {
      const { container } = render(<LoginPage />);
      const formContainer = container.querySelector(".max-w-sm");
      expect(formContainer).toBeInTheDocument();
      expect(formContainer).toHaveClass("w-full");
    });
  });

  describe("Layout Structure", () => {
    it("renders header section before form", () => {
      const { container } = render(<LoginPage />);
      const headerDiv = container.querySelector(".mb-8");
      expect(headerDiv).toBeInTheDocument();
      expect(headerDiv?.textContent).toContain("MyVivaTour");
      expect(headerDiv?.textContent).toContain("Dang nhap de tiep tuc");
    });

    it("centers header text", () => {
      const { container } = render(<LoginPage />);
      const headerDiv = container.querySelector(".text-center");
      expect(headerDiv).toBeInTheDocument();
    });

    it("renders text-based UI elements in correct order", () => {
      const { container } = render(<LoginPage />);
      const textElements = container.querySelectorAll(".text-center *");
      const h1 = Array.from(textElements).find((el) =>
        el.classList.contains("text-2xl")
      );
      const subtitle = Array.from(textElements).find(
        (el) =>
          el.textContent === "Dang nhap de tiep tuc" ||
          el.textContent?.includes("Dang nhap de tiep tuc")
      );
      expect(h1).toBeInTheDocument();
      expect(subtitle).toBeInTheDocument();
    });
  });

  describe("Responsive Design", () => {
    it("applies responsive padding", () => {
      const { container } = render(<LoginPage />);
      const outerDiv = container.querySelector(".px-4");
      expect(outerDiv).toBeInTheDocument();
    });

    it("limits form width on larger screens", () => {
      const { container } = render(<LoginPage />);
      const formContainer = container.querySelector(".max-w-sm");
      expect(formContainer).toBeInTheDocument();
    });
  });

  describe("Integration with LoginForm", () => {
    it("passes no props to LoginForm", () => {
      render(<LoginPage />);
      expect(mockLoginForm).toHaveBeenCalled();
      expect(mockLoginForm).toHaveBeenCalledTimes(1);
    });

    it("mounts LoginForm as a child component", () => {
      render(<LoginPage />);
      const mockComponent = screen.getByTestId("login-form-mock");
      expect(mockComponent).toBeInTheDocument();
      expect(mockComponent.textContent).toContain("Login Form");
    });
  });

  describe("Accessibility", () => {
    it("maintains semantic HTML structure", () => {
      const { container } = render(<LoginPage />);
      // Page should have proper structure with header and form container
      // Note: LoginForm is mocked, so we check for the mock element
      const formMock = screen.getByTestId("login-form-mock");
      expect(formMock).toBeInTheDocument();
      // Verify proper container hierarchy
      const wrapper = container.querySelector(".w-full.max-w-sm");
      expect(wrapper).toBeInTheDocument();
    });

    it("uses proper heading hierarchy", () => {
      render(<LoginPage />);
      const heading = screen.getByText(/MyVivaTour/i);
      // The heading should be in a proper heading tag
      expect(heading).toBeInTheDocument();
      expect(heading.tagName).toBe("H1");
    });
  });
});
</file>

<file path="src/app/login/login-form.tsx">
"use client";

import { useState, Suspense } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { signIn } from "next-auth/react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";

import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

const loginSchema = z.object({
  email: z.string().email("Email khong hop le"),
  password: z.string().min(1, "Mat khau bat buoc"),
});

type LoginFormData = z.infer<typeof loginSchema>;

// Prevent open redirect attacks - only allow relative paths
function getSafeCallbackUrl(url: string | null): string {
  const defaultUrl = "/requests";
  if (!url) return defaultUrl;
  // Must start with single / and not // (protocol-relative)
  if (!url.startsWith("/") || url.startsWith("//")) return defaultUrl;
  return url;
}

function LoginFormContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const callbackUrl = getSafeCallbackUrl(searchParams.get("callbackUrl"));
  const [isLoading, setIsLoading] = useState(false);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  async function onSubmit(data: LoginFormData) {
    setIsLoading(true);

    try {
      const result = await signIn("credentials", {
        email: data.email,
        password: data.password,
        redirect: false,
      });

      if (result?.error) {
        toast.error("Dang nhap that bai", {
          description: "Email hoac mat khau khong dung",
        });
        return;
      }

      toast.success("Dang nhap thanh cong");
      router.push(callbackUrl);
      router.refresh();
    } catch (error) {
      console.error("Login error:", error);
      toast.error("Loi he thong", {
        description: "Vui long thu lai sau",
      });
    } finally {
      setIsLoading(false);
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="email">Email</Label>
        <Input
          id="email"
          type="email"
          placeholder="email@example.com"
          autoComplete="email"
          disabled={isLoading}
          {...register("email")}
        />
        {errors.email && (
          <p className="text-sm text-red-500">{errors.email.message}</p>
        )}
      </div>

      <div className="space-y-2">
        <Label htmlFor="password">Mat khau</Label>
        <Input
          id="password"
          type="password"
          placeholder="••••••••"
          autoComplete="current-password"
          disabled={isLoading}
          {...register("password")}
        />
        {errors.password && (
          <p className="text-sm text-red-500">{errors.password.message}</p>
        )}
      </div>

      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Dang xu ly...
          </>
        ) : (
          "Dang nhap"
        )}
      </Button>
    </form>
  );
}

export function LoginForm() {
  return (
    <Suspense
      fallback={
        <div className="flex items-center justify-center py-8">
          <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
        </div>
      }
    >
      <LoginFormContent />
    </Suspense>
  );
}
</file>

<file path="src/app/login/page.tsx">
import { LoginForm } from "./login-form";

export default function LoginPage() {
  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 px-4">
      <div className="w-full max-w-sm">
        <div className="mb-8 text-center">
          <h1 className="text-2xl font-bold text-gray-900">MyVivaTour</h1>
          <p className="mt-2 text-sm text-muted-foreground">
            Dang nhap de tiep tuc
          </p>
        </div>
        <LoginForm />
      </div>
    </div>
  );
}
</file>

<file path="src/auth.config.ts">
/**
 * Edge-compatible NextAuth configuration
 *
 * This file contains auth config that works in edge runtime (middleware).
 * It excludes database access and bcrypt which require Node.js crypto.
 *
 * Used by: middleware.ts (edge runtime)
 * Extended by: auth.ts (Node.js runtime with full authorize logic)
 */
import type { NextAuthConfig } from "next-auth";
import Credentials from "next-auth/providers/credentials";

type RoleType = "ADMIN" | "SELLER" | "ACCOUNTANT" | "OPERATOR";

// Extend types for role
declare module "next-auth" {
  interface User {
    role: RoleType;
  }
  interface Session {
    user: {
      id: string;
      email: string;
      name?: string | null;
      role: RoleType;
    };
  }
}

declare module "@auth/core/jwt" {
  interface JWT {
    id: string;
    role: RoleType;
  }
}

/**
 * Base auth config - edge compatible (no DB/bcrypt)
 * The authorize function is intentionally omitted here.
 * It will be added in auth.ts which runs in Node.js runtime.
 */
export const authConfig: NextAuthConfig = {
  providers: [
    // Credentials provider placeholder - authorize added in auth.ts
    Credentials({
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      // authorize is intentionally not defined here for edge compatibility
      // It will be overridden in auth.ts
      authorize: () => null,
    }),
  ],
  session: {
    strategy: "jwt",
    maxAge: 24 * 60 * 60, // 24 hours
  },
  pages: {
    signIn: "/login",
    error: "/login",
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.id = user.id as string;
        token.role = user.role;
      }
      return token;
    },
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id as string;
        session.user.role = token.role as RoleType;
      }
      return session;
    },
    // Authorization callback for middleware route protection
    authorized({ auth, request: { nextUrl } }) {
      const isLoggedIn = !!auth?.user;
      const pathname = nextUrl.pathname;

      // Public routes
      const publicRoutes = ["/login", "/api/auth", "/forbidden"];
      const isPublicRoute = publicRoutes.some((route) =>
        pathname.startsWith(route)
      );

      if (isPublicRoute) return true;

      // Require authentication for all other routes
      if (!isLoggedIn) return false;

      // Role-based route access
      const roleRoutes: Record<string, string[]> = {
        "/requests": ["ADMIN", "SELLER", "OPERATOR", "ACCOUNTANT"],
        "/operators": ["ADMIN", "OPERATOR", "ACCOUNTANT"],
        "/revenues": ["ADMIN", "ACCOUNTANT"],
        "/suppliers": ["ADMIN", "ACCOUNTANT"],
        "/settings": ["ADMIN"],
      };

      const userRole = auth?.user?.role;

      // Check role-based access
      for (const [route, allowedRoles] of Object.entries(roleRoutes)) {
        if (pathname.startsWith(route)) {
          if (userRole === "ADMIN") return true;
          if (!allowedRoles.includes(userRole as string)) {
            return Response.redirect(new URL("/forbidden", nextUrl));
          }
        }
      }

      return true;
    },
  },
};
</file>

<file path="src/components/layouts/index.ts">
/**
 * Layout Components Barrel Export
 *
 * Reusable layout patterns for the application.
 */

export { MasterDetailLayout } from "./master-detail-layout";
export { SlideInPanel } from "./slide-in-panel";
</file>

<file path="src/components/layouts/master-detail-layout.tsx">
"use client";

/**
 * MasterDetailLayout Component
 *
 * Responsive layout with:
 * - Desktop (md+): Resizable 40-60 split panels
 * - Mobile (<md): Full list with Sheet overlay for detail
 *
 * Panel sizes persist to localStorage via autoSaveId.
 *
 * @example
 * <MasterDetailLayout
 *   storageKey="requests-layout"
 *   selectedId={selectedId}
 *   onClose={() => setSelectedId(null)}
 *   detailTitle="Chi tiết"
 *   master={<RequestList onSelect={setSelectedId} />}
 *   detail={selectedId && <RequestDetail id={selectedId} />}
 * />
 */

import { Group, Panel, Separator } from "react-resizable-panels";
import { cn } from "@/lib/utils";
import { SlideInPanel } from "./slide-in-panel";

interface MasterDetailLayoutProps {
  /** Content for the master (list) panel */
  master: React.ReactNode;
  /** Content for the detail panel */
  detail: React.ReactNode;
  /** Currently selected item ID (controls mobile sheet) */
  selectedId?: string | null;
  /** Callback when mobile sheet closes */
  onClose?: () => void;
  /** LocalStorage key for persisting panel sizes */
  storageKey?: string;
  /** Title for mobile sheet header */
  detailTitle?: string;
  /** Description for mobile sheet header */
  detailDescription?: string;
  /** Custom class for container */
  className?: string;
  /** Placeholder text when no selection (Vietnamese) */
  emptyText?: string;
}

export function MasterDetailLayout({
  master,
  detail,
  selectedId,
  onClose,
  storageKey = "master-detail-layout",
  detailTitle,
  detailDescription,
  className,
  emptyText = "Chọn một mục để xem chi tiết",
}: MasterDetailLayoutProps) {
  const hasSelection = selectedId !== null && selectedId !== undefined;

  return (
    <div className={cn("h-full", className)}>
      {/* Desktop: Resizable panels */}
      <div className="hidden md:block h-full">
        <Group orientation="horizontal" id={storageKey}>
          <Panel
            id="master"
            defaultSize={40}
            minSize={25}
            maxSize={60}
            className="overflow-auto"
          >
            {master}
          </Panel>
          <Separator
            aria-label="Resize panels"
            className="w-1.5 bg-border hover:bg-primary/20 active:bg-primary/40 transition-colors"
          />
          <Panel
            id="detail"
            defaultSize={60}
            minSize={40}
            className="overflow-auto"
          >
            {hasSelection ? (
              detail
            ) : (
              <div className="flex items-center justify-center h-full text-muted-foreground">
                {emptyText}
              </div>
            )}
          </Panel>
        </Group>
      </div>

      {/* Mobile: Full list + Sheet overlay */}
      <div className="md:hidden h-full">
        <div className="h-full overflow-auto">{master}</div>
        <SlideInPanel
          isOpen={hasSelection}
          onClose={onClose || (() => {})}
          title={detailTitle}
          description={detailDescription}
        >
          {detail}
        </SlideInPanel>
      </div>
    </div>
  );
}
</file>

<file path="src/components/layouts/slide-in-panel.tsx">
"use client";

/**
 * SlideInPanel Component
 *
 * Wrapper around shadcn Sheet for mobile detail views.
 * Slides in from right side with responsive widths.
 *
 * @example
 * <SlideInPanel
 *   isOpen={!!selectedId}
 *   onClose={() => setSelectedId(null)}
 *   title="Chi tiết"
 * >
 *   <DetailContent />
 * </SlideInPanel>
 */

import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetDescription,
} from "@/components/ui/sheet";

interface SlideInPanelProps {
  /** Whether the panel is open */
  isOpen: boolean;
  /** Callback when panel closes */
  onClose: () => void;
  /** Panel header title */
  title?: string;
  /** Panel header description */
  description?: string;
  /** Panel content */
  children: React.ReactNode;
}

export function SlideInPanel({
  isOpen,
  onClose,
  title,
  description,
  children,
}: SlideInPanelProps) {
  return (
    <Sheet open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <SheetContent
        side="right"
        className="w-[85vw] sm:w-[540px] md:w-[600px] p-0 flex flex-col"
      >
        {(title || description) && (
          <SheetHeader className="px-4 pt-4 pb-2 border-b">
            {title && <SheetTitle>{title}</SheetTitle>}
            {description && <SheetDescription>{description}</SheetDescription>}
          </SheetHeader>
        )}
        <div className="flex-1 overflow-auto p-4">{children}</div>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="src/components/operators/index.ts">
// Operator Components Exports
export * from './operator-lock-tier-badge';
export * from './operator-lock-dialog';
export * from './operator-history-panel';
export * from './operator-form';
export * from './operator-approval-table';
export * from './operator-list-filters';
export * from './lock-indicator';
export * from './approval-summary-cards';
</file>

<file path="src/components/operators/operator-list-filters.tsx">
'use client';

import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { Search, X, Archive } from 'lucide-react';
import { SERVICE_TYPES, SERVICE_TYPE_KEYS, PAYMENT_STATUSES, PAYMENT_STATUS_KEYS } from '@/config/operator-config';
import type { OperatorFilters } from '@/types';

interface OperatorListFiltersProps {
  filters: OperatorFilters;
  onFilterChange: (filters: OperatorFilters) => void;
}

export function OperatorListFilters({ filters, onFilterChange }: OperatorListFiltersProps) {
  const updateFilter = <K extends keyof OperatorFilters>(key: K, value: OperatorFilters[K]) => {
    onFilterChange({ ...filters, [key]: value });
  };

  const clearFilters = () => {
    onFilterChange({
      search: '',
      serviceType: '',
      paymentStatus: '',
      fromDate: '',
      toDate: '',
      isLocked: undefined,
      includeArchived: false,
    });
  };

  const hasFilters =
    filters.search ||
    filters.serviceType ||
    filters.paymentStatus ||
    filters.fromDate ||
    filters.toDate ||
    filters.isLocked !== undefined ||
    filters.includeArchived;

  return (
    <div className="space-y-4">
      {/* Row 1: Search + Service Type + Payment Status */}
      <div className="flex gap-4">
        <div className="flex-1 relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Tìm theo tên dịch vụ, NCC, mã Booking..."
            value={filters.search || ''}
            onChange={(e) => updateFilter('search', e.target.value)}
            className="pl-10"
          />
        </div>
        <Select
          value={filters.serviceType || 'all'}
          onValueChange={(v) => updateFilter('serviceType', v === 'all' ? '' : v)}
        >
          <SelectTrigger className="w-48">
            <SelectValue placeholder="Loại dịch vụ" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Tất cả loại DV</SelectItem>
            {SERVICE_TYPE_KEYS.map((key) => (
              <SelectItem key={key} value={key}>
                {SERVICE_TYPES[key].label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
        <Select
          value={filters.paymentStatus || 'all'}
          onValueChange={(v) => updateFilter('paymentStatus', v === 'all' ? '' : v)}
        >
          <SelectTrigger className="w-48">
            <SelectValue placeholder="Trạng thái TT" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Tất cả TT</SelectItem>
            {PAYMENT_STATUS_KEYS.map((key) => (
              <SelectItem key={key} value={key}>
                {PAYMENT_STATUSES[key].label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Row 2: Date Range + Lock Status + Clear */}
      <div className="flex gap-4 items-center">
        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground whitespace-nowrap">Từ ngày:</span>
          <Input
            type="date"
            value={filters.fromDate || ''}
            onChange={(e) => updateFilter('fromDate', e.target.value)}
            className="w-40"
          />
        </div>
        <div className="flex items-center gap-2">
          <span className="text-sm text-muted-foreground whitespace-nowrap">Đến ngày:</span>
          <Input
            type="date"
            value={filters.toDate || ''}
            onChange={(e) => updateFilter('toDate', e.target.value)}
            className="w-40"
          />
        </div>
        <Select
          value={filters.isLocked === undefined ? 'all' : filters.isLocked ? 'locked' : 'unlocked'}
          onValueChange={(v) => {
            if (v === 'all') updateFilter('isLocked', undefined);
            else if (v === 'locked') updateFilter('isLocked', true);
            else updateFilter('isLocked', false);
          }}
        >
          <SelectTrigger className="w-40">
            <SelectValue placeholder="Trạng thái khóa" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Tất cả</SelectItem>
            <SelectItem value="locked">Đã khóa</SelectItem>
            <SelectItem value="unlocked">Chưa khóa</SelectItem>
          </SelectContent>
        </Select>
        <div className="flex items-center gap-2">
          <Checkbox
            id="includeArchived"
            checked={filters.includeArchived || false}
            onCheckedChange={(checked: boolean) => updateFilter('includeArchived', checked)}
          />
          <Label htmlFor="includeArchived" className="text-sm flex items-center gap-1 cursor-pointer">
            <Archive className="h-4 w-4" />
            Hiện đã lưu trữ
          </Label>
        </div>
        {hasFilters && (
          <Button variant="ghost" size="sm" onClick={clearFilters}>
            <X className="h-4 w-4 mr-1" />
            Xóa bộ lọc
          </Button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/operators/operator-lock-tier-badge.tsx">
'use client';

import { Badge } from '@/components/ui/badge';
import { Lock, LockOpen } from 'lucide-react';
import { LOCK_TIER_LABELS, LOCK_TIER_COLORS } from '@/config/lock-config';
import type { LockTier } from '@/lib/lock-utils';

interface LockTierBadgeProps {
  lockKT: boolean;
  lockKTAt?: Date | string | null;
  lockKTBy?: string | null;
  lockAdmin: boolean;
  lockAdminAt?: Date | string | null;
  lockAdminBy?: string | null;
  lockFinal: boolean;
  lockFinalAt?: Date | string | null;
  lockFinalBy?: string | null;
  showAll?: boolean; // Show all tiers or just active ones
}

interface TierInfo {
  tier: LockTier;
  locked: boolean;
  at?: Date | string | null;
  by?: string | null;
}

/**
 * Full lock tier badge showing all 3 lock tiers
 */
export function LockTierBadge({
  lockKT,
  lockKTAt,
  lockKTBy,
  lockAdmin,
  lockAdminAt,
  lockAdminBy,
  lockFinal,
  lockFinalAt,
  lockFinalBy,
  showAll = false,
}: LockTierBadgeProps) {
  const tiers: TierInfo[] = [
    { tier: 'KT', locked: lockKT, at: lockKTAt, by: lockKTBy },
    { tier: 'Admin', locked: lockAdmin, at: lockAdminAt, by: lockAdminBy },
    { tier: 'Final', locked: lockFinal, at: lockFinalAt, by: lockFinalBy },
  ];

  const activeTiers = tiers.filter((t) => t.locked);
  const displayTiers = showAll ? tiers : activeTiers;

  if (displayTiers.length === 0) {
    return (
      <Badge variant="outline" className="gap-1 text-muted-foreground">
        <LockOpen className="h-3 w-3" />
        Chưa khóa
      </Badge>
    );
  }

  const formatDate = (date: Date | string | null | undefined) => {
    if (!date) return '';
    return new Date(date).toLocaleString('vi-VN');
  };

  return (
    <div className="flex flex-wrap gap-1">
      {displayTiers.map((tierInfo) => {
        const color = LOCK_TIER_COLORS[tierInfo.tier];
        const label = LOCK_TIER_LABELS[tierInfo.tier];

        if (!tierInfo.locked && !showAll) return null;

        const colorClass = tierInfo.locked
          ? color === 'amber'
            ? 'bg-amber-500 hover:bg-amber-600 text-white'
            : color === 'orange'
              ? 'bg-orange-500 hover:bg-orange-600 text-white'
              : 'bg-red-500 hover:bg-red-600 text-white'
          : 'text-muted-foreground border-dashed';

        return (
          <Badge
            key={tierInfo.tier}
            variant={tierInfo.locked ? 'default' : 'outline'}
            className={`gap-1 ${colorClass}`}
            title={
              tierInfo.locked && tierInfo.at
                ? `Khóa lúc: ${formatDate(tierInfo.at)}${tierInfo.by ? `\nBởi: ${tierInfo.by}` : ''}`
                : undefined
            }
          >
            {tierInfo.locked ? (
              <Lock className="h-3 w-3" />
            ) : (
              <LockOpen className="h-3 w-3" />
            )}
            {label}
          </Badge>
        );
      })}
    </div>
  );
}

/**
 * Compact version for table cells - shows only highest active tier
 */
export function LockTierBadgeCompact({
  lockKT,
  lockAdmin,
  lockFinal,
}: Pick<LockTierBadgeProps, 'lockKT' | 'lockAdmin' | 'lockFinal'>) {
  const highestTier: LockTier | null = lockFinal
    ? 'Final'
    : lockAdmin
      ? 'Admin'
      : lockKT
        ? 'KT'
        : null;

  if (!highestTier) {
    return <LockOpen className="h-4 w-4 text-muted-foreground" />;
  }

  const color = LOCK_TIER_COLORS[highestTier];
  const colorClass =
    color === 'amber'
      ? 'text-amber-500'
      : color === 'orange'
        ? 'text-orange-500'
        : 'text-red-500';

  return (
    <div className={`flex items-center gap-1 ${colorClass}`} title={`Khóa ${LOCK_TIER_LABELS[highestTier]}`}>
      <Lock className="h-4 w-4" />
      <span className="text-xs font-medium">{highestTier}</span>
    </div>
  );
}

/**
 * Single tier badge - for showing specific tier status
 */
export function SingleTierBadge({
  tier,
  isLocked,
  size = 'default',
}: {
  tier: LockTier;
  isLocked: boolean;
  size?: 'default' | 'sm';
}) {
  const color = LOCK_TIER_COLORS[tier];
  const label = LOCK_TIER_LABELS[tier];

  const sizeClass = size === 'sm' ? 'text-xs px-2 py-0.5' : '';

  const colorClass = isLocked
    ? color === 'amber'
      ? 'bg-amber-500 hover:bg-amber-600 text-white'
      : color === 'orange'
        ? 'bg-orange-500 hover:bg-orange-600 text-white'
        : 'bg-red-500 hover:bg-red-600 text-white'
    : 'text-muted-foreground';

  return (
    <Badge
      variant={isLocked ? 'default' : 'outline'}
      className={`gap-1 ${colorClass} ${sizeClass}`}
    >
      {isLocked ? <Lock className="h-3 w-3" /> : <LockOpen className="h-3 w-3" />}
      {label}
    </Badge>
  );
}
</file>

<file path="src/components/operators/reports/profit-chart.tsx">
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Cell, ReferenceLine } from 'recharts';
import { BarChart3 } from 'lucide-react';
import { formatCurrency } from '@/lib/utils';
import type { ProfitByBooking } from '@/types';

interface Props {
  data: ProfitByBooking[];
}

// Custom tooltip component
function CustomTooltip({ active, payload }: { active?: boolean; payload?: Array<{ payload: ProfitByBooking }> }) {
  if (!active || !payload || !payload.length) return null;

  const item = payload[0].payload;
  return (
    <div className="bg-white p-3 border rounded-lg shadow-lg text-sm">
      <p className="font-medium mb-1">{item.bookingCode}</p>
      <p className="text-muted-foreground">{item.customerName}</p>
      <div className="mt-2 space-y-1">
        <p>
          <span className="text-muted-foreground">Doanh thu:</span>{' '}
          <span className="text-blue-600 font-medium">{formatCurrency(item.totalRevenue)} ₫</span>
        </p>
        <p>
          <span className="text-muted-foreground">Chi phí:</span>{' '}
          <span className="text-red-600 font-medium">{formatCurrency(item.totalCost)} ₫</span>
        </p>
        <p>
          <span className="text-muted-foreground">Lợi nhuận:</span>{' '}
          <span className={`font-medium ${item.profit >= 0 ? 'text-green-600' : 'text-red-600'}`}>
            {formatCurrency(item.profit)} ₫
          </span>
        </p>
        <p>
          <span className="text-muted-foreground">Tỷ suất:</span>{' '}
          <span className={`font-medium ${item.profitMargin >= 0 ? 'text-green-600' : 'text-red-600'}`}>
            {item.profitMargin.toFixed(1)}%
          </span>
        </p>
      </div>
    </div>
  );
}

// Format Y axis values
function formatYAxis(value: number): string {
  if (Math.abs(value) >= 1000000) {
    return `${(value / 1000000).toFixed(0)}M`;
  }
  if (Math.abs(value) >= 1000) {
    return `${(value / 1000).toFixed(0)}K`;
  }
  return value.toString();
}

export function ProfitChart({ data }: Props) {
  // Get top 10 by profit (can be positive or negative)
  const top10 = [...data]
    .sort((a, b) => b.profit - a.profit)
    .slice(0, 10);

  // Truncate booking code for display
  const chartData = top10.map((item) => ({
    ...item,
    displayCode: item.bookingCode.length > 10
      ? item.bookingCode.slice(-8) // Show last 8 chars
      : item.bookingCode,
  }));

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <BarChart3 className="h-5 w-5" />
          Top 10 Booking theo Lợi nhuận
        </CardTitle>
      </CardHeader>
      <CardContent>
        {data.length === 0 ? (
          <p className="text-muted-foreground text-center py-8">
            Không có dữ liệu để hiển thị
          </p>
        ) : (
          <div className="h-[400px] w-full">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={chartData}
                layout="vertical"
                margin={{ top: 10, right: 30, left: 60, bottom: 10 }}
              >
                <CartesianGrid strokeDasharray="3 3" horizontal={true} vertical={false} />
                <XAxis
                  type="number"
                  tickFormatter={formatYAxis}
                  axisLine={false}
                  tickLine={false}
                />
                <YAxis
                  type="category"
                  dataKey="displayCode"
                  width={70}
                  tick={{ fontSize: 11 }}
                  axisLine={false}
                  tickLine={false}
                />
                <Tooltip content={<CustomTooltip />} />
                <ReferenceLine x={0} stroke="#666" strokeWidth={1} />
                <Bar
                  dataKey="profit"
                  radius={[0, 4, 4, 0]}
                  maxBarSize={30}
                >
                  {chartData.map((entry, index) => (
                    <Cell
                      key={`cell-${index}`}
                      fill={entry.profit >= 0 ? '#22c55e' : '#ef4444'}
                    />
                  ))}
                </Bar>
              </BarChart>
            </ResponsiveContainer>
          </div>
        )}

        {/* Legend */}
        <div className="flex justify-center gap-6 mt-4 text-sm">
          <div className="flex items-center gap-2">
            <div className="w-3 h-3 rounded bg-green-500" />
            <span className="text-muted-foreground">Có lãi</span>
          </div>
          <div className="flex items-center gap-2">
            <div className="w-3 h-3 rounded bg-red-500" />
            <span className="text-muted-foreground">Lỗ</span>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/providers/index.ts">
/**
 * Providers Barrel Export
 */

export { SessionProviderWrapper } from "./session-provider-wrapper";
</file>

<file path="src/components/providers/session-provider-wrapper.tsx">
"use client";

/**
 * SessionProvider Wrapper
 *
 * Client component wrapper for NextAuth SessionProvider.
 * Required because SessionProvider must be used in client components,
 * but layout.tsx is a server component by default.
 */

import { SessionProvider } from "next-auth/react";

interface SessionProviderWrapperProps {
  children: React.ReactNode;
}

export function SessionProviderWrapper({
  children,
}: SessionProviderWrapperProps) {
  return <SessionProvider>{children}</SessionProvider>;
}
</file>

<file path="src/components/reports/cost-breakdown-chart.tsx">
'use client';

import { memo, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts';
import { PieChartIcon } from 'lucide-react';
import { formatCurrency } from '@/lib/utils';
import type { CostBreakdownResponse } from '@/lib/report-utils';

interface Props {
  data: CostBreakdownResponse | null;
  loading?: boolean;
}

const COLORS = ['#3b82f6', '#22c55e', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4'];

const SERVICE_TYPE_LABELS: Record<string, string> = {
  HOTEL: 'Khách sạn',
  FLIGHT: 'Vé máy bay',
  TRANSPORT: 'Vận chuyển',
  TOUR: 'Tour',
  VISA: 'Visa',
  INSURANCE: 'Bảo hiểm',
  OTHER: 'Khác',
};

const PAYMENT_LABELS: Record<string, { label: string; color: string }> = {
  paid: { label: 'Đã thanh toán', color: '#22c55e' },
  partial: { label: 'Thanh toán một phần', color: '#f59e0b' },
  unpaid: { label: 'Chưa thanh toán', color: '#ef4444' },
};

interface TooltipPayload {
  name: string;
  value: number;
}

function CustomTooltip({
  active,
  payload
}: {
  active?: boolean;
  payload?: Array<{ payload: TooltipPayload }>;
}) {
  if (!active || !payload?.length) return null;
  const item = payload[0].payload;
  return (
    <div className="bg-white p-2 border rounded shadow text-sm">
      <p>{item.name}: {formatCurrency(item.value)} ₫</p>
    </div>
  );
}

export const CostBreakdownChart = memo(function CostBreakdownChart({ data, loading }: Props) {
  const { pieData, paymentBars } = useMemo(() => {
    if (!data) return { pieData: [], paymentBars: [] };

    const pie = data.byServiceType.map((item) => ({
      name: SERVICE_TYPE_LABELS[item.type] || item.type,
      value: item.amount,
    }));

    const totalPayment = data.paymentStatus.paid + data.paymentStatus.partial + data.paymentStatus.unpaid;

    const bars = Object.entries(PAYMENT_LABELS).map(([key, { label, color }]) => {
      const value = data.paymentStatus[key as keyof typeof data.paymentStatus];
      return {
        key,
        label,
        color,
        value,
        percentage: totalPayment > 0 ? (value / totalPayment) * 100 : 0,
      };
    });

    return { pieData: pie, paymentBars: bars };
  }, [data]);

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <PieChartIcon className="h-5 w-5" />
            Phân tích Chi phí
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-[300px] w-full" />
        </CardContent>
      </Card>
    );
  }

  if (!data) return null;

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <PieChartIcon className="h-5 w-5" />
          Phân tích Chi phí
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="grid md:grid-cols-2 gap-6">
          {/* Pie Chart - By Service Type */}
          <div>
            <p className="text-sm font-medium mb-2 text-muted-foreground">
              Theo loại dịch vụ
            </p>
            {pieData.length === 0 ? (
              <p className="text-muted-foreground text-center py-8">Không có dữ liệu</p>
            ) : (
              <div className="h-[250px]">
                <ResponsiveContainer width="100%" height="100%">
                  <PieChart>
                    <Pie
                      data={pieData}
                      dataKey="value"
                      nameKey="name"
                      cx="50%"
                      cy="50%"
                      outerRadius={80}
                      label={({ name, percent }) =>
                        `${name}: ${((percent ?? 0) * 100).toFixed(0)}%`
                      }
                      labelLine={{ strokeWidth: 1 }}
                    >
                      {pieData.map((_, idx) => (
                        <Cell key={idx} fill={COLORS[idx % COLORS.length]} />
                      ))}
                    </Pie>
                    <Tooltip content={<CustomTooltip />} />
                  </PieChart>
                </ResponsiveContainer>
              </div>
            )}
          </div>

          {/* Horizontal Bars - Payment Status */}
          <div>
            <p className="text-sm font-medium mb-4 text-muted-foreground">
              Theo trạng thái thanh toán
            </p>
            <div className="space-y-4">
              {paymentBars.map(({ key, label, color, value, percentage }) => (
                <div key={key}>
                  <div className="flex justify-between text-sm mb-1">
                    <span>{label}</span>
                    <span className="font-medium">{formatCurrency(value)} ₫</span>
                  </div>
                  <div className="h-3 bg-gray-100 rounded-full overflow-hidden">
                    <div
                      className="h-full rounded-full transition-all"
                      style={{ width: `${percentage}%`, backgroundColor: color }}
                    />
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
});
</file>

<file path="src/components/reports/date-range-selector.tsx">
'use client';

import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from '@/components/ui/select';
import type { DateRangeOption } from '@/hooks/use-reports';

const DATE_RANGES: Array<{ value: DateRangeOption; label: string }> = [
  { value: 'thisMonth', label: 'Tháng này' },
  { value: 'lastMonth', label: 'Tháng trước' },
  { value: 'last3Months', label: '3 tháng gần đây' },
  { value: 'last6Months', label: '6 tháng gần đây' },
  { value: 'thisYear', label: 'Năm nay' },
];

interface Props {
  value: DateRangeOption;
  onChange: (value: DateRangeOption) => void;
}

export function DateRangeSelector({ value, onChange }: Props) {
  return (
    <Select value={value} onValueChange={onChange}>
      <SelectTrigger className="w-48">
        <SelectValue placeholder="Chọn khoảng thời gian" />
      </SelectTrigger>
      <SelectContent>
        {DATE_RANGES.map((range) => (
          <SelectItem key={range.value} value={range.value}>
            {range.label}
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
}
</file>

<file path="src/components/reports/funnel-chart.tsx">
'use client';

import { memo, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Cell,
  LabelList
} from 'recharts';
import { Filter } from 'lucide-react';
import type { FunnelResponse, FunnelStage } from '@/lib/report-utils';

interface Props {
  data: FunnelResponse | null;
  loading?: boolean;
}

// Stage labels in Vietnamese
const STAGE_LABELS: Record<string, string> = {
  LEAD: 'Tiềm năng',
  QUOTE: 'Báo giá',
  FOLLOWUP: 'Theo dõi',
  OUTCOME: 'Kết quả',
};

// Gradient colors from blue to green for funnel stages
const STAGE_COLORS = ['#3b82f6', '#6366f1', '#8b5cf6', '#22c55e'];

function CustomTooltip({
  active,
  payload
}: {
  active?: boolean;
  payload?: Array<{ payload: FunnelStage }>;
}) {
  if (!active || !payload?.length) return null;
  const item = payload[0].payload;
  return (
    <div className="bg-white p-3 border rounded-lg shadow-lg text-sm">
      <p className="font-medium">{STAGE_LABELS[item.stage] || item.stage}</p>
      <p className="text-muted-foreground">Số lượng: {item.count}</p>
      <p className="text-muted-foreground">Tỷ lệ: {item.percentage.toFixed(1)}%</p>
    </div>
  );
}

export const FunnelChart = memo(function FunnelChart({ data, loading }: Props) {
  const chartData = useMemo(() => {
    if (!data) return [];
    return data.stages.map((stage) => ({
      ...stage,
      label: STAGE_LABELS[stage.stage] || stage.stage,
    }));
  }, [data]);

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Filter className="h-5 w-5" />
            Phễu Chuyển đổi
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-[300px] w-full" />
        </CardContent>
      </Card>
    );
  }

  if (!data) return null;

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle className="flex items-center gap-2">
          <Filter className="h-5 w-5" />
          Phễu Chuyển đổi
        </CardTitle>
        <span className="text-sm font-medium text-green-600">
          Tỷ lệ chuyển đổi: {data.conversionRate.toFixed(1)}%
        </span>
      </CardHeader>
      <CardContent>
        {chartData.length === 0 ? (
          <p className="text-muted-foreground text-center py-8">Không có dữ liệu</p>
        ) : (
          <div className="h-[300px] w-full">
            <ResponsiveContainer width="100%" height="100%">
              <BarChart
                data={chartData}
                layout="vertical"
                margin={{ top: 10, right: 30, left: 100, bottom: 10 }}
              >
                <CartesianGrid
                  strokeDasharray="3 3"
                  horizontal={true}
                  vertical={false}
                />
                <XAxis type="number" axisLine={false} tickLine={false} />
                <YAxis
                  type="category"
                  dataKey="label"
                  width={90}
                  tick={{ fontSize: 12 }}
                  axisLine={false}
                  tickLine={false}
                />
                <Tooltip content={<CustomTooltip />} />
                <Bar dataKey="count" radius={[0, 4, 4, 0]} maxBarSize={30}>
                  <LabelList
                    dataKey="count"
                    position="right"
                    formatter={(v) => typeof v === 'number' ? v.toLocaleString('vi-VN') : String(v)}
                    style={{ fontSize: 11, fill: '#666' }}
                  />
                  {chartData.map((_, idx) => (
                    <Cell key={idx} fill={STAGE_COLORS[idx % STAGE_COLORS.length]} />
                  ))}
                </Bar>
              </BarChart>
            </ResponsiveContainer>
          </div>
        )}
      </CardContent>
    </Card>
  );
});
</file>

<file path="src/components/reports/kpi-cards.tsx">
'use client';

import { memo } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import {
  TrendingUp,
  TrendingDown,
  DollarSign,
  Wallet,
  FileText,
  Users,
  Target
} from 'lucide-react';
import { formatCurrency } from '@/lib/utils';
import type { DashboardResponse } from '@/lib/report-utils';

interface Props {
  data: DashboardResponse | null;
  loading?: boolean;
}

type KpiKey = 'totalBookings' | 'totalRevenue' | 'totalProfit' | 'activeRequests' | 'conversionRate';
type ComparisonKey = 'bookings' | 'revenue';

const KPI_CONFIG: Array<{
  key: KpiKey;
  compKey: ComparisonKey | null;
  label: string;
  icon: typeof FileText;
  format: 'number' | 'currency' | 'percent';
}> = [
  { key: 'totalBookings', compKey: 'bookings', label: 'Tổng Booking', icon: FileText, format: 'number' },
  { key: 'totalRevenue', compKey: 'revenue', label: 'Tổng Doanh thu', icon: DollarSign, format: 'currency' },
  { key: 'totalProfit', compKey: null, label: 'Tổng Lợi nhuận', icon: Wallet, format: 'currency' },
  { key: 'activeRequests', compKey: null, label: 'Yêu cầu đang xử lý', icon: Users, format: 'number' },
  { key: 'conversionRate', compKey: null, label: 'Tỷ lệ chuyển đổi', icon: Target, format: 'percent' },
];

function formatValue(value: number, format: 'number' | 'currency' | 'percent'): string {
  if (format === 'currency') return `${formatCurrency(value)} ₫`;
  if (format === 'percent') return `${value.toFixed(1)}%`;
  return value.toLocaleString('vi-VN');
}

export const KPICards = memo(function KPICards({ data, loading }: Props) {
  if (loading) {
    return (
      <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
        {[...Array(5)].map((_, i) => (
          <Card key={i}>
            <CardContent className="p-4">
              <Skeleton className="h-4 w-20 mb-2" />
              <Skeleton className="h-8 w-24 mb-2" />
              <Skeleton className="h-5 w-16" />
            </CardContent>
          </Card>
        ))}
      </div>
    );
  }

  if (!data) return null;

  return (
    <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
      {KPI_CONFIG.map(({ key, compKey, label, icon: Icon, format }) => {
        const value = data.kpiCards[key];
        const change = compKey ? data.comparison[compKey]?.changePercent : null;
        const isPositive = change !== null && change >= 0;

        return (
          <Card key={key}>
            <CardContent className="p-4">
              <div className="flex items-center gap-2 text-muted-foreground text-sm mb-1">
                <Icon className="h-4 w-4" />
                {label}
              </div>
              <p className="text-2xl font-bold">{formatValue(value, format)}</p>
              {change !== null && (
                <Badge variant={isPositive ? 'default' : 'destructive'} className="mt-2">
                  {isPositive ? (
                    <TrendingUp className="h-3 w-3 mr-1" />
                  ) : (
                    <TrendingDown className="h-3 w-3 mr-1" />
                  )}
                  {isPositive ? '+' : ''}{change.toFixed(1)}%
                </Badge>
              )}
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
});
</file>

<file path="src/components/reports/revenue-trend-chart.tsx">
'use client';

import { memo, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import {
  ComposedChart,
  Line,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend
} from 'recharts';
import { TrendingUp } from 'lucide-react';
import { formatCurrency } from '@/lib/utils';
import type { RevenueTrendResponse } from '@/lib/report-utils';

interface Props {
  data: RevenueTrendResponse | null;
  loading?: boolean;
}

// Format period YYYY-MM to "Th.M/YY"
function formatPeriod(period: string): string {
  const [year, month] = period.split('-');
  return `Th.${parseInt(month)}/${year.slice(2)}`;
}

// Format axis values
function formatYAxis(value: number): string {
  if (Math.abs(value) >= 1000000) return `${(value / 1000000).toFixed(0)}M`;
  if (Math.abs(value) >= 1000) return `${(value / 1000).toFixed(0)}K`;
  return value.toString();
}

interface TooltipPayload {
  dataKey: string;
  value: number;
  color: string;
}

// Custom tooltip
function CustomTooltip({
  active,
  payload,
  label
}: {
  active?: boolean;
  payload?: TooltipPayload[];
  label?: string;
}) {
  if (!active || !payload) return null;

  return (
    <div className="bg-white p-3 border rounded-lg shadow-lg text-sm">
      <p className="font-medium mb-2">{label}</p>
      {payload.map((entry) => (
        <p key={entry.dataKey} style={{ color: entry.color }}>
          {entry.dataKey === 'revenue' && 'Doanh thu: '}
          {entry.dataKey === 'cost' && 'Chi phí: '}
          {entry.dataKey === 'profit' && 'Lợi nhuận: '}
          {formatCurrency(entry.value)} ₫
        </p>
      ))}
    </div>
  );
}

export const RevenueTrendChart = memo(function RevenueTrendChart({ data, loading }: Props) {
  const chartData = useMemo(() => {
    if (!data) return [];
    return data.data.map((item) => ({
      ...item,
      displayPeriod: formatPeriod(item.period),
    }));
  }, [data]);

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <TrendingUp className="h-5 w-5" />
            Xu hướng Doanh thu
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Skeleton className="h-[400px] w-full" />
        </CardContent>
      </Card>
    );
  }

  if (!data) return null;

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <TrendingUp className="h-5 w-5" />
          Xu hướng Doanh thu
        </CardTitle>
      </CardHeader>
      <CardContent>
        {chartData.length === 0 ? (
          <p className="text-muted-foreground text-center py-8">Không có dữ liệu</p>
        ) : (
          <div className="h-[400px] w-full">
            <ResponsiveContainer width="100%" height="100%">
              <ComposedChart
                data={chartData}
                margin={{ top: 10, right: 30, left: 0, bottom: 10 }}
              >
                <CartesianGrid strokeDasharray="3 3" vertical={false} />
                <XAxis
                  dataKey="displayPeriod"
                  tick={{ fontSize: 12 }}
                  axisLine={false}
                  tickLine={false}
                />
                <YAxis
                  tickFormatter={formatYAxis}
                  axisLine={false}
                  tickLine={false}
                />
                <Tooltip content={<CustomTooltip />} />
                <Legend wrapperStyle={{ paddingTop: 20 }} />
                <Bar
                  dataKey="profit"
                  name="Lợi nhuận"
                  fill="#22c55e"
                  radius={[4, 4, 0, 0]}
                  maxBarSize={40}
                />
                <Line
                  type="monotone"
                  dataKey="revenue"
                  name="Doanh thu"
                  stroke="#3b82f6"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
                <Line
                  type="monotone"
                  dataKey="cost"
                  name="Chi phí"
                  stroke="#ef4444"
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              </ComposedChart>
            </ResponsiveContainer>
          </div>
        )}
      </CardContent>
    </Card>
  );
});
</file>

<file path="src/components/requests/request-filters.tsx">
'use client';

import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  REQUEST_STAGES,
  REQUEST_STAGE_KEYS,
  getStatusesByStage,
  REQUEST_STATUSES,
} from '@/config/request-config';
import type { RequestFilters, User } from '@/types';

interface RequestFiltersProps {
  filters: RequestFilters;
  onChange: (filters: RequestFilters) => void;
  sellers?: User[];
  showSellerFilter?: boolean;
}

export function RequestFilters({
  filters,
  onChange,
  sellers,
  showSellerFilter = false,
}: RequestFiltersProps) {
  return (
    <div className="flex flex-wrap gap-4 p-4 bg-muted/50 rounded-lg items-end">
      {/* Stage select */}
      <div className="flex flex-col gap-1.5">
        <Label className="text-xs text-muted-foreground font-medium">Phễu</Label>
        <Select
          value={filters.stage || 'all'}
          onValueChange={(v) => onChange({ ...filters, stage: v === 'all' ? '' : v })}
        >
          <SelectTrigger className="w-[150px]">
            <SelectValue placeholder="Giai đoạn" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Tất cả</SelectItem>
            {REQUEST_STAGE_KEYS.map((stage) => (
              <SelectItem key={stage} value={stage}>
                {REQUEST_STAGES[stage].label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Status select - grouped by stage */}
      <div className="flex flex-col gap-1.5">
        <Label className="text-xs text-muted-foreground font-medium">Trạng thái</Label>
        <Select
          value={filters.status || 'all'}
          onValueChange={(v) => onChange({ ...filters, status: v === 'all' ? '' : v })}
        >
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Trạng thái" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">Tất cả</SelectItem>
            {REQUEST_STAGE_KEYS.map((stage) => (
              <SelectGroup key={stage}>
                <SelectLabel>{REQUEST_STAGES[stage].label}</SelectLabel>
                {getStatusesByStage(stage).map((status) => (
                  <SelectItem key={status} value={status}>
                    {REQUEST_STATUSES[status].label}
                  </SelectItem>
                ))}
              </SelectGroup>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Seller select (if permitted) */}
      {showSellerFilter && sellers && sellers.length > 0 && (
        <div className="flex flex-col gap-1.5">
          <Label className="text-xs text-muted-foreground font-medium">Seller</Label>
          <Select
            value={filters.seller || 'all'}
            onValueChange={(v) => onChange({ ...filters, seller: v === 'all' ? '' : v })}
          >
            <SelectTrigger className="w-[150px]">
              <SelectValue placeholder="Seller" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">Tất cả</SelectItem>
              {sellers.map((s) => (
                <SelectItem key={s.id} value={s.id}>
                  {s.name || s.email}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      )}

      {/* Search input */}
      <div className="flex flex-col gap-1.5">
        <Label className="text-xs text-muted-foreground font-medium">Tìm kiếm</Label>
        <Input
          placeholder="Tìm theo tên, mã..."
          value={filters.search || ''}
          onChange={(e) => onChange({ ...filters, search: e.target.value })}
          className="w-[200px]"
        />
      </div>

      {/* Date range */}
      <div className="flex flex-col gap-1.5">
        <Label className="text-xs text-muted-foreground font-medium">Khoảng thời gian</Label>
        <div className="flex gap-2 items-center">
          <Input
            type="date"
            value={filters.fromDate || ''}
            onChange={(e) => onChange({ ...filters, fromDate: e.target.value })}
            className="w-[140px]"
          />
          <span className="text-muted-foreground">-</span>
          <Input
            type="date"
            value={filters.toDate || ''}
            onChange={(e) => onChange({ ...filters, toDate: e.target.value })}
            className="w-[140px]"
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/revenues/revenue-lock-dialog.tsx">
'use client';

import { useState } from 'react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Label } from '@/components/ui/label';
import { Loader2, Lock, AlertCircle } from 'lucide-react';
import { LOCK_TIER_LABELS } from '@/config/lock-config';
import type { LockTier, LockState } from '@/lib/lock-utils';

interface RevenueLockDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  revenueId: string;
  currentState: LockState;
  onSuccess: () => void;
}

export function RevenueLockDialog({
  open,
  onOpenChange,
  revenueId,
  currentState,
  onSuccess,
}: RevenueLockDialogProps) {
  const [tier, setTier] = useState<LockTier>('KT');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Determine which tiers can be locked (sequential progression)
  const canLockKT = !currentState.lockKT;
  const canLockAdmin = currentState.lockKT && !currentState.lockAdmin;
  const canLockFinal = currentState.lockAdmin && !currentState.lockFinal;

  const handleLock = async () => {
    setLoading(true);
    setError(null);

    try {
      const res = await fetch(`/api/revenues/${revenueId}/lock`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tier }),
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || 'Khóa thất bại');
      }

      onSuccess();
      onOpenChange(false);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Khóa thất bại');
    } finally {
      setLoading(false);
    }
  };

  const handleOpenChange = (isOpen: boolean) => {
    if (!isOpen) {
      setError(null);
      // Reset to next available tier
      if (canLockKT) setTier('KT');
      else if (canLockAdmin) setTier('Admin');
      else if (canLockFinal) setTier('Final');
    }
    onOpenChange(isOpen);
  };

  return (
    <Dialog open={open} onOpenChange={handleOpenChange}>
      <DialogContent className="sm:max-w-[400px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Lock className="h-5 w-5" />
            Khóa Doanh thu
          </DialogTitle>
          <DialogDescription>
            Chọn mức khóa để áp dụng cho bản ghi này
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label htmlFor="tier">Mức khóa</Label>
            <Select value={tier} onValueChange={(v) => setTier(v as LockTier)}>
              <SelectTrigger id="tier">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="KT" disabled={!canLockKT}>
                  {LOCK_TIER_LABELS.KT}
                  {!canLockKT && ' (đã khóa)'}
                </SelectItem>
                <SelectItem value="Admin" disabled={!canLockAdmin}>
                  {LOCK_TIER_LABELS.Admin}
                  {currentState.lockAdmin && ' (đã khóa)'}
                  {!currentState.lockKT && ' (cần khóa KT trước)'}
                </SelectItem>
                <SelectItem value="Final" disabled={!canLockFinal}>
                  {LOCK_TIER_LABELS.Final}
                  {currentState.lockFinal && ' (đã khóa)'}
                  {!currentState.lockAdmin && ' (cần khóa Admin trước)'}
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          {error && (
            <div className="flex items-center gap-2 text-sm text-destructive">
              <AlertCircle className="h-4 w-4" />
              {error}
            </div>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => handleOpenChange(false)}>
            Hủy
          </Button>
          <Button onClick={handleLock} disabled={loading}>
            {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Xác nhận
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/revenues/sales-summary-table.tsx">
'use client';

import Link from 'next/link';
import { Badge } from '@/components/ui/badge';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { formatDate, formatCurrency } from '@/lib/utils';
import type { SaleItem, SalesSummary } from '@/types';

interface SalesSummaryTableProps {
  sales: SaleItem[];
  summary: SalesSummary;
}

export function SalesSummaryTable({ sales, summary }: SalesSummaryTableProps) {
  if (sales.length === 0) {
    return (
      <div className="text-center py-8 text-muted-foreground">
        Khong co du lieu tong hop
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Summary Stats */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <SummaryCard label="Tong doanh thu" value={summary.totalRevenue} color="text-green-600" />
        <SummaryCard label="Tong chi phi" value={summary.totalCost} color="text-orange-600" />
        <SummaryCard label="Tong loi nhuan" value={summary.totalProfit} color="text-blue-600" />
        <div className="rounded-lg border p-4 bg-muted/50">
          <p className="text-sm text-muted-foreground">So booking</p>
          <p className="text-2xl font-bold">{summary.bookingCount}</p>
        </div>
      </div>

      {/* Sales Table */}
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Ma Booking</TableHead>
            <TableHead>Khach hang</TableHead>
            <TableHead>Ngay bat dau</TableHead>
            <TableHead>Ngay ket thuc</TableHead>
            <TableHead className="text-right">Doanh thu</TableHead>
            <TableHead className="text-right">Chi phi</TableHead>
            <TableHead className="text-right">Loi nhuan</TableHead>
            <TableHead className="text-center">So lan thu</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {sales.map((sale) => (
            <TableRow key={sale.bookingCode}>
              <TableCell className="font-mono text-sm">
                <Link
                  href={`/operators/reports?bookingCode=${sale.bookingCode}`}
                  className="text-primary hover:underline"
                >
                  {sale.bookingCode}
                </Link>
              </TableCell>
              <TableCell className="font-medium">{sale.customerName}</TableCell>
              <TableCell>
                {sale.startDate ? formatDate(sale.startDate) : '-'}
              </TableCell>
              <TableCell>
                {sale.endDate ? formatDate(sale.endDate) : '-'}
              </TableCell>
              <TableCell className="text-right font-mono text-green-600">
                {formatCurrency(sale.totalRevenue)}
              </TableCell>
              <TableCell className="text-right font-mono text-orange-600">
                {formatCurrency(sale.totalCost)}
              </TableCell>
              <TableCell className="text-right font-mono">
                <span className={sale.profit >= 0 ? 'text-blue-600' : 'text-red-600'}>
                  {formatCurrency(sale.profit)}
                </span>
              </TableCell>
              <TableCell className="text-center">
                <Badge variant="outline">{sale.revenueCount}</Badge>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}

// Summary card component
function SummaryCard({
  label,
  value,
  color,
}: {
  label: string;
  value: number;
  color: string;
}) {
  return (
    <div className="rounded-lg border p-4 bg-muted/50">
      <p className="text-sm text-muted-foreground">{label}</p>
      <p className={`text-2xl font-bold font-mono ${color}`}>
        {formatCurrency(value)}
      </p>
    </div>
  );
}
</file>

<file path="src/components/settings/followup-status-table.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
  useSortable,
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { GripVertical, Edit, Trash2, Plus } from 'lucide-react';
import { toast } from 'sonner';
import { FollowUpStatus } from '@/types';

interface FollowUpStatusTableProps {
  onEdit: (status: FollowUpStatus) => void;
  onDelete: (id: string) => Promise<void>;
  onAdd: () => void;
}

interface SortableRowProps {
  status: FollowUpStatus;
  onEdit: (status: FollowUpStatus) => void;
  onDeleteClick: (status: FollowUpStatus) => void;
}

function getDaysBadgeClass(days: number): string {
  if (days === 0) return 'bg-gray-100 text-gray-800 border-gray-200';
  if (days <= 2) return 'bg-yellow-100 text-yellow-800 border-yellow-200';
  return 'bg-red-100 text-red-800 border-red-200';
}

function SortableRow({ status, onEdit, onDeleteClick }: SortableRowProps) {
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({
    id: status.id,
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  return (
    <TableRow ref={setNodeRef} style={style}>
      {/* Drag Handle */}
      <TableCell className="w-[40px]">
        <button
          {...attributes}
          {...listeners}
          className="cursor-grab active:cursor-grabbing"
          type="button"
        >
          <GripVertical className="h-4 w-4 text-muted-foreground" />
        </button>
      </TableCell>

      {/* Status Name */}
      <TableCell className="w-[200px] font-medium">{status.status}</TableCell>

      {/* Aliases */}
      <TableCell className="w-[250px]">
        <div className="flex flex-wrap gap-1">
          {status.aliases.length === 0 ? (
            <span className="text-sm text-muted-foreground">-</span>
          ) : (
            status.aliases.map((alias, idx) => (
              <Badge
                key={idx}
                variant="outline"
                className="inline-flex items-center px-2 py-0.5 rounded text-xs bg-slate-100 text-slate-700"
              >
                {alias}
              </Badge>
            ))
          )}
        </div>
      </TableCell>

      {/* Days to Follow-up */}
      <TableCell className="w-[80px]">
        <Badge variant="outline" className={getDaysBadgeClass(status.daysToFollowup)}>
          {status.daysToFollowup} ngày
        </Badge>
      </TableCell>

      {/* Active Status */}
      <TableCell className="w-[100px]">
        <Badge
          variant={status.isActive ? 'default' : 'secondary'}
          className={
            status.isActive
              ? 'bg-green-100 text-green-800 hover:bg-green-100'
              : 'bg-gray-100 text-gray-600'
          }
        >
          {status.isActive ? 'Hoạt động' : 'Ngừng'}
        </Badge>
      </TableCell>

      {/* Actions */}
      <TableCell className="w-[80px] text-right">
        <div className="flex justify-end gap-1">
          <Button variant="ghost" size="icon" onClick={() => onEdit(status)} title="Sửa">
            <Edit className="h-4 w-4" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            onClick={() => onDeleteClick(status)}
            title="Xóa"
            className="text-destructive hover:text-destructive"
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        </div>
      </TableCell>
    </TableRow>
  );
}

export function FollowUpStatusTable({ onEdit, onDelete, onAdd }: FollowUpStatusTableProps) {
  const [statuses, setStatuses] = useState<FollowUpStatus[]>([]);
  const [loading, setLoading] = useState(true);

  // Delete dialog state
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [deletingStatus, setDeletingStatus] = useState<FollowUpStatus | null>(null);
  const [deleting, setDeleting] = useState(false);

  // DnD sensors
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const fetchStatuses = useCallback(async () => {
    setLoading(true);
    try {
      const res = await fetch('/api/config/follow-up-statuses');
      const data = await res.json();

      if (data.success) {
        setStatuses(data.data);
      } else {
        toast.error(data.error || 'Lỗi tải danh sách trạng thái');
      }
    } catch {
      toast.error('Lỗi kết nối server');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStatuses();
  }, [fetchStatuses]);

  const handleDragEnd = async (event: DragEndEvent) => {
    const { active, over } = event;

    if (!over || active.id === over.id) {
      return;
    }

    const oldIndex = statuses.findIndex((s) => s.id === active.id);
    const newIndex = statuses.findIndex((s) => s.id === over.id);

    // Optimistic UI update
    const reorderedStatuses = arrayMove(statuses, oldIndex, newIndex);
    setStatuses(reorderedStatuses);

    // Calculate new sortOrder values
    const updates = reorderedStatuses.map((status, index) => ({
      id: status.id,
      sortOrder: index,
    }));

    try {
      const res = await fetch('/api/config/follow-up-statuses/reorder', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ items: updates }),
      });

      const data = await res.json();

      if (!data.success) {
        // Revert on error
        setStatuses(statuses);
        toast.error(data.error || 'Lỗi sắp xếp lại trạng thái');
      } else {
        toast.success('Đã cập nhật thứ tự trạng thái');
      }
    } catch {
      // Revert on error
      setStatuses(statuses);
      toast.error('Lỗi kết nối server');
    }
  };

  const handleDeleteClick = (status: FollowUpStatus) => {
    setDeletingStatus(status);
    setDeleteDialogOpen(true);
  };

  const handleDeleteConfirm = async () => {
    if (!deletingStatus) return;

    setDeleting(true);
    try {
      await onDelete(deletingStatus.id);
      toast.success('Đã xóa trạng thái thành công');
      fetchStatuses(); // Refresh list
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Lỗi xóa trạng thái';
      toast.error(message);
    } finally {
      setDeleting(false);
      setDeleteDialogOpen(false);
      setDeletingStatus(null);
    }
  };

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">Trạng thái Follow-up</h3>
        <Button onClick={onAdd}>
          <Plus className="mr-2 h-4 w-4" />
          Thêm trạng thái
        </Button>
      </div>

      {/* Table */}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[40px]"></TableHead>
              <TableHead className="w-[200px]">Trạng thái</TableHead>
              <TableHead className="w-[250px]">Aliases</TableHead>
              <TableHead className="w-[80px]">Số ngày</TableHead>
              <TableHead className="w-[100px]">Trạng thái</TableHead>
              <TableHead className="w-[80px] text-right">Thao tác</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableRow>
                <TableCell colSpan={6} className="text-center py-8">
                  Đang tải...
                </TableCell>
              </TableRow>
            ) : statuses.length === 0 ? (
              <TableRow>
                <TableCell colSpan={6} className="text-center py-8 text-muted-foreground">
                  Chưa có trạng thái nào
                </TableCell>
              </TableRow>
            ) : (
              <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
                <SortableContext items={statuses.map((s) => s.id)} strategy={verticalListSortingStrategy}>
                  {statuses.map((status) => (
                    <SortableRow
                      key={status.id}
                      status={status}
                      onEdit={onEdit}
                      onDeleteClick={handleDeleteClick}
                    />
                  ))}
                </SortableContext>
              </DndContext>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Xác nhận xóa</AlertDialogTitle>
            <AlertDialogDescription>
              Bạn có chắc muốn xóa trạng thái &quot;{deletingStatus?.status}&quot;? Hành động này
              không thể hoàn tác.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={deleting}>Hủy</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteConfirm}
              disabled={deleting}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {deleting ? 'Đang xóa...' : 'Xóa'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="src/components/settings/google-sheets-sync.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { RefreshCw, FileSpreadsheet, CheckCircle, XCircle, AlertCircle, Loader2 } from 'lucide-react';
import { toast } from 'sonner';

interface SyncStats {
  sheetName: string;
  status: string;
  _count: number;
}

interface LastSync {
  sheetName: string;
  lastSync: string | null;
  lastRow: number | null;
}

interface SyncStatusData {
  configured: boolean;
  stats: SyncStats[];
  lastSyncs: LastSync[];
}

const SHEETS = [
  { name: 'Request', label: 'Requests', description: 'Sync customer requests from sheet' },
  { name: 'Operator', label: 'Operators', description: 'Sync operator costs from sheet' },
  { name: 'Revenue', label: 'Revenues', description: 'Sync revenue entries from sheet' },
] as const;

export function GoogleSheetsSync() {
  const [status, setStatus] = useState<SyncStatusData | null>(null);
  const [loading, setLoading] = useState(true);
  const [syncing, setSyncing] = useState<string | null>(null);

  const fetchStatus = useCallback(async () => {
    try {
      const res = await fetch('/api/sync/sheets');
      const data = await res.json();
      if (data.success) {
        setStatus(data.data);
      }
    } catch (error) {
      console.error('Failed to fetch sync status:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStatus();
  }, [fetchStatus]);

  const handleSync = async (sheetName: string) => {
    setSyncing(sheetName);
    try {
      const res = await fetch('/api/sync/sheets', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sheetName }),
      });

      const data = await res.json();

      if (data.success) {
        if (data.synced > 0 || data.errors > 0) {
          toast.success(`Synced ${data.synced} rows${data.errors > 0 ? `, ${data.errors} errors` : ''}`);
        } else {
          toast.info('No new rows to sync');
        }
        // Refresh status
        fetchStatus();
      } else {
        toast.error(data.error || 'Sync failed');
      }
    } catch (error) {
      console.error('Sync error:', error);
      toast.error('Sync failed. Check console for details.');
    } finally {
      setSyncing(null);
    }
  };

  const getSheetStats = (sheetName: string) => {
    if (!status) return { success: 0, failed: 0, lastSync: null, lastRow: null };

    const success = status.stats.find(s => s.sheetName === sheetName && s.status === 'SUCCESS')?._count || 0;
    const failed = status.stats.find(s => s.sheetName === sheetName && s.status === 'FAILED')?._count || 0;
    const lastSyncData = status.lastSyncs.find(s => s.sheetName === sheetName);

    return {
      success,
      failed,
      lastSync: lastSyncData?.lastSync,
      lastRow: lastSyncData?.lastRow,
    };
  };

  const formatDate = (dateStr: string | null) => {
    if (!dateStr) return 'Never';
    return new Date(dateStr).toLocaleString('vi-VN', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-8">
        <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (!status?.configured) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Google Sheets Not Configured</AlertTitle>
        <AlertDescription>
          Set the following environment variables to enable Google Sheets sync:
          <ul className="mt-2 list-disc list-inside text-sm">
            <li>GOOGLE_SERVICE_ACCOUNT_EMAIL</li>
            <li>GOOGLE_PRIVATE_KEY</li>
            <li>GOOGLE_SHEET_ID</li>
          </ul>
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-medium">Google Sheets Sync</h3>
          <p className="text-sm text-muted-foreground">
            One-way sync from Google Sheets to database (append-only)
          </p>
        </div>
        <Button variant="outline" size="sm" onClick={fetchStatus}>
          <RefreshCw className="h-4 w-4 mr-2" />
          Refresh Status
        </Button>
      </div>

      <div className="grid gap-4 md:grid-cols-3">
        {SHEETS.map((sheet) => {
          const stats = getSheetStats(sheet.name);
          const isSyncing = syncing === sheet.name;

          return (
            <Card key={sheet.name}>
              <CardHeader className="pb-3">
                <div className="flex items-center justify-between">
                  <CardTitle className="text-base flex items-center gap-2">
                    <FileSpreadsheet className="h-4 w-4" />
                    {sheet.label}
                  </CardTitle>
                  <Button
                    size="sm"
                    onClick={() => handleSync(sheet.name)}
                    disabled={isSyncing || syncing !== null}
                  >
                    {isSyncing ? (
                      <>
                        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        Syncing...
                      </>
                    ) : (
                      <>
                        <RefreshCw className="h-4 w-4 mr-2" />
                        Sync
                      </>
                    )}
                  </Button>
                </div>
                <CardDescription>{sheet.description}</CardDescription>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex items-center gap-2">
                  <Badge variant="outline" className="text-green-600">
                    <CheckCircle className="h-3 w-3 mr-1" />
                    {stats.success} synced
                  </Badge>
                  {stats.failed > 0 && (
                    <Badge variant="outline" className="text-red-600">
                      <XCircle className="h-3 w-3 mr-1" />
                      {stats.failed} failed
                    </Badge>
                  )}
                </div>
                <div className="text-xs text-muted-foreground space-y-1">
                  <p>Last sync: {formatDate(stats.lastSync ?? null)}</p>
                  {stats.lastRow && <p>Last row: {stats.lastRow}</p>}
                </div>
              </CardContent>
            </Card>
          );
        })}
      </div>

      <Alert>
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>How it works</AlertTitle>
        <AlertDescription>
          <ul className="mt-2 text-sm space-y-1">
            <li>1. Click &quot;Sync&quot; to import new rows from Google Sheet</li>
            <li>2. Only rows after the last synced row are imported</li>
            <li>3. Existing records are updated by unique code/ID</li>
            <li>4. Sync logs track all operations for audit</li>
          </ul>
        </AlertDescription>
      </Alert>
    </div>
  );
}
</file>

<file path="src/components/shared/lock-tier-badge.tsx">
'use client';

import { Badge } from '@/components/ui/badge';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { Lock, Unlock, Shield, ShieldCheck, ShieldAlert } from 'lucide-react';
import { LOCK_TIER_LABELS, LOCK_TIER_COLORS } from '@/config/lock-config';
import type { LockState } from '@/lib/lock-utils';

interface LockTierBadgeProps extends LockState {
  showTooltip?: boolean;
  compact?: boolean;
}

/**
 * Displays 3-tier lock status as a badge
 * Colors: KT=amber, Admin=orange, Final=red
 */
export function LockTierBadge({
  lockKT,
  lockAdmin,
  lockFinal,
  showTooltip = true,
  compact = false,
}: LockTierBadgeProps) {
  // Determine highest lock tier
  const highestTier = lockFinal ? 'Final' : lockAdmin ? 'Admin' : lockKT ? 'KT' : null;

  if (!highestTier) {
    return (
      <Badge variant="outline" className="text-gray-500 gap-1">
        <Unlock className="h-3 w-3" />
        {!compact && 'Mở'}
      </Badge>
    );
  }

  const color = LOCK_TIER_COLORS[highestTier];
  const label = LOCK_TIER_LABELS[highestTier];

  // Color classes based on tier
  const colorClasses = {
    amber: 'bg-amber-100 text-amber-800 border-amber-200',
    orange: 'bg-orange-100 text-orange-800 border-orange-200',
    red: 'bg-red-100 text-red-800 border-red-200',
  }[color] || 'bg-gray-100 text-gray-800';

  // Icon based on tier
  const Icon = highestTier === 'Final' ? ShieldAlert : highestTier === 'Admin' ? ShieldCheck : Shield;

  const badge = (
    <Badge variant="outline" className={`${colorClasses} gap-1`}>
      <Icon className="h-3 w-3" />
      {!compact && label}
    </Badge>
  );

  if (!showTooltip || compact) {
    return badge;
  }

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>{badge}</TooltipTrigger>
        <TooltipContent>
          <div className="text-xs space-y-1">
            <div className="flex items-center gap-2">
              {lockKT ? <Lock className="h-3 w-3 text-amber-600" /> : <Unlock className="h-3 w-3 text-gray-400" />}
              <span className={lockKT ? 'text-amber-600' : 'text-gray-400'}>KT</span>
            </div>
            <div className="flex items-center gap-2">
              {lockAdmin ? <Lock className="h-3 w-3 text-orange-600" /> : <Unlock className="h-3 w-3 text-gray-400" />}
              <span className={lockAdmin ? 'text-orange-600' : 'text-gray-400'}>Admin</span>
            </div>
            <div className="flex items-center gap-2">
              {lockFinal ? <Lock className="h-3 w-3 text-red-600" /> : <Unlock className="h-3 w-3 text-gray-400" />}
              <span className={lockFinal ? 'text-red-600' : 'text-gray-400'}>Cuối</span>
            </div>
          </div>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}

/**
 * Compact version showing only icons for table cells
 */
export function LockTierBadgeCompact(props: LockState) {
  return <LockTierBadge {...props} compact showTooltip />;
}
</file>

<file path="src/components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/error-fallback.tsx">
"use client";

import * as React from "react";
import { AlertTriangle, RefreshCw, ArrowLeft } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { cn } from "@/lib/utils";

interface ErrorFallbackProps {
  title?: string;
  message?: string;
  onRetry?: () => void;
  onBack?: () => void;
  backLabel?: string;
  retryLabel?: string;
  className?: string;
}

/**
 * Reusable error UI component for error boundaries and error states.
 * Follows VivaTour design standards with danger color scheme.
 */
export function ErrorFallback({
  title = "Đã xảy ra lỗi",
  message = "Không thể tải dữ liệu. Vui lòng thử lại sau.",
  onRetry,
  onBack,
  backLabel = "Quay lại",
  retryLabel = "Thử lại",
  className,
}: ErrorFallbackProps) {
  return (
    <Card
      className={cn(
        "mx-auto max-w-md border-danger-200 bg-danger-50/30",
        className
      )}
    >
      <CardContent className="flex flex-col items-center justify-center py-12 text-center">
        {/* Error Icon */}
        <div className="mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-danger-100">
          <AlertTriangle className="h-8 w-8 text-danger-500" />
        </div>

        {/* Title */}
        <h2 className="mb-2 text-lg font-semibold text-neutral-800">{title}</h2>

        {/* Message */}
        <p className="mb-6 text-sm text-neutral-600">{message}</p>

        {/* Action Buttons */}
        <div className="flex items-center gap-3">
          {onBack && (
            <Button variant="outline" onClick={onBack}>
              <ArrowLeft className="mr-2 h-4 w-4" />
              {backLabel}
            </Button>
          )}
          {onRetry && (
            <Button
              onClick={onRetry}
              className="bg-gradient-to-r from-danger-500 to-danger-600 text-white hover:brightness-110"
            >
              <RefreshCw className="mr-2 h-4 w-4" />
              {retryLabel}
            </Button>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/config/lock-config.ts">
// ============================================
// Lock System Configuration
// Constants, Vietnamese labels, colors for 3-tier lock
// ============================================

// History action types for lock operations
export const LOCK_HISTORY_ACTIONS = {
  LOCK_KT: 'LOCK_KT',
  UNLOCK_KT: 'UNLOCK_KT',
  LOCK_ADMIN: 'LOCK_ADMIN',
  UNLOCK_ADMIN: 'UNLOCK_ADMIN',
  LOCK_FINAL: 'LOCK_FINAL',
  UNLOCK_FINAL: 'UNLOCK_FINAL',
} as const;

export type LockHistoryAction = (typeof LOCK_HISTORY_ACTIONS)[keyof typeof LOCK_HISTORY_ACTIONS];

// Vietnamese labels for lock tiers
export const LOCK_TIER_LABELS: Record<string, string> = {
  KT: 'Khóa KT',
  Admin: 'Khóa Admin',
  Final: 'Khóa Cuối',
};

// Lock tier colors for badges (Tailwind colors)
export const LOCK_TIER_COLORS: Record<string, string> = {
  KT: 'amber',
  Admin: 'orange',
  Final: 'red',
};

// History action labels (Vietnamese)
export const HISTORY_ACTION_LABELS: Record<string, string> = {
  CREATE: 'Tạo mới',
  UPDATE: 'Cập nhật',
  DELETE: 'Xóa',
  LOCK: 'Khóa', // Legacy
  UNLOCK: 'Mở khóa', // Legacy
  LOCK_KT: 'Khóa KT',
  UNLOCK_KT: 'Mở khóa KT',
  LOCK_ADMIN: 'Khóa Admin',
  UNLOCK_ADMIN: 'Mở khóa Admin',
  LOCK_FINAL: 'Khóa cuối',
  UNLOCK_FINAL: 'Mở khóa cuối',
  APPROVE: 'Duyệt thanh toán',
};

// History action colors
export const HISTORY_ACTION_COLORS: Record<string, string> = {
  CREATE: 'green',
  UPDATE: 'blue',
  DELETE: 'red',
  LOCK: 'amber',
  UNLOCK: 'purple',
  LOCK_KT: 'amber',
  UNLOCK_KT: 'purple',
  LOCK_ADMIN: 'orange',
  UNLOCK_ADMIN: 'purple',
  LOCK_FINAL: 'red',
  UNLOCK_FINAL: 'purple',
  APPROVE: 'emerald',
};

/**
 * Get Vietnamese label for lock tier
 */
export function getLockTierLabel(tier: string): string {
  return LOCK_TIER_LABELS[tier] || tier;
}

/**
 * Get color for lock tier badge
 */
export function getLockTierColor(tier: string): string {
  return LOCK_TIER_COLORS[tier] || 'gray';
}

/**
 * Get Vietnamese label for history action
 */
export function getHistoryActionLabel(action: string): string {
  return HISTORY_ACTION_LABELS[action] || action;
}

/**
 * Get color for history action
 */
export function getHistoryActionColor(action: string): string {
  return HISTORY_ACTION_COLORS[action] || 'gray';
}
</file>

<file path="src/config/operator-config.ts">
// Operator configuration - centralized constants
// Service types aligned with Supplier types for consistency

export const SERVICE_TYPES = {
  HOTEL: { label: 'Khách sạn', icon: 'Building2' },
  RESTAURANT: { label: 'Nhà hàng', icon: 'UtensilsCrossed' },
  TRANSPORT: { label: 'Vận chuyển', icon: 'Car' },
  GUIDE: { label: 'Hướng dẫn viên', icon: 'User' },
  VISA: { label: 'Visa', icon: 'FileText' },
  VMB: { label: 'Vé máy bay', icon: 'Plane' },
  CRUISE: { label: 'Du thuyền', icon: 'Ship' },
  ACTIVITY: { label: 'Hoạt động/Tour', icon: 'Camera' },
  OTHER: { label: 'Khác', icon: 'MoreHorizontal' },
} as const;

export type ServiceTypeKey = keyof typeof SERVICE_TYPES;
export const SERVICE_TYPE_KEYS = Object.keys(SERVICE_TYPES) as ServiceTypeKey[];

// Payment status options
export const PAYMENT_STATUSES = {
  PENDING: { label: 'Chờ thanh toán', color: 'yellow' },
  PARTIAL: { label: 'Thanh toán một phần', color: 'orange' },
  PAID: { label: 'Đã thanh toán', color: 'green' },
} as const;

export type PaymentStatusKey = keyof typeof PAYMENT_STATUSES;
export const PAYMENT_STATUS_KEYS = Object.keys(PAYMENT_STATUSES) as PaymentStatusKey[];

// Default VAT rate (%)
export const DEFAULT_VAT_RATE = 10;

// History action types
export const HISTORY_ACTIONS = {
  CREATE: { label: 'Tạo mới', color: 'green' },
  UPDATE: { label: 'Cập nhật', color: 'blue' },
  DELETE: { label: 'Xóa', color: 'red' },
  // Legacy lock actions (kept for backward compatibility)
  LOCK: { label: 'Khóa', color: 'amber' },
  UNLOCK: { label: 'Mở khóa', color: 'purple' },
  // 3-tier lock actions
  LOCK_KT: { label: 'Khóa KT', color: 'amber' },
  UNLOCK_KT: { label: 'Mở khóa KT', color: 'purple' },
  LOCK_ADMIN: { label: 'Khóa Admin', color: 'orange' },
  UNLOCK_ADMIN: { label: 'Mở khóa Admin', color: 'purple' },
  LOCK_FINAL: { label: 'Khóa Cuối', color: 'red' },
  UNLOCK_FINAL: { label: 'Mở khóa Cuối', color: 'purple' },
  APPROVE: { label: 'Duyệt TT', color: 'emerald' },
} as const;

export type HistoryActionKey = keyof typeof HISTORY_ACTIONS;
</file>

<file path="src/config/revenue-config.ts">
// Revenue configuration - centralized constants

// Payment types
export const PAYMENT_TYPES = {
  DEPOSIT: { label: 'Đặt cọc', color: 'blue' },
  FULL_PAYMENT: { label: 'Thanh toán đủ', color: 'green' },
  PARTIAL: { label: 'Thanh toán một phần', color: 'yellow' },
  REFUND: { label: 'Hoàn tiền', color: 'red' },
} as const;

export type PaymentTypeKey = keyof typeof PAYMENT_TYPES;
export const PAYMENT_TYPE_KEYS = Object.keys(PAYMENT_TYPES) as PaymentTypeKey[];

// Payment sources
export const PAYMENT_SOURCES = {
  BANK_TRANSFER: { label: 'Chuyển khoản', icon: 'Building' },
  CASH: { label: 'Tiền mặt', icon: 'Banknote' },
  CARD: { label: 'Thẻ tín dụng', icon: 'CreditCard' },
  PAYPAL: { label: 'PayPal', icon: 'Globe' },
  WISE: { label: 'Wise', icon: 'Globe' },
  OTHER: { label: 'Khác', icon: 'MoreHorizontal' },
} as const;

export type PaymentSourceKey = keyof typeof PAYMENT_SOURCES;
export const PAYMENT_SOURCE_KEYS = Object.keys(PAYMENT_SOURCES) as PaymentSourceKey[];

// Supported currencies
export const CURRENCIES = {
  VND: { label: 'VND', symbol: '₫', decimals: 0 },
  USD: { label: 'USD', symbol: '$', decimals: 2 },
  EUR: { label: 'EUR', symbol: '€', decimals: 2 },
  GBP: { label: 'GBP', symbol: '£', decimals: 2 },
  AUD: { label: 'AUD', symbol: 'A$', decimals: 2 },
  JPY: { label: 'JPY', symbol: '¥', decimals: 0 },
  SGD: { label: 'SGD', symbol: 'S$', decimals: 2 },
  THB: { label: 'THB', symbol: '฿', decimals: 2 },
} as const;

export type CurrencyKey = keyof typeof CURRENCIES;
export const CURRENCY_KEYS = Object.keys(CURRENCIES) as CurrencyKey[];

// Default exchange rates (fallback, user should input actual rate)
export const DEFAULT_EXCHANGE_RATES: Record<CurrencyKey, number> = {
  VND: 1,
  USD: 25000,
  EUR: 27000,
  GBP: 32000,
  AUD: 16500,
  JPY: 165,
  SGD: 18500,
  THB: 700,
};
</file>

<file path="src/hooks/index.ts">
/**
 * Hooks Barrel Export
 *
 * Central export point for all custom React hooks.
 */

export { usePermission } from "./use-permission";
</file>

<file path="src/hooks/use-reports.ts">
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { safeFetch } from '@/lib/api/fetch-utils';
import type {
  DashboardResponse,
  RevenueTrendResponse,
  CostBreakdownResponse,
  FunnelResponse
} from '@/lib/report-utils';

export type DateRangeOption = 'thisMonth' | 'lastMonth' | 'last3Months' | 'last6Months' | 'thisYear';

interface ReportsState {
  dashboard: DashboardResponse | null;
  trend: RevenueTrendResponse | null;
  costBreakdown: CostBreakdownResponse | null;
  funnel: FunnelResponse | null;
  loading: boolean;
  error: string | null;
}

export function useReports(dateRange: DateRangeOption) {
  const [state, setState] = useState<ReportsState>({
    dashboard: null,
    trend: null,
    costBreakdown: null,
    funnel: null,
    loading: true,
    error: null,
  });

  const abortRef = useRef<AbortController | null>(null);

  const fetchAll = useCallback(async (signal: AbortSignal) => {
    setState((prev) => ({ ...prev, loading: true, error: null }));

    const params = `?range=${dateRange}`;

    try {
      // Parallel fetch all 4 endpoints
      const [dashRes, trendRes, costRes, funnelRes] = await Promise.all([
        safeFetch<DashboardResponse>(`/api/reports/dashboard${params}`, { signal }),
        safeFetch<RevenueTrendResponse>(`/api/reports/revenue-trend${params}`, { signal }),
        safeFetch<CostBreakdownResponse>(`/api/reports/cost-breakdown${params}`, { signal }),
        safeFetch<FunnelResponse>(`/api/reports/funnel${params}`, { signal }),
      ]);

      if (signal.aborted) return;

      // Check for errors
      const firstError = [dashRes, trendRes, costRes, funnelRes].find((r) => r.error);
      if (firstError?.error) {
        setState((prev) => ({ ...prev, loading: false, error: firstError.error }));
        return;
      }

      setState({
        dashboard: dashRes.data,
        trend: trendRes.data,
        costBreakdown: costRes.data,
        funnel: funnelRes.data,
        loading: false,
        error: null,
      });
    } catch {
      if (!signal.aborted) {
        setState((prev) => ({
          ...prev,
          loading: false,
          error: 'Không thể tải dữ liệu báo cáo',
        }));
      }
    }
  }, [dateRange]);

  useEffect(() => {
    abortRef.current?.abort();
    abortRef.current = new AbortController();
    fetchAll(abortRef.current.signal);

    return () => {
      abortRef.current?.abort();
    };
  }, [fetchAll]);

  const refetch = useCallback(() => {
    abortRef.current?.abort();
    abortRef.current = new AbortController();
    fetchAll(abortRef.current.signal);
  }, [fetchAll]);

  return { ...state, refetch };
}
</file>

<file path="src/lib/__mocks__/auth-utils.ts">
/**
 * Mock auth-utils for Jest tests
 * Provides controllable authentication state for testing
 */

import { NextResponse } from 'next/server';
import type { Role, Permission } from '../permissions';

export interface SessionUser {
  id: string;
  email: string;
  name: string | null;
  role: Role;
}

// Default mock user - can be overridden in tests
let mockUser: SessionUser | null = {
  id: 'test-admin-id',
  email: 'admin@test.com',
  name: 'Test Admin',
  role: 'ADMIN',
};

/**
 * Set mock user for tests
 */
export function setMockUser(user: SessionUser | null) {
  mockUser = user;
}

/**
 * Reset mock user to default
 */
export function resetMockUser() {
  mockUser = {
    id: 'test-admin-id',
    email: 'admin@test.com',
    name: 'Test Admin',
    role: 'ADMIN',
  };
}

/**
 * Mock getSessionUser
 */
export async function getSessionUser(): Promise<SessionUser | null> {
  return mockUser;
}

/**
 * Standard 401 Unauthorized response
 */
export function unauthorizedResponse() {
  return NextResponse.json(
    { success: false, error: 'Chưa đăng nhập' },
    { status: 401 }
  );
}

/**
 * Standard 403 Forbidden response
 */
export function forbiddenResponse(message = 'Không có quyền truy cập') {
  return NextResponse.json(
    { success: false, error: message },
    { status: 403 }
  );
}

/**
 * Check if user has permission
 */
export function hasPermission(role: Role, permission: Permission): boolean {
  // Simplified permission check for tests
  if (role === 'ADMIN') return true;
  if (role === 'ACCOUNTANT') {
    return ['operators:lock', 'operators:unlock', 'reports:view'].includes(permission);
  }
  return false;
}

/**
 * Require admin role
 */
export async function requireAdmin() {
  const user = await getSessionUser();
  if (!user) {
    return { error: unauthorizedResponse(), user: null };
  }
  if (user.role !== 'ADMIN') {
    return { error: forbiddenResponse('Chỉ Admin mới có quyền'), user: null };
  }
  return { error: null, user };
}

/**
 * Require accountant or admin role
 */
export async function requireAccountant() {
  const user = await getSessionUser();
  if (!user) {
    return { error: unauthorizedResponse(), user: null };
  }
  if (user.role !== 'ADMIN' && user.role !== 'ACCOUNTANT') {
    return { error: forbiddenResponse('Cần quyền Kế toán'), user: null };
  }
  return { error: null, user };
}

/**
 * Require specific permission
 */
export async function requirePermission(permission: Permission) {
  const user = await getSessionUser();
  if (!user) {
    return { error: unauthorizedResponse(), user: null };
  }
  if (!hasPermission(user.role, permission)) {
    return { error: forbiddenResponse('Không có quyền thực hiện'), user: null };
  }
  return { error: null, user };
}
</file>

<file path="src/lib/api/fetch-utils.ts">
/**
 * Safe fetch utility with standardized error handling.
 * Returns typed response with data, error message, and status code.
 */

export interface FetchResult<T> {
  data: T | null;
  error: string | null;
  status: number;
}

/**
 * HTTP error messages in Vietnamese
 */
const HTTP_ERROR_MESSAGES: Record<number, string> = {
  400: 'Dữ liệu không hợp lệ',
  401: 'Phiên đăng nhập hết hạn',
  403: 'Không có quyền truy cập',
  404: 'Không tìm thấy dữ liệu',
  409: 'Dữ liệu bị xung đột',
  422: 'Dữ liệu không thể xử lý',
  429: 'Quá nhiều yêu cầu, vui lòng thử lại sau',
  500: 'Lỗi máy chủ, vui lòng thử lại',
  502: 'Lỗi kết nối máy chủ',
  503: 'Dịch vụ tạm thời không khả dụng',
  504: 'Máy chủ không phản hồi',
};

/**
 * Get Vietnamese error message for HTTP status code
 */
function getErrorMessage(status: number, statusText?: string): string {
  if (HTTP_ERROR_MESSAGES[status]) {
    return HTTP_ERROR_MESSAGES[status];
  }
  if (status >= 500) {
    return 'Lỗi máy chủ, vui lòng thử lại';
  }
  if (status >= 400) {
    return statusText ? `Lỗi: ${statusText}` : 'Yêu cầu không hợp lệ';
  }
  return 'Đã xảy ra lỗi không xác định';
}

/**
 * Parse error from API response body
 * Attempts to extract error message from JSON response
 */
async function parseErrorFromResponse(res: Response): Promise<string> {
  try {
    const contentType = res.headers.get('content-type');
    if (contentType?.includes('application/json')) {
      const json = await res.json();
      // Handle various API error response formats
      if (json.error) return json.error;
      if (json.message) return json.message;
      if (json.errors && Array.isArray(json.errors)) {
        return json.errors.map((e: { message?: string }) => e.message || e).join(', ');
      }
    }
  } catch {
    // Ignore parse errors, use default message
  }
  return getErrorMessage(res.status, res.statusText);
}

/**
 * Wrapper around fetch with standardized error handling.
 * Returns { data, error, status } instead of throwing.
 *
 * @example
 * const { data, error, status } = await safeFetch<User[]>('/api/users');
 * if (error) {
 *   toast.error(error);
 *   return;
 * }
 * // Use data safely
 */
export async function safeFetch<T>(
  url: string,
  options?: RequestInit
): Promise<FetchResult<T>> {
  try {
    const res = await fetch(url, options);

    if (!res.ok) {
      const errorMessage = await parseErrorFromResponse(res);
      return { data: null, error: errorMessage, status: res.status };
    }

    // Handle empty responses (204 No Content)
    if (res.status === 204) {
      return { data: null, error: null, status: 204 };
    }

    const data = await res.json();

    // Handle API response format: { success: boolean, data: T, error?: string }
    if (typeof data === 'object' && 'success' in data) {
      if (data.success) {
        return { data: data.data as T, error: null, status: res.status };
      } else {
        return {
          data: null,
          error: data.error || 'Yêu cầu không thành công',
          status: res.status,
        };
      }
    }

    // Return raw data if not in API format
    return { data: data as T, error: null, status: res.status };
  } catch (err) {
    // Network error or other unexpected error
    console.error('[safeFetch] Error:', err);
    return {
      data: null,
      error: 'Không thể kết nối đến máy chủ',
      status: 0,
    };
  }
}

/**
 * POST request with JSON body
 */
export async function safePost<T>(
  url: string,
  body: unknown,
  options?: RequestInit
): Promise<FetchResult<T>> {
  return safeFetch<T>(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    body: JSON.stringify(body),
    ...options,
  });
}

/**
 * PUT request with JSON body
 */
export async function safePut<T>(
  url: string,
  body: unknown,
  options?: RequestInit
): Promise<FetchResult<T>> {
  return safeFetch<T>(url, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    body: JSON.stringify(body),
    ...options,
  });
}

/**
 * PATCH request with JSON body
 */
export async function safePatch<T>(
  url: string,
  body: unknown,
  options?: RequestInit
): Promise<FetchResult<T>> {
  return safeFetch<T>(url, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
    body: JSON.stringify(body),
    ...options,
  });
}

/**
 * DELETE request
 */
export async function safeDelete<T>(
  url: string,
  options?: RequestInit
): Promise<FetchResult<T>> {
  return safeFetch<T>(url, {
    method: 'DELETE',
    ...options,
  });
}
</file>

<file path="src/lib/auth-utils.ts">
/**
 * Authentication Utilities for API Routes
 *
 * Provides helper functions to get authenticated user session
 * with proper error handling for API routes.
 *
 * @example
 * import { getSessionUser, requireAdmin } from '@/lib/auth-utils';
 *
 * // In API route:
 * const user = await getSessionUser();
 * if (!user) return unauthorizedResponse();
 *
 * // For admin-only routes:
 * const adminCheck = await requireAdmin();
 * if (adminCheck.error) return adminCheck.error;
 * const user = adminCheck.user;
 */

import { auth } from "@/auth";
import { NextResponse } from "next/server";
import { hasPermission, type Role, type Permission } from "./permissions";

export interface SessionUser {
  id: string;
  email: string;
  name: string | null;
  role: Role;
}

/**
 * Get authenticated user from session
 * Returns null if not authenticated
 */
export async function getSessionUser(): Promise<SessionUser | null> {
  const session = await auth();

  if (!session?.user?.id) {
    return null;
  }

  return {
    id: session.user.id,
    email: session.user.email ?? "",
    name: session.user.name ?? null,
    role: (session.user.role as Role) ?? "SELLER",
  };
}

/**
 * Standard 401 Unauthorized response
 */
export function unauthorizedResponse() {
  return NextResponse.json(
    { success: false, error: "Chưa đăng nhập" },
    { status: 401 }
  );
}

/**
 * Standard 403 Forbidden response
 */
export function forbiddenResponse(message = "Không có quyền truy cập") {
  return NextResponse.json({ success: false, error: message }, { status: 403 });
}

/**
 * Require authenticated user with specific permission
 * Returns user if authorized, or error response if not
 */
export async function requirePermission(permission: Permission): Promise<{
  user: SessionUser | null;
  error: NextResponse | null;
}> {
  const user = await getSessionUser();

  if (!user) {
    return { user: null, error: unauthorizedResponse() };
  }

  if (!hasPermission(user.role, permission)) {
    return { user: null, error: forbiddenResponse() };
  }

  return { user, error: null };
}

/**
 * Require ADMIN role
 * Returns user if admin, or error response if not
 */
export async function requireAdmin(): Promise<{
  user: SessionUser | null;
  error: NextResponse | null;
}> {
  const user = await getSessionUser();

  if (!user) {
    return { user: null, error: unauthorizedResponse() };
  }

  if (user.role !== "ADMIN") {
    return {
      user: null,
      error: forbiddenResponse("Chỉ Admin được thực hiện thao tác này"),
    };
  }

  return { user, error: null };
}
</file>

<file path="src/lib/id-utils.ts">
// ============================================
// ID Generation Utilities for VivaTour
// Centralized ID generators for Request, Operator, Revenue
// ============================================

import { prisma } from './db';

// Vietnamese diacritics removal map
const DIACRITICS_MAP: Record<string, string> = {
  // Uppercase
  'À': 'A', 'Á': 'A', 'Ả': 'A', 'Ã': 'A', 'Ạ': 'A',
  'Ă': 'A', 'Ằ': 'A', 'Ắ': 'A', 'Ẳ': 'A', 'Ẵ': 'A', 'Ặ': 'A',
  'Â': 'A', 'Ầ': 'A', 'Ấ': 'A', 'Ẩ': 'A', 'Ẫ': 'A', 'Ậ': 'A',
  'È': 'E', 'É': 'E', 'Ẻ': 'E', 'Ẽ': 'E', 'Ẹ': 'E',
  'Ê': 'E', 'Ề': 'E', 'Ế': 'E', 'Ể': 'E', 'Ễ': 'E', 'Ệ': 'E',
  'Ì': 'I', 'Í': 'I', 'Ỉ': 'I', 'Ĩ': 'I', 'Ị': 'I',
  'Ò': 'O', 'Ó': 'O', 'Ỏ': 'O', 'Õ': 'O', 'Ọ': 'O',
  'Ô': 'O', 'Ồ': 'O', 'Ố': 'O', 'Ổ': 'O', 'Ỗ': 'O', 'Ộ': 'O',
  'Ơ': 'O', 'Ờ': 'O', 'Ớ': 'O', 'Ở': 'O', 'Ỡ': 'O', 'Ợ': 'O',
  'Ù': 'U', 'Ú': 'U', 'Ủ': 'U', 'Ũ': 'U', 'Ụ': 'U',
  'Ư': 'U', 'Ừ': 'U', 'Ứ': 'U', 'Ử': 'U', 'Ữ': 'U', 'Ự': 'U',
  'Ỳ': 'Y', 'Ý': 'Y', 'Ỷ': 'Y', 'Ỹ': 'Y', 'Ỵ': 'Y',
  'Đ': 'D',
  // Lowercase
  'à': 'a', 'á': 'a', 'ả': 'a', 'ã': 'a', 'ạ': 'a',
  'ă': 'a', 'ằ': 'a', 'ắ': 'a', 'ẳ': 'a', 'ẵ': 'a', 'ặ': 'a',
  'â': 'a', 'ầ': 'a', 'ấ': 'a', 'ẩ': 'a', 'ẫ': 'a', 'ậ': 'a',
  'è': 'e', 'é': 'e', 'ẻ': 'e', 'ẽ': 'e', 'ẹ': 'e',
  'ê': 'e', 'ề': 'e', 'ế': 'e', 'ể': 'e', 'ễ': 'e', 'ệ': 'e',
  'ì': 'i', 'í': 'i', 'ỉ': 'i', 'ĩ': 'i', 'ị': 'i',
  'ò': 'o', 'ó': 'o', 'ỏ': 'o', 'õ': 'o', 'ọ': 'o',
  'ô': 'o', 'ồ': 'o', 'ố': 'o', 'ổ': 'o', 'ỗ': 'o', 'ộ': 'o',
  'ơ': 'o', 'ờ': 'o', 'ớ': 'o', 'ở': 'o', 'ỡ': 'o', 'ợ': 'o',
  'ù': 'u', 'ú': 'u', 'ủ': 'u', 'ũ': 'u', 'ụ': 'u',
  'ư': 'u', 'ừ': 'u', 'ứ': 'u', 'ử': 'u', 'ữ': 'u', 'ự': 'u',
  'ỳ': 'y', 'ý': 'y', 'ỷ': 'y', 'ỹ': 'y', 'ỵ': 'y',
  'đ': 'd',
};

/**
 * Remove Vietnamese diacritics from string
 */
export function removeDiacritics(str: string): string {
  return str
    .split('')
    .map((char) => DIACRITICS_MAP[char] || char)
    .join('');
}

/**
 * Format timestamp for ID generation
 * Format: yyyyMMddHHmmssSSS (17 chars)
 */
export function formatTimestamp(date: Date = new Date()): string {
  const pad = (n: number, len = 2) => n.toString().padStart(len, '0');
  return (
    date.getFullYear().toString() +
    pad(date.getMonth() + 1) +
    pad(date.getDate()) +
    pad(date.getHours()) +
    pad(date.getMinutes()) +
    pad(date.getSeconds()) +
    pad(date.getMilliseconds(), 3)
  );
}

/**
 * Format date portion only
 * Format: yyyyMMdd (8 chars)
 */
export function formatDatePart(date: Date = new Date()): string {
  const pad = (n: number) => n.toString().padStart(2, '0');
  return (
    date.getFullYear().toString() +
    pad(date.getMonth() + 1) +
    pad(date.getDate())
  );
}

/**
 * Generate RequestID
 * Format: {SellerCode}{yyyyMMddHHmmssSSS}
 * Example: LY20260108143045123
 */
export async function generateRequestId(
  sellerCode: string,
  timestamp: Date = new Date()
): Promise<string> {
  const cleanCode = removeDiacritics(sellerCode).toUpperCase().replace(/\s+/g, '');
  const ts = formatTimestamp(timestamp);
  const requestId = `${cleanCode}${ts}`;

  // Verify uniqueness
  const existing = await prisma.request.findUnique({
    where: { requestId },
    select: { id: true },
  });

  if (existing) {
    // Collision - retry with new timestamp
    await new Promise((r) => setTimeout(r, 1));
    return generateRequestId(sellerCode, new Date());
  }

  return requestId;
}

/**
 * Generate ServiceID for Operator
 * Format: {bookingCode}-{yyyyMMddHHmmssSSS}
 * Example: 20260108L0001-20260108143045123
 */
export async function generateServiceId(
  bookingCode: string,
  timestamp: Date = new Date()
): Promise<string> {
  const ts = formatTimestamp(timestamp);
  const serviceId = `${bookingCode}-${ts}`;

  // Verify uniqueness
  const existing = await prisma.operator.findUnique({
    where: { serviceId },
    select: { id: true },
  });

  if (existing) {
    await new Promise((r) => setTimeout(r, 1));
    return generateServiceId(bookingCode, new Date());
  }

  return serviceId;
}

/**
 * Generate RevenueID
 * Format: {bookingCode}-{yyyyMMddHHmmss}-{rowNum}
 * Example: 20260108L0001-20260108143045-1
 */
export async function generateRevenueId(
  bookingCode: string,
  timestamp: Date = new Date()
): Promise<string> {
  const pad = (n: number) => n.toString().padStart(2, '0');
  const dateTime =
    timestamp.getFullYear().toString() +
    pad(timestamp.getMonth() + 1) +
    pad(timestamp.getDate()) +
    pad(timestamp.getHours()) +
    pad(timestamp.getMinutes()) +
    pad(timestamp.getSeconds());

  const prefix = `${bookingCode}-${dateTime}`;

  // Get max row number for this prefix
  const existing = await prisma.revenue.findMany({
    where: { revenueId: { startsWith: prefix } },
    select: { revenueId: true },
  });

  const rowNum = existing.length + 1;
  return `${prefix}-${rowNum}`;
}
</file>

<file path="src/lib/lock-utils.ts">
// ============================================
// Lock System Utilities for VivaTour
// 3-tier lock: KT (Accountant) → Admin → Final
// ============================================

import type { Role } from '@prisma/client';

// Lock tier definitions
export const LOCK_TIERS = ['KT', 'Admin', 'Final'] as const;
export type LockTier = (typeof LOCK_TIERS)[number];

// Lock tier order (for progression validation)
export const LOCK_TIER_ORDER: Record<LockTier, number> = {
  KT: 1,
  Admin: 2,
  Final: 3,
};

// Permissions per tier per action
export const LOCK_PERMISSIONS: Record<
  LockTier,
  { lock: Role[]; unlock: Role[] }
> = {
  KT: {
    lock: ['ACCOUNTANT', 'ADMIN'],
    unlock: ['ACCOUNTANT', 'ADMIN'],
  },
  Admin: {
    lock: ['ADMIN'],
    unlock: ['ADMIN'],
  },
  Final: {
    lock: ['ADMIN'],
    unlock: ['ADMIN'],
  },
};

/**
 * Check if role can perform lock action on tier
 */
export function canLock(role: Role, tier: LockTier): boolean {
  return LOCK_PERMISSIONS[tier].lock.includes(role);
}

/**
 * Check if role can perform unlock action on tier
 */
export function canUnlock(role: Role, tier: LockTier): boolean {
  return LOCK_PERMISSIONS[tier].unlock.includes(role);
}

/**
 * Lock state interface matching DB fields
 */
export interface LockState {
  lockKT: boolean;
  lockAdmin: boolean;
  lockFinal: boolean;
}

/**
 * Get current highest lock tier from record
 */
export function getCurrentLockTier(state: LockState): LockTier | null {
  if (state.lockFinal) return 'Final';
  if (state.lockAdmin) return 'Admin';
  if (state.lockKT) return 'KT';
  return null;
}

/**
 * Check if next tier can be locked (sequential progression)
 */
export function canLockTier(state: LockState, tier: LockTier): boolean {
  const tierOrder = LOCK_TIER_ORDER[tier];

  // For tier 1 (KT), always can lock if not already locked
  if (tierOrder === 1) {
    return !state.lockKT;
  }

  // For tier 2 (Admin), tier 1 must be locked
  if (tierOrder === 2) {
    return state.lockKT && !state.lockAdmin;
  }

  // For tier 3 (Final), tier 2 must be locked
  if (tierOrder === 3) {
    return state.lockAdmin && !state.lockFinal;
  }

  return false;
}

/**
 * Check if tier can be unlocked (reverse order)
 */
export function canUnlockTier(state: LockState, tier: LockTier): boolean {
  const tierOrder = LOCK_TIER_ORDER[tier];

  // For tier 3 (Final), can unlock if locked
  if (tierOrder === 3) {
    return state.lockFinal;
  }

  // For tier 2 (Admin), tier 3 must be unlocked first
  if (tierOrder === 2) {
    return state.lockAdmin && !state.lockFinal;
  }

  // For tier 1 (KT), tier 2 must be unlocked first
  if (tierOrder === 1) {
    return state.lockKT && !state.lockAdmin;
  }

  return false;
}

/**
 * Check if record is editable (no locks applied)
 */
export function isEditable(state: LockState): boolean {
  return !state.lockKT && !state.lockAdmin && !state.lockFinal;
}

/**
 * Get lock tier fields for database update
 */
export function getLockFields(
  tier: LockTier,
  userId: string,
  lock: boolean
): Record<string, boolean | Date | string | null> {
  const now = new Date();
  const tierKey = `lock${tier}`;

  if (lock) {
    return {
      [tierKey]: true,
      [`${tierKey}At`]: now,
      [`${tierKey}By`]: userId,
    };
  } else {
    return {
      [tierKey]: false,
      [`${tierKey}At`]: null,
      [`${tierKey}By`]: null,
    };
  }
}

/**
 * Get history action name for lock operation
 */
export function getLockHistoryAction(tier: LockTier, lock: boolean): string {
  return lock ? `LOCK_${tier.toUpperCase()}` : `UNLOCK_${tier.toUpperCase()}`;
}

/**
 * Get all active lock tiers for a record
 */
export function getActiveLockTiers(state: LockState): LockTier[] {
  const tiers: LockTier[] = [];
  if (state.lockKT) tiers.push('KT');
  if (state.lockAdmin) tiers.push('Admin');
  if (state.lockFinal) tiers.push('Final');
  return tiers;
}

/**
 * Check if any lock is active
 */
export function hasAnyLock(state: LockState): boolean {
  return state.lockKT || state.lockAdmin || state.lockFinal;
}
</file>

<file path="src/lib/permissions.ts">
/**
 * Permission System
 *
 * RBAC (Role-Based Access Control) configuration for MyVivaTour.
 * Defines permissions per role using resource:action naming convention.
 *
 * @example
 * import { hasPermission } from "@/lib/permissions";
 * hasPermission("SELLER", "request:create"); // true
 * hasPermission("SELLER", "revenue:manage"); // false
 */

export type Role = "ADMIN" | "SELLER" | "OPERATOR" | "ACCOUNTANT";

export type Permission =
  // Request permissions
  | "request:view"
  | "request:create"
  | "request:edit"
  | "request:edit_own"
  | "request:delete"
  // Operator permissions
  | "operator:view"
  | "operator:create"
  | "operator:edit"
  | "operator:edit_claimed"
  | "operator:claim"
  | "operator:approve"
  | "operator:delete"
  // Revenue permissions
  | "revenue:view"
  | "revenue:manage"
  // Expense permissions
  | "expense:view"
  | "expense:manage"
  // Supplier permissions
  | "supplier:view"
  | "supplier:manage"
  // User permissions
  | "user:view"
  | "user:manage"
  // Wildcard (admin only)
  | "*";

/**
 * Role-Permission mapping
 *
 * ADMIN: Full access via wildcard
 * SELLER: Request management (own), operator viewing
 * OPERATOR: Claim and edit claimed operators
 * ACCOUNTANT: Revenue, expense, supplier management + operator approval
 */
export const PERMISSIONS: Record<Role, Permission[]> = {
  ADMIN: ["*"],
  SELLER: [
    "request:view",
    "request:create",
    "request:edit_own",
    "operator:view",
  ],
  OPERATOR: [
    "request:view",
    "operator:view",
    "operator:claim",
    "operator:edit_claimed",
  ],
  ACCOUNTANT: [
    "request:view",
    "operator:view",
    "operator:approve",
    "revenue:view",
    "revenue:manage",
    "expense:view",
    "expense:manage",
    "supplier:view",
    "supplier:manage",
  ],
};

/**
 * Check if a role has a specific permission
 *
 * @param role - User role
 * @param permission - Permission to check
 * @returns true if role has permission (ADMIN always returns true)
 */
export function hasPermission(role: Role, permission: Permission): boolean {
  const permissions = PERMISSIONS[role];

  // Safety check
  if (!permissions) {
    return false;
  }

  // ADMIN with wildcard has all permissions
  if (permissions.includes("*")) {
    return true;
  }

  return permissions.includes(permission);
}

/**
 * Get all permissions for a role
 *
 * @param role - User role
 * @returns Array of permissions (empty if role not found)
 */
export function getPermissions(role: Role): Permission[] {
  return PERMISSIONS[role] || [];
}
</file>

<file path="src/lib/revenue-history.ts">
// ============================================
// Revenue History Utility
// Creates audit trail entries for revenue operations
// ============================================

import { prisma } from './db';
import type { Prisma } from '@prisma/client';

// History action types
export const REVENUE_HISTORY_ACTIONS = {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOCK_KT: 'LOCK_KT',
  UNLOCK_KT: 'UNLOCK_KT',
  LOCK_ADMIN: 'LOCK_ADMIN',
  UNLOCK_ADMIN: 'UNLOCK_ADMIN',
  LOCK_FINAL: 'LOCK_FINAL',
  UNLOCK_FINAL: 'UNLOCK_FINAL',
} as const;

export type RevenueHistoryAction =
  (typeof REVENUE_HISTORY_ACTIONS)[keyof typeof REVENUE_HISTORY_ACTIONS];

// Input interface
export interface RevenueHistoryInput {
  revenueId: string;
  action: RevenueHistoryAction;
  changes: Record<string, { before?: unknown; after?: unknown }>;
  userId: string;
}

/**
 * Create revenue history entry
 */
export async function createRevenueHistory(input: RevenueHistoryInput) {
  return prisma.revenueHistory.create({
    data: {
      revenueId: input.revenueId,
      action: input.action,
      changes: input.changes as Prisma.InputJsonValue,
      userId: input.userId,
    },
  });
}

/**
 * Get revenue history with user names
 */
export async function getRevenueHistory(revenueId: string) {
  const history = await prisma.revenueHistory.findMany({
    where: { revenueId },
    orderBy: { createdAt: 'desc' },
  });

  // Fetch unique user IDs
  const userIds = Array.from(new Set(history.map((h) => h.userId)));
  const users = await prisma.user.findMany({
    where: { id: { in: userIds } },
    select: { id: true, name: true },
  });

  const userMap = new Map(users.map((u) => [u.id, u.name]));

  // Merge user names
  return history.map((h) => ({
    ...h,
    userName: userMap.get(h.userId) || 'Unknown',
  }));
}
</file>

<file path="src/lib/utils/parse-utils.ts">
/**
 * Safe parsing utilities for type coercion in forms and inputs.
 * Handles undefined, null, empty strings, and NaN values safely.
 */

/**
 * Safely parse a value to integer with default fallback.
 * @param value - Value to parse (string, number, undefined, or null)
 * @param defaultValue - Default value if parsing fails (default: 0)
 * @returns Parsed integer or default value
 */
export function safeParseInt(
  value: string | number | undefined | null,
  defaultValue = 0
): number {
  if (value === undefined || value === null || value === '') {
    return defaultValue;
  }
  const parsed = typeof value === 'number' ? Math.floor(value) : parseInt(String(value), 10);
  return isNaN(parsed) ? defaultValue : parsed;
}

/**
 * Safely parse a value to float with default fallback.
 * @param value - Value to parse (string, number, undefined, or null)
 * @param defaultValue - Default value if parsing fails (default: 0)
 * @returns Parsed float or default value
 */
export function safeParseFloat(
  value: string | number | undefined | null,
  defaultValue = 0
): number {
  if (value === undefined || value === null || value === '') {
    return defaultValue;
  }
  const parsed = typeof value === 'number' ? value : parseFloat(String(value));
  return isNaN(parsed) ? defaultValue : parsed;
}

/**
 * Safely parse a value to positive integer (>= 1).
 * Useful for fields like "pax", "quantity", etc.
 * @param value - Value to parse
 * @param defaultValue - Default value if parsing fails or result <= 0 (default: 1)
 * @returns Parsed positive integer or default value
 */
export function safePositiveInt(
  value: string | number | undefined | null,
  defaultValue = 1
): number {
  const parsed = safeParseInt(value, defaultValue);
  return parsed > 0 ? parsed : defaultValue;
}

/**
 * Safely parse a value to non-negative float (>= 0).
 * Useful for fields like "cost", "price", etc.
 * @param value - Value to parse
 * @param defaultValue - Default value if parsing fails or result < 0 (default: 0)
 * @returns Parsed non-negative float or default value
 */
export function safeNonNegativeFloat(
  value: string | number | undefined | null,
  defaultValue = 0
): number {
  const parsed = safeParseFloat(value, defaultValue);
  return parsed >= 0 ? parsed : defaultValue;
}

/**
 * Parse optional integer - returns undefined instead of default for empty values.
 * Useful for optional number fields in forms.
 */
export function parseOptionalInt(
  value: string | number | undefined | null
): number | undefined {
  if (value === undefined || value === null || value === '') {
    return undefined;
  }
  const parsed = typeof value === 'number' ? Math.floor(value) : parseInt(String(value), 10);
  return isNaN(parsed) ? undefined : parsed;
}

/**
 * Parse optional float - returns undefined instead of default for empty values.
 */
export function parseOptionalFloat(
  value: string | number | undefined | null
): number | undefined {
  if (value === undefined || value === null || value === '') {
    return undefined;
  }
  const parsed = typeof value === 'number' ? value : parseFloat(String(value));
  return isNaN(parsed) ? undefined : parsed;
}
</file>

<file path="src/lib/validations/config-validation.ts">
import { z } from 'zod';

// Seller validation schema
export const sellerSchema = z.object({
  telegramId: z.string().min(1, 'Telegram ID không được trống'),
  sellerName: z.string().min(1, 'Tên seller không được trống'),
  sheetName: z.string().min(1, 'Tên sheet không được trống'),
  metaName: z.string().optional().nullable(),
  email: z.string().email('Email không hợp lệ').optional().nullable().or(z.literal('')),
  gender: z.enum(['MALE', 'FEMALE'], { message: 'Giới tính không hợp lệ' }),
  sellerCode: z
    .string()
    .min(1, 'Mã seller không được trống')
    .max(2, 'Mã seller tối đa 2 ký tự')
    .regex(/^[A-Z]{1,2}$/, 'Mã seller phải là 1-2 ký tự in hoa (A-Z)'),
  isActive: z.boolean().optional().default(true),
});

// FollowUpStatus validation schema
export const followUpStatusSchema = z.object({
  status: z.string().min(1, 'Tên trạng thái không được trống'),
  aliases: z.array(z.string()).default([]),
  daysToFollowup: z.number().int().min(0, 'Số ngày phải >= 0'),
  sortOrder: z.number().int().min(0).optional(),
  isActive: z.boolean().optional().default(true),
});

// Reorder schema for batch sortOrder update
export const reorderSchema = z.object({
  items: z
    .array(
      z.object({
        id: z.string(),
        sortOrder: z.number().int().min(0),
      })
    )
    .min(1, 'Cần ít nhất 1 item'),
});

// Inferred types
export type SellerFormData = z.infer<typeof sellerSchema>;
export type FollowUpStatusFormData = z.infer<typeof followUpStatusSchema>;
export type ReorderData = z.infer<typeof reorderSchema>;

// Transform empty strings to null for optional fields
export function transformSellerData(data: SellerFormData) {
  return {
    ...data,
    metaName: data.metaName || null,
    email: data.email || null,
  };
}
</file>

<file path="src/lib/validations/report-validation.ts">
import { z } from 'zod';

// Fixed date range options
export const DATE_RANGE_OPTIONS = [
  'thisMonth',
  'lastMonth',
  'last3Months',
  'last6Months',
  'thisYear'
] as const;

export type DateRangeOption = typeof DATE_RANGE_OPTIONS[number];

// Query params schema
export const reportQuerySchema = z.object({
  range: z.enum(DATE_RANGE_OPTIONS, {
    message: 'Khoang thoi gian khong hop le'
  }).default('thisMonth'),
});

export type ReportQueryParams = z.infer<typeof reportQuerySchema>;

// Extract errors helper
export function extractReportZodErrors(error: z.ZodError): Record<string, string> {
  const errors: Record<string, string> = {};
  for (const issue of error.issues) {
    const field = issue.path.join('.');
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }
  return errors;
}
</file>

<file path="src/lib/validations/revenue-validation.ts">
import { z } from 'zod';
import {
  PAYMENT_TYPE_KEYS,
  PAYMENT_SOURCE_KEYS,
  CURRENCY_KEYS,
  type PaymentTypeKey,
  type PaymentSourceKey,
  type CurrencyKey,
} from '@/config/revenue-config';

// ============================================
// Revenue Form Validation Schema
// Vietnamese error messages for user-facing forms
// ============================================

// Enum validators from config
const paymentTypeEnum = z.enum(PAYMENT_TYPE_KEYS as [PaymentTypeKey, ...PaymentTypeKey[]], {
  message: 'Loai thanh toan khong hop le',
});

const paymentSourceEnum = z.enum(PAYMENT_SOURCE_KEYS as [PaymentSourceKey, ...PaymentSourceKey[]], {
  message: 'Nguon thanh toan khong hop le',
});

const currencyEnum = z.enum(CURRENCY_KEYS as [CurrencyKey, ...CurrencyKey[]], {
  message: 'Loai tien te khong hop le',
});

// Date string validator
const dateStringRequired = z
  .string({ message: 'Ngay la bat buoc' })
  .refine((val) => val && !isNaN(Date.parse(val)), { message: 'Ngay khong hop le' });

// ============================================
// API Schemas
// ============================================

// Create Revenue API Schema
export const createRevenueApiSchema = z
  .object({
    requestId: z
      .string({ message: 'Booking la bat buoc' })
      .min(1, 'Vui long chon Booking'),
    paymentDate: dateStringRequired,
    paymentType: paymentTypeEnum,
    paymentSource: paymentSourceEnum,
    currency: currencyEnum.default('VND'),
    foreignAmount: z
      .number({ message: 'So tien ngoai te phai la so' })
      .positive('So tien ngoai te phai > 0')
      .optional()
      .nullable(),
    exchangeRate: z
      .number({ message: 'Ty gia phai la so' })
      .positive('Ty gia phai > 0')
      .optional()
      .nullable(),
    amountVND: z
      .number({ message: 'So tien VND phai la so' })
      .positive('So tien VND phai > 0')
      .optional(),
    notes: z
      .string()
      .max(1000, 'Ghi chu khong duoc qua 1000 ky tu')
      .optional()
      .nullable(),
  })
  // Foreign currency validation: foreignAmount and exchangeRate required when not VND
  .refine(
    (data) => {
      if (data.currency !== 'VND') {
        return data.foreignAmount && data.foreignAmount > 0;
      }
      return true;
    },
    {
      message: 'So tien ngoai te la bat buoc khi dung ngoai te',
      path: ['foreignAmount'],
    }
  )
  .refine(
    (data) => {
      if (data.currency !== 'VND') {
        return data.exchangeRate && data.exchangeRate > 0;
      }
      return true;
    },
    {
      message: 'Ty gia la bat buoc khi dung ngoai te',
      path: ['exchangeRate'],
    }
  )
  // VND amount validation: required when currency is VND
  .refine(
    (data) => {
      if (data.currency === 'VND') {
        return data.amountVND && data.amountVND > 0;
      }
      return true;
    },
    {
      message: 'So tien VND phai > 0',
      path: ['amountVND'],
    }
  );

// Update Revenue API Schema (partial - all fields optional)
export const updateRevenueApiSchema = z
  .object({
    paymentDate: z
      .string()
      .refine((val) => !isNaN(Date.parse(val)), { message: 'Ngay khong hop le' })
      .optional(),
    paymentType: paymentTypeEnum.optional(),
    paymentSource: paymentSourceEnum.optional(),
    currency: currencyEnum.optional(),
    foreignAmount: z
      .number()
      .positive('So tien ngoai te phai > 0')
      .optional()
      .nullable(),
    exchangeRate: z
      .number()
      .positive('Ty gia phai > 0')
      .optional()
      .nullable(),
    amountVND: z
      .number()
      .positive('So tien VND phai > 0')
      .optional(),
    notes: z
      .string()
      .max(1000, 'Ghi chu khong duoc qua 1000 ky tu')
      .optional()
      .nullable(),
  });

// ============================================
// Type Exports
// ============================================

export type CreateRevenueApiData = z.infer<typeof createRevenueApiSchema>;
export type UpdateRevenueApiData = z.infer<typeof updateRevenueApiSchema>;

// Error type for form validation
export interface RevenueFormErrors {
  requestId?: string;
  paymentDate?: string;
  paymentType?: string;
  paymentSource?: string;
  currency?: string;
  foreignAmount?: string;
  exchangeRate?: string;
  amountVND?: string;
  notes?: string;
  _form?: string;
}

// ============================================
// Validation Functions
// ============================================

/**
 * Extract field errors from Zod error for API response
 */
export function extractRevenueZodErrors(error: z.ZodError): Record<string, string> {
  const errors: Record<string, string> = {};
  for (const issue of error.issues) {
    const field = issue.path.join('.');
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }
  return errors;
}

/**
 * Validate create revenue data
 */
export function validateCreateRevenue(data: unknown): {
  success: boolean;
  data?: CreateRevenueApiData;
  errors?: Record<string, string>;
} {
  const result = createRevenueApiSchema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, errors: extractRevenueZodErrors(result.error) };
}

/**
 * Validate update revenue data
 */
export function validateUpdateRevenue(data: unknown): {
  success: boolean;
  data?: UpdateRevenueApiData;
  errors?: Record<string, string>;
} {
  const result = updateRevenueApiSchema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  return { success: false, errors: extractRevenueZodErrors(result.error) };
}
</file>

<file path="src/lib/validations/seller-validation.ts">
import { z } from 'zod';

// Seller form validation schema
export const sellerSchema = z.object({
  telegramId: z.string().min(1, 'Telegram ID không được trống'),
  sellerName: z.string().min(1, 'Tên seller không được trống'),
  sheetName: z.string().min(1, 'Tên sheet không được trống'),
  metaName: z.string().optional().nullable(),
  email: z.string().email('Email không hợp lệ').optional().nullable().or(z.literal('')),
  gender: z.enum(['MALE', 'FEMALE'], { message: 'Giới tính không hợp lệ' }),
  sellerCode: z
    .string()
    .min(1, 'Mã seller không được trống')
    .max(2, 'Mã seller tối đa 2 ký tự')
    .regex(/^[A-Z]{1,2}$/, 'Mã seller phải là 1-2 ký tự in hoa (A-Z)'),
  isActive: z.boolean().optional().default(true),
});

export type SellerFormData = z.infer<typeof sellerSchema>;

// Transform empty strings to null for optional fields
export function transformSellerData(data: SellerFormData) {
  return {
    ...data,
    metaName: data.metaName || null,
    email: data.email || null,
  };
}
</file>

<file path="src/proxy.ts">
/**
 * Authentication & Authorization Proxy (Edge Runtime)
 *
 * Next.js 16+ proxy.ts convention for route protection.
 * Uses edge-compatible auth config (no DB/bcrypt imports).
 * Authorization logic is in auth.config.ts authorized() callback.
 *
 * @see https://nextjs.org/docs/messages/middleware-to-proxy
 */
import NextAuth from "next-auth";
import { authConfig } from "./auth.config";

// Use edge-compatible config - authorization handled by authorized() callback
export default NextAuth(authConfig).auth;

export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization)
     * - favicon.ico (favicon)
     * - public folder
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
</file>

<file path="src/__tests__/api/operator-approvals.test.ts">
/**
 * @jest-environment node
 */

// Tests for Operator Approval API routes
// Covers: GET /api/operators/pending-payments, POST /api/operators/approve, POST /api/operators/[id]/approve

import { NextRequest } from 'next/server';
import { prismaMock } from '@/lib/__mocks__/db';
import { setMockUser, resetMockUser } from '@/lib/__mocks__/auth-utils';

// Mock the db module
jest.mock('@/lib/db', () => ({
  prisma: prismaMock,
}));

// Mock auth-utils to avoid next-auth ESM import issues
jest.mock('@/lib/auth-utils');

// Mock operator history
jest.mock('@/lib/operator-history', () => ({
  createOperatorHistory: jest.fn().mockResolvedValue({}),
}));

import { GET } from '@/app/api/operators/pending-payments/route';
import { POST as batchApprove } from '@/app/api/operators/approve/route';
import { POST as singleApprove } from '@/app/api/operators/[id]/approve/route';

// Helper to create mock NextRequest
function createMockRequest(url: string, options?: { method?: string; body?: string }): NextRequest {
  return new NextRequest(new URL(url, 'http://localhost:3000'), options as never);
}

describe('GET /api/operators/pending-payments', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  const mockOperator = {
    id: 'op-1',
    requestId: 'req-1',
    supplierId: 'sup-1',
    serviceDate: new Date('2026-01-10'),
    serviceType: 'HOTEL',
    serviceName: 'Hotel Room',
    supplier: 'Hotel ABC',
    costBeforeTax: 1000000,
    vat: 100000,
    totalCost: 1100000,
    paymentDeadline: new Date('2026-01-05'),
    paymentStatus: 'PENDING',
    paymentDate: null,
    bankAccount: null,
    isLocked: false,
    lockedAt: null,
    lockedBy: null,
    notes: null,
    userId: 'user-1',
    sheetRowIndex: null,
    createdAt: new Date(),
    updatedAt: new Date(),
    request: { code: '260110-JOHN-US', customerName: 'John Doe' },
    supplierRef: { code: 'HOT-DN-ABC-0001', name: 'Hotel ABC' },
  };

  it('should return pending payments with success', async () => {
    prismaMock.operator.findMany.mockResolvedValue([mockOperator] as never);

    const request = createMockRequest('http://localhost:3000/api/operators/pending-payments');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data).toHaveLength(1);
    expect(data.summary).toBeDefined();
    expect(data.summary.total).toBe(1);
  });

  it('should filter by overdue', async () => {
    prismaMock.operator.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/operators/pending-payments?filter=overdue');
    await GET(request);

    expect(prismaMock.operator.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          paymentDeadline: expect.objectContaining({ lt: expect.any(Date) }),
        }),
      })
    );
  });

  it('should filter by today', async () => {
    prismaMock.operator.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/operators/pending-payments?filter=today');
    await GET(request);

    expect(prismaMock.operator.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          paymentDeadline: expect.objectContaining({
            gte: expect.any(Date),
            lt: expect.any(Date),
          }),
        }),
      })
    );
  });

  it('should filter by week', async () => {
    prismaMock.operator.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/operators/pending-payments?filter=week');
    await GET(request);

    expect(prismaMock.operator.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          paymentDeadline: expect.objectContaining({
            gte: expect.any(Date),
            lt: expect.any(Date),
          }),
        }),
      })
    );
  });

  it('should filter by serviceType', async () => {
    prismaMock.operator.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/operators/pending-payments?serviceType=HOTEL');
    await GET(request);

    expect(prismaMock.operator.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          serviceType: 'HOTEL',
        }),
      })
    );
  });

  it('should calculate daysOverdue correctly', async () => {
    const overdueDate = new Date();
    overdueDate.setDate(overdueDate.getDate() - 5);

    prismaMock.operator.findMany.mockResolvedValue([
      { ...mockOperator, paymentDeadline: overdueDate },
    ] as never);

    const request = createMockRequest('http://localhost:3000/api/operators/pending-payments');
    const response = await GET(request);
    const data = await response.json();

    expect(data.data[0].daysOverdue).toBe(5);
  });

  it('should return correct summary', async () => {
    const overdueDate = new Date();
    overdueDate.setDate(overdueDate.getDate() - 3);

    const todayDate = new Date();
    todayDate.setHours(0, 0, 0, 0);

    prismaMock.operator.findMany.mockResolvedValue([
      { ...mockOperator, id: 'op-1', paymentDeadline: overdueDate, totalCost: 1000000 },
      { ...mockOperator, id: 'op-2', paymentDeadline: todayDate, totalCost: 2000000 },
    ] as never);

    const request = createMockRequest('http://localhost:3000/api/operators/pending-payments');
    const response = await GET(request);
    const data = await response.json();

    expect(data.summary.total).toBe(2);
    expect(data.summary.overdue).toBe(1);
    expect(data.summary.dueToday).toBe(1);
  });

  it('should return 500 on database error', async () => {
    prismaMock.operator.findMany.mockRejectedValue(new Error('Database error'));

    const request = createMockRequest('http://localhost:3000/api/operators/pending-payments');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.success).toBe(false);
  });
});

describe('POST /api/operators/approve (batch)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  const mockOperator = {
    id: 'op-1',
    requestId: 'req-1',
    supplierId: 'sup-1',
    serviceDate: new Date(),
    serviceType: 'HOTEL',
    serviceName: 'Hotel Room',
    supplier: 'Hotel ABC',
    costBeforeTax: 1000000,
    vat: 100000,
    totalCost: 1000000,
    paymentDeadline: new Date(),
    paymentStatus: 'PENDING',
    paymentDate: null,
    bankAccount: null,
    isLocked: false,
    lockedAt: null,
    lockedBy: null,
    notes: null,
    userId: 'user-1',
    sheetRowIndex: null,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  it('should batch approve operators successfully', async () => {
    prismaMock.operator.findMany.mockResolvedValue([
      { ...mockOperator, id: 'op-1' },
      { ...mockOperator, id: 'op-2' },
    ] as never);

    (prismaMock.$transaction as jest.Mock).mockImplementation(async (fn: (tx: unknown) => Promise<unknown>) => {
      return fn({
        operator: {
          update: jest.fn().mockResolvedValue({ ...mockOperator, paymentStatus: 'PAID' }),
        },
        operatorHistory: {
          create: jest.fn().mockResolvedValue({}),
        },
      });
    });

    const request = createMockRequest('http://localhost:3000/api/operators/approve', {
      method: 'POST',
      body: JSON.stringify({
        operatorIds: ['op-1', 'op-2'],
        paymentDate: new Date().toISOString(),
        userId: 'user-1',
      }),
    });

    const response = await batchApprove(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
  });

  it('should return 400 when no operatorIds provided', async () => {
    const request = createMockRequest('http://localhost:3000/api/operators/approve', {
      method: 'POST',
      body: JSON.stringify({
        operatorIds: [],
        paymentDate: new Date().toISOString(),
      }),
    });

    const response = await batchApprove(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toContain('Vui lòng chọn ít nhất 1 dịch vụ');
  });

  it('should return 400 when paymentDate is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/operators/approve', {
      method: 'POST',
      body: JSON.stringify({
        operatorIds: ['op-1'],
      }),
    });

    const response = await batchApprove(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toContain('Vui lòng chọn ngày thanh toán');
  });

  it('should return 404 when some operators not found', async () => {
    prismaMock.operator.findMany.mockResolvedValue([mockOperator] as never);

    const request = createMockRequest('http://localhost:3000/api/operators/approve', {
      method: 'POST',
      body: JSON.stringify({
        operatorIds: ['op-1', 'op-2'], // op-2 doesn't exist
        paymentDate: new Date().toISOString(),
      }),
    });

    const response = await batchApprove(request);
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.error).toContain('Một số dịch vụ không tồn tại');
  });

  it('should return 403 when trying to approve locked operators', async () => {
    prismaMock.operator.findMany.mockResolvedValue([
      { ...mockOperator, isLocked: true },
    ] as never);

    const request = createMockRequest('http://localhost:3000/api/operators/approve', {
      method: 'POST',
      body: JSON.stringify({
        operatorIds: ['op-1'],
        paymentDate: new Date().toISOString(),
      }),
    });

    const response = await batchApprove(request);
    const data = await response.json();

    expect(response.status).toBe(403);
    expect(data.error).toContain('đã khóa');
  });
});

describe('POST /api/operators/[id]/approve (single)', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  const mockOperator = {
    id: 'op-1',
    requestId: 'req-1',
    supplierId: 'sup-1',
    serviceDate: new Date(),
    serviceType: 'HOTEL',
    serviceName: 'Hotel Room',
    supplier: 'Hotel ABC',
    costBeforeTax: 1000000,
    vat: 100000,
    totalCost: 1000000,
    paymentDeadline: new Date(),
    paymentStatus: 'PENDING',
    paymentDate: null,
    bankAccount: null,
    isLocked: false,
    lockedAt: null,
    lockedBy: null,
    notes: null,
    userId: 'user-1',
    sheetRowIndex: null,
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const mockParams = Promise.resolve({ id: 'op-1' });

  it('should approve single operator successfully', async () => {
    prismaMock.operator.findUnique.mockResolvedValue(mockOperator as never);
    prismaMock.operator.update.mockResolvedValue({
      ...mockOperator,
      paymentStatus: 'PAID',
      paymentDate: new Date(),
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/approve', {
      method: 'POST',
      body: JSON.stringify({
        paymentDate: new Date().toISOString(),
        userId: 'user-1',
      }),
    });

    const response = await singleApprove(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.paymentStatus).toBe('PAID');
  });

  it('should return 404 when operator not found', async () => {
    prismaMock.operator.findUnique.mockResolvedValue(null);

    const request = createMockRequest('http://localhost:3000/api/operators/op-999/approve', {
      method: 'POST',
      body: JSON.stringify({}),
    });

    const response = await singleApprove(request, { params: Promise.resolve({ id: 'op-999' }) });
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.error).toContain('không tồn tại');
  });

  it('should return 403 when operator is locked', async () => {
    prismaMock.operator.findUnique.mockResolvedValue({
      ...mockOperator,
      isLocked: true,
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/approve', {
      method: 'POST',
      body: JSON.stringify({}),
    });

    const response = await singleApprove(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(403);
    expect(data.error).toContain('đã khóa');
  });

  it('should return 400 when already paid', async () => {
    prismaMock.operator.findUnique.mockResolvedValue({
      ...mockOperator,
      paymentStatus: 'PAID',
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/approve', {
      method: 'POST',
      body: JSON.stringify({}),
    });

    const response = await singleApprove(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toContain('đã được thanh toán');
  });

  it('should use current date when paymentDate not provided', async () => {
    prismaMock.operator.findUnique.mockResolvedValue(mockOperator as never);
    prismaMock.operator.update.mockResolvedValue({
      ...mockOperator,
      paymentStatus: 'PAID',
      paymentDate: new Date(),
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/approve', {
      method: 'POST',
      body: JSON.stringify({}),
    });

    await singleApprove(request, { params: mockParams });

    expect(prismaMock.operator.update).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          paymentDate: expect.any(Date),
        }),
      })
    );
  });
});
</file>

<file path="src/__tests__/api/reports.test.ts">
/**
 * @jest-environment node
 */

// Tests for Report API routes
// Covers: GET /api/reports/dashboard, revenue-trend, cost-breakdown, funnel

import { NextRequest } from 'next/server';
import { prismaMock } from '@/lib/__mocks__/db';

// Mock database
jest.mock('@/lib/db', () => ({
  prisma: prismaMock,
}));

// Mock auth
const mockSession = {
  user: {
    id: 'user-123',
    email: 'test@example.com',
    role: 'ADMIN'
  }
};

jest.mock('@/auth', () => ({
  auth: jest.fn(() => Promise.resolve(mockSession)),
}));

import { auth } from '@/auth';

// Type-safe auth mock - use jest.Mock for flexible mocking
const mockAuth = auth as jest.Mock;

function createMockRequest(url: string): NextRequest {
  return new NextRequest(new URL(url, 'http://localhost:3000'));
}

// ============================================
// Dashboard Endpoint Tests
// ============================================

describe('GET /api/reports/dashboard', () => {
  let GET: any;

  beforeAll(() => {
    const module = require('@/app/api/reports/dashboard/route');
    GET = module.GET;
  });

  beforeEach(() => {
    jest.clearAllMocks();
    mockAuth.mockResolvedValue(mockSession as any);
  });

  describe('Authentication & Authorization', () => {
    it('should return 401 when unauthenticated', async () => {
      mockAuth.mockResolvedValue(null as any);

      const request = createMockRequest('http://localhost:3000/api/reports/dashboard');
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(401);
      expect(data.success).toBe(false);
    });

    it('should return 403 for SELLER role (no revenue:view)', async () => {
      mockAuth.mockResolvedValue({
        user: { id: 'user-123', role: 'SELLER' }
      } as any);

      const request = createMockRequest('http://localhost:3000/api/reports/dashboard');
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(403);
      expect(data.success).toBe(false);
    });

    it('should return 403 for OPERATOR role (no revenue:view)', async () => {
      mockAuth.mockResolvedValue({
        user: { id: 'user-123', role: 'OPERATOR' }
      } as any);

      const request = createMockRequest('http://localhost:3000/api/reports/dashboard');
      const response = await GET(request);

      expect(response.status).toBe(403);
    });
  });

  describe('Query Validation', () => {
    it('should return 400 for invalid range parameter', async () => {
      const request = createMockRequest(
        'http://localhost:3000/api/reports/dashboard?range=invalidRange'
      );
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.success).toBe(false);
    });

    it('should accept valid thisMonth range', async () => {
      // Setup mocks for successful query
      prismaMock.request.count.mockResolvedValue(10 as never);
      prismaMock.revenue.aggregate.mockResolvedValue({
        _sum: { amountVND: 5000000 }
      } as never);
      prismaMock.operator.aggregate.mockResolvedValue({
        _sum: { totalCost: 2000000 }
      } as never);

      const request = createMockRequest(
        'http://localhost:3000/api/reports/dashboard?range=thisMonth'
      );
      const response = await GET(request);

      expect(response.status).toBe(200);
    });

    it('should accept valid lastMonth range', async () => {
      prismaMock.request.count.mockResolvedValue(8 as never);
      prismaMock.revenue.aggregate.mockResolvedValue({
        _sum: { amountVND: 4000000 }
      } as never);
      prismaMock.operator.aggregate.mockResolvedValue({
        _sum: { totalCost: 1500000 }
      } as never);

      const request = createMockRequest(
        'http://localhost:3000/api/reports/dashboard?range=lastMonth'
      );
      const response = await GET(request);

      expect(response.status).toBe(200);
    });
  });

  describe('Response Structure', () => {
    beforeEach(() => {
      // Setup default mocks
      prismaMock.request.count.mockResolvedValue(50 as never);
      prismaMock.revenue.aggregate.mockResolvedValue({
        _sum: { amountVND: 10000000 }
      } as never);
      prismaMock.operator.aggregate.mockResolvedValue({
        _sum: { totalCost: 3000000 }
      } as never);
    });

    it('should return valid dashboard response with all required fields', async () => {
      const request = createMockRequest('http://localhost:3000/api/reports/dashboard');
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data).toHaveProperty('success', true);
      expect(data).toHaveProperty('data');
      expect(data.data).toHaveProperty('kpiCards');
      expect(data.data).toHaveProperty('comparison');
      expect(data.data).toHaveProperty('dateRange');
    });

    it('should include all KPI card metrics', async () => {
      const request = createMockRequest('http://localhost:3000/api/reports/dashboard');
      const response = await GET(request);
      const data = await response.json();

      const kpis = data.data.kpiCards;
      expect(kpis).toHaveProperty('totalBookings');
      expect(kpis).toHaveProperty('totalRevenue');
      expect(kpis).toHaveProperty('totalProfit');
      expect(kpis).toHaveProperty('activeRequests');
      expect(kpis).toHaveProperty('conversionRate');

      // Validate types
      expect(typeof kpis.totalBookings).toBe('number');
      expect(typeof kpis.totalRevenue).toBe('number');
      expect(typeof kpis.totalProfit).toBe('number');
    });

    it('should calculate profit as revenue minus cost', async () => {
      const request = createMockRequest('http://localhost:3000/api/reports/dashboard');
      const response = await GET(request);
      const data = await response.json();

      expect(data.data.kpiCards.totalProfit).toBe(10000000 - 3000000);
    });

    it('should include comparison metrics with changePercent', async () => {
      const request = createMockRequest('http://localhost:3000/api/reports/dashboard');
      const response = await GET(request);
      const data = await response.json();

      const comparison = data.data.comparison;
      expect(comparison).toHaveProperty('bookings');
      expect(comparison).toHaveProperty('revenue');

      expect(comparison.bookings).toHaveProperty('current');
      expect(comparison.bookings).toHaveProperty('previous');
      expect(comparison.bookings).toHaveProperty('changePercent');
    });

    it('should include dateRange with startDate, endDate and label', async () => {
      const request = createMockRequest('http://localhost:3000/api/reports/dashboard');
      const response = await GET(request);
      const data = await response.json();

      const dr = data.data.dateRange;
      expect(dr).toHaveProperty('startDate');
      expect(dr).toHaveProperty('endDate');
      expect(dr).toHaveProperty('label');
      expect(typeof dr.label).toBe('string');
    });
  });
});

// ============================================
// Revenue Trend Endpoint Tests
// ============================================

describe('GET /api/reports/revenue-trend', () => {
  let GET: any;

  beforeAll(() => {
    const module = require('@/app/api/reports/revenue-trend/route');
    GET = module.GET;
  });

  beforeEach(() => {
    jest.clearAllMocks();
    mockAuth.mockResolvedValue(mockSession as any);
  });

  it('should return 401 when unauthenticated', async () => {
    mockAuth.mockResolvedValue(null as any);

    const request = createMockRequest('http://localhost:3000/api/reports/revenue-trend');
    const response = await GET(request);

    expect(response.status).toBe(401);
  });

  it('should return 403 for SELLER role', async () => {
    mockAuth.mockResolvedValue({
      user: { id: 'user-123', role: 'SELLER' }
    } as any);

    const request = createMockRequest('http://localhost:3000/api/reports/revenue-trend');
    const response = await GET(request);

    expect(response.status).toBe(403);
  });

  it('should return 400 for invalid range parameter', async () => {
    const request = createMockRequest(
      'http://localhost:3000/api/reports/revenue-trend?range=invalid'
    );
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(400);
  });

  it('should return valid response with summary and data array', async () => {
    prismaMock.revenue.findMany.mockResolvedValue([
      { paymentDate: new Date('2026-01-15'), amountVND: 5000000 }
    ] as never);

    prismaMock.operator.findMany.mockResolvedValue([
      { serviceDate: new Date('2026-01-15'), totalCost: 2000000 }
    ] as never);

    const request = createMockRequest('http://localhost:3000/api/reports/revenue-trend');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(Array.isArray(data.data.data)).toBe(true);
    expect(data.data).toHaveProperty('summary');
    expect(data.data.summary).toHaveProperty('totalRevenue');
    expect(data.data.summary).toHaveProperty('totalCost');
    expect(data.data.summary).toHaveProperty('totalProfit');
    expect(data.data.summary).toHaveProperty('avgMonthly');
  });

  it('should group data points by period', async () => {
    prismaMock.revenue.findMany.mockResolvedValue([
      { paymentDate: new Date('2026-01-15'), amountVND: 1000000 },
      { paymentDate: new Date('2026-02-15'), amountVND: 2000000 }
    ] as never);

    prismaMock.operator.findMany.mockResolvedValue([
      { serviceDate: new Date('2026-01-10'), totalCost: 500000 }
    ] as never);

    const request = createMockRequest('http://localhost:3000/api/reports/revenue-trend');
    const response = await GET(request);
    const data = await response.json();

    expect(data.data.data.length).toBeGreaterThan(0);
    expect(data.data.data[0]).toHaveProperty('period');
    expect(data.data.data[0]).toHaveProperty('revenue');
    expect(data.data.data[0]).toHaveProperty('cost');
    expect(data.data.data[0]).toHaveProperty('profit');
  });
});

// ============================================
// Cost Breakdown Endpoint Tests
// ============================================

describe('GET /api/reports/cost-breakdown', () => {
  let GET: any;

  beforeAll(() => {
    const module = require('@/app/api/reports/cost-breakdown/route');
    GET = module.GET;
  });

  beforeEach(() => {
    jest.clearAllMocks();
    mockAuth.mockResolvedValue(mockSession as any);
  });

  it('should return 401 when unauthenticated', async () => {
    mockAuth.mockResolvedValue(null as any);

    const request = createMockRequest('http://localhost:3000/api/reports/cost-breakdown');
    const response = await GET(request);

    expect(response.status).toBe(401);
  });

  it('should return 403 for OPERATOR role', async () => {
    mockAuth.mockResolvedValue({
      user: { id: 'user-123', role: 'OPERATOR' }
    } as any);

    const request = createMockRequest('http://localhost:3000/api/reports/cost-breakdown');
    const response = await GET(request);

    expect(response.status).toBe(403);
  });

  it('should return 400 for invalid range parameter', async () => {
    const request = createMockRequest(
      'http://localhost:3000/api/reports/cost-breakdown?range=badRange'
    );
    const response = await GET(request);

    expect(response.status).toBe(400);
  });

  it('should return valid cost breakdown response', async () => {
    prismaMock.operator.findMany.mockResolvedValue([
      { serviceType: 'ACCOMMODATION', totalCost: 3000000, paymentStatus: 'PAID' },
      { serviceType: 'TRANSPORTATION', totalCost: 2000000, paymentStatus: 'UNPAID' }
    ] as never);

    const request = createMockRequest('http://localhost:3000/api/reports/cost-breakdown');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data).toHaveProperty('byServiceType');
    expect(data.data).toHaveProperty('paymentStatus');
    expect(data.data).toHaveProperty('dateRange');

    expect(Array.isArray(data.data.byServiceType)).toBe(true);
    expect(data.data.byServiceType[0]).toHaveProperty('type');
    expect(data.data.byServiceType[0]).toHaveProperty('amount');
    expect(data.data.byServiceType[0]).toHaveProperty('percentage');
  });

  it('should aggregate payment status correctly', async () => {
    prismaMock.operator.findMany.mockResolvedValue([
      { serviceType: 'ACCOMMODATION', totalCost: 2000000, paymentStatus: 'PAID' },
      { serviceType: 'ACCOMMODATION', totalCost: 1000000, paymentStatus: 'PARTIAL' },
      { serviceType: 'TRANSPORTATION', totalCost: 3000000, paymentStatus: 'UNPAID' }
    ] as never);

    const request = createMockRequest('http://localhost:3000/api/reports/cost-breakdown');
    const response = await GET(request);
    const data = await response.json();

    expect(data.data.paymentStatus.paid).toBe(2000000);
    expect(data.data.paymentStatus.partial).toBe(1000000);
    expect(data.data.paymentStatus.unpaid).toBe(3000000);
  });

  it('should calculate percentage by service type', async () => {
    prismaMock.operator.findMany.mockResolvedValue([
      { serviceType: 'ACCOMMODATION', totalCost: 4000000, paymentStatus: 'PAID' },
      { serviceType: 'TRANSPORTATION', totalCost: 6000000, paymentStatus: 'UNPAID' }
    ] as never);

    const request = createMockRequest('http://localhost:3000/api/reports/cost-breakdown');
    const response = await GET(request);
    const data = await response.json();

    // Check percentages
    const breakdown = data.data.byServiceType;
    const totalCost = 10000000;
    expect(breakdown[0].percentage).toBe(60); // 6M / 10M
    expect(breakdown[1].percentage).toBe(40); // 4M / 10M
  });
});

// ============================================
// Funnel Endpoint Tests
// ============================================

describe('GET /api/reports/funnel', () => {
  let GET: any;

  beforeAll(() => {
    const module = require('@/app/api/reports/funnel/route');
    GET = module.GET;
  });

  beforeEach(() => {
    jest.clearAllMocks();
    mockAuth.mockResolvedValue(mockSession as any);
  });

  it('should return 401 when unauthenticated', async () => {
    mockAuth.mockResolvedValue(null as any);

    const request = createMockRequest('http://localhost:3000/api/reports/funnel');
    const response = await GET(request);

    expect(response.status).toBe(401);
  });

  it('should return 403 for SELLER role', async () => {
    mockAuth.mockResolvedValue({
      user: { id: 'user-123', role: 'SELLER' }
    } as any);

    const request = createMockRequest('http://localhost:3000/api/reports/funnel');
    const response = await GET(request);

    expect(response.status).toBe(403);
  });

  it('should return 400 for invalid range parameter', async () => {
    const request = createMockRequest(
      'http://localhost:3000/api/reports/funnel?range=wrongRange'
    );
    const response = await GET(request);

    expect(response.status).toBe(400);
  });

  it('should return valid funnel response with all stages', async () => {
    prismaMock.request.groupBy.mockResolvedValue([
      { stage: 'LEAD', _count: { id: 100 } },
      { stage: 'QUOTE', _count: { id: 50 } }
    ] as never);

    prismaMock.request.count.mockResolvedValue(10 as never);

    const request = createMockRequest('http://localhost:3000/api/reports/funnel');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data).toHaveProperty('stages');
    expect(data.data).toHaveProperty('conversionRate');
    expect(data.data).toHaveProperty('dateRange');

    expect(Array.isArray(data.data.stages)).toBe(true);
    expect(data.data.stages.length).toBe(4); // LEAD, QUOTE, FOLLOWUP, OUTCOME
  });

  it('should include all funnel stages in correct order', async () => {
    prismaMock.request.groupBy.mockResolvedValue([
      { stage: 'OUTCOME', _count: { id: 10 } },
      { stage: 'LEAD', _count: { id: 100 } }
    ] as never);

    prismaMock.request.count.mockResolvedValue(10 as never);

    const request = createMockRequest('http://localhost:3000/api/reports/funnel');
    const response = await GET(request);
    const data = await response.json();

    const stageNames = data.data.stages.map((s: any) => s.stage);
    expect(stageNames).toEqual(['LEAD', 'QUOTE', 'FOLLOWUP', 'OUTCOME']);
  });

  it('should include count and percentage for each stage', async () => {
    prismaMock.request.groupBy.mockResolvedValue([
      { stage: 'LEAD', _count: { id: 100 } },
      { stage: 'QUOTE', _count: { id: 50 } }
    ] as never);

    prismaMock.request.count.mockResolvedValue(50 as never); // conversions

    const request = createMockRequest('http://localhost:3000/api/reports/funnel');
    const response = await GET(request);
    const data = await response.json();

    const lead = data.data.stages.find((s: any) => s.stage === 'LEAD');
    const quote = data.data.stages.find((s: any) => s.stage === 'QUOTE');

    expect(lead).toHaveProperty('count', 100);
    expect(lead).toHaveProperty('percentage');
    expect(quote).toHaveProperty('count', 50);
    expect(quote).toHaveProperty('percentage');
  });

  it('should calculate conversion rate correctly', async () => {
    prismaMock.request.groupBy.mockResolvedValue([
      { stage: 'LEAD', _count: { id: 100 } }
    ] as never);

    prismaMock.request.count.mockResolvedValue(20 as never); // 20 bookings out of 100 = 20%

    const request = createMockRequest('http://localhost:3000/api/reports/funnel');
    const response = await GET(request);
    const data = await response.json();

    expect(data.data.conversionRate).toBe(20);
  });

  it('should handle stages with zero count', async () => {
    prismaMock.request.groupBy.mockResolvedValue([
      { stage: 'LEAD', _count: { id: 100 } }
      // QUOTE, FOLLOWUP, OUTCOME have no records
    ] as never);

    prismaMock.request.count.mockResolvedValue(10 as never);

    const request = createMockRequest('http://localhost:3000/api/reports/funnel');
    const response = await GET(request);
    const data = await response.json();

    // All 4 stages should be present
    expect(data.data.stages.length).toBe(4);

    // QUOTE, FOLLOWUP, OUTCOME should have count 0
    const empty = data.data.stages.filter((s: any) => ['QUOTE', 'FOLLOWUP', 'OUTCOME'].includes(s.stage));
    empty.forEach((s: any) => {
      expect(s.count).toBe(0);
    });
  });
});
</file>

<file path="src/__tests__/api/supplier-transactions.test.ts">
/**
 * @jest-environment node
 */

// Tests for Supplier Transaction API routes validation and error handling
// Covers: GET /api/supplier-transactions, POST /api/supplier-transactions

import { NextRequest } from 'next/server';
import { prismaMock } from '@/lib/__mocks__/db';
import type { SupplierTransaction, TransactionType } from '@prisma/client';

// Mock Decimal type for test data
class MockDecimal {
  private value: number;
  constructor(value: number | string) {
    this.value = typeof value === 'string' ? parseFloat(value) : value;
  }
  toNumber() { return this.value; }
  toString() { return this.value.toString(); }
}
// Use local mock class to avoid Prisma runtime import issues
const Decimal = MockDecimal;

// Mock the db module
jest.mock('@/lib/db', () => ({
  prisma: prismaMock,
}));

// Mock auth-utils to avoid next-auth ESM import issues
jest.mock('@/lib/auth-utils');

import { GET, POST } from '@/app/api/supplier-transactions/route';

// Helper to create mock NextRequest
function createMockRequest(url: string, options?: RequestInit): NextRequest {
  return new NextRequest(new URL(url, 'http://localhost:3000'), options as never);
}

// Type for transaction with supplier relation
type TransactionWithSupplier = SupplierTransaction & {
  supplier: { code: string; name: string };
};

describe('GET /api/supplier-transactions', () => {
  const mockTransactions = [
    {
      id: 'tx-1',
      supplierId: 'sup-1',
      type: 'DEPOSIT' as TransactionType,
      amount: new Decimal(5000000) as never,
      transactionDate: new Date('2024-01-15'),
      description: 'Monthly deposit',
      proofLink: 'https://example.com/receipt.pdf',
      relatedBookingCode: null,
      createdBy: 'admin',
      createdAt: new Date(),
      supplier: {
        code: 'HOT-DN-ABC-0001',
        name: 'Hotel ABC',
      },
    },
  ] as TransactionWithSupplier[];

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return all transactions with success response', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue(mockTransactions);
    prismaMock.supplierTransaction.count.mockResolvedValue(1);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data).toHaveLength(1);
    expect(data.total).toBe(1);
    expect(data.hasMore).toBe(false);
  });

  it('should filter by supplierId', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue([]);
    prismaMock.supplierTransaction.count.mockResolvedValue(0);

    const request = createMockRequest(
      'http://localhost:3000/api/supplier-transactions?supplierId=sup-1'
    );
    await GET(request);

    expect(prismaMock.supplierTransaction.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({ supplierId: 'sup-1' }),
      })
    );
  });

  it('should filter by transaction type', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue([]);
    prismaMock.supplierTransaction.count.mockResolvedValue(0);

    const request = createMockRequest(
      'http://localhost:3000/api/supplier-transactions?type=DEPOSIT'
    );
    await GET(request);

    expect(prismaMock.supplierTransaction.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({ type: 'DEPOSIT' }),
      })
    );
  });

  it('should filter by date range (fromDate only)', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue([]);
    prismaMock.supplierTransaction.count.mockResolvedValue(0);

    const request = createMockRequest(
      'http://localhost:3000/api/supplier-transactions?fromDate=2024-01-01'
    );
    await GET(request);

    expect(prismaMock.supplierTransaction.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          transactionDate: { gte: new Date('2024-01-01') },
        }),
      })
    );
  });

  it('should filter by date range (toDate only)', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue([]);
    prismaMock.supplierTransaction.count.mockResolvedValue(0);

    const request = createMockRequest(
      'http://localhost:3000/api/supplier-transactions?toDate=2024-12-31'
    );
    await GET(request);

    expect(prismaMock.supplierTransaction.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          transactionDate: { lte: new Date('2024-12-31') },
        }),
      })
    );
  });

  it('should filter by date range (both fromDate and toDate)', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue([]);
    prismaMock.supplierTransaction.count.mockResolvedValue(0);

    const request = createMockRequest(
      'http://localhost:3000/api/supplier-transactions?fromDate=2024-01-01&toDate=2024-12-31'
    );
    await GET(request);

    expect(prismaMock.supplierTransaction.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        where: expect.objectContaining({
          transactionDate: {
            gte: new Date('2024-01-01'),
            lte: new Date('2024-12-31'),
          },
        }),
      })
    );
  });

  it('should paginate with limit and offset', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue([]);
    prismaMock.supplierTransaction.count.mockResolvedValue(100);

    const request = createMockRequest(
      'http://localhost:3000/api/supplier-transactions?limit=20&offset=40'
    );
    await GET(request);

    expect(prismaMock.supplierTransaction.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        take: 20,
        skip: 40,
      })
    );
  });

  it('should default limit to 50', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue([]);
    prismaMock.supplierTransaction.count.mockResolvedValue(0);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions');
    await GET(request);

    expect(prismaMock.supplierTransaction.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        take: 50,
        skip: 0,
      })
    );
  });

  it('should return hasMore=true when more records exist', async () => {
    const transactions = Array(20).fill(mockTransactions[0]);
    prismaMock.supplierTransaction.findMany.mockResolvedValue(transactions);
    prismaMock.supplierTransaction.count.mockResolvedValue(100);

    const request = createMockRequest(
      'http://localhost:3000/api/supplier-transactions?limit=20&offset=0'
    );
    const response = await GET(request);
    const data = await response.json();

    expect(data.hasMore).toBe(true);
    expect(data.total).toBe(100);
  });

  it('should include supplier details in response', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue(mockTransactions);
    prismaMock.supplierTransaction.count.mockResolvedValue(1);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions');
    const response = await GET(request);
    const data = await response.json();

    expect(data.data[0].supplier).toBeDefined();
    expect(data.data[0].supplier.code).toBe('HOT-DN-ABC-0001');
  });

  it('should order by transactionDate desc', async () => {
    prismaMock.supplierTransaction.findMany.mockResolvedValue([]);
    prismaMock.supplierTransaction.count.mockResolvedValue(0);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions');
    await GET(request);

    expect(prismaMock.supplierTransaction.findMany).toHaveBeenCalledWith(
      expect.objectContaining({
        orderBy: { transactionDate: 'desc' },
      })
    );
  });

  it('should return 500 on database error', async () => {
    prismaMock.supplierTransaction.findMany.mockRejectedValue(
      new Error('Database connection failed')
    );

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.success).toBe(false);
    expect(data.error).toBe('Failed to fetch transactions');
  });
});

describe('POST /api/supplier-transactions', () => {
  const validTransactionData = {
    supplierId: 'sup-1',
    type: 'DEPOSIT',
    amount: 5000000,
    transactionDate: '2024-01-15',
    description: 'Monthly deposit',
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should create transaction with valid data', async () => {
    const createdTransaction = {
      id: 'tx-new',
      supplierId: 'sup-1',
      type: 'DEPOSIT' as TransactionType,
      amount: new Decimal(5000000) as never,
      transactionDate: new Date('2024-01-15'),
      description: 'Monthly deposit',
      proofLink: null,
      relatedBookingCode: null,
      createdBy: 'system',
      createdAt: new Date(),
      supplier: {
        code: 'HOT-DN-ABC-0001',
        name: 'Hotel ABC',
      },
    } as TransactionWithSupplier;

    prismaMock.supplier.findUnique.mockResolvedValue({ id: 'sup-1' } as never);
    prismaMock.supplierTransaction.create.mockResolvedValue(createdTransaction);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify(validTransactionData),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    expect(data.success).toBe(true);
    expect(data.data.type).toBe('DEPOSIT');
    // Amount may be Decimal object or number depending on serialization
    expect(Number(data.data.amount.value ?? data.data.amount)).toBe(5000000);
  });

  it('should return 400 when supplierId is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        type: 'DEPOSIT',
        amount: 5000000,
        transactionDate: '2024-01-15',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Missing required fields');
  });

  it('should return 400 when type is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        supplierId: 'sup-1',
        amount: 5000000,
        transactionDate: '2024-01-15',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Missing required fields');
  });

  it('should return 400 when amount is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        supplierId: 'sup-1',
        type: 'DEPOSIT',
        transactionDate: '2024-01-15',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Missing required fields');
  });

  it('should return 400 when transactionDate is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        supplierId: 'sup-1',
        type: 'DEPOSIT',
        amount: 5000000,
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Missing required fields');
  });

  it('should return 400 when amount is zero', async () => {
    // Note: In JS, 0 is falsy, so the required fields check fails first
    // This test verifies that amount=0 is rejected (either as missing or non-positive)
    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        ...validTransactionData,
        amount: 0,
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    // Amount 0 is falsy, so it fails the required fields check
    expect(data.error).toContain('Missing required fields');
  });

  it('should return 400 when amount is negative', async () => {
    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        ...validTransactionData,
        amount: -1000,
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toBe('Amount must be positive');
  });

  describe('transaction type validation', () => {
    const validTypes = ['DEPOSIT', 'REFUND', 'ADJUSTMENT', 'FEE'];

    validTypes.forEach((type) => {
      it(`should accept valid type: ${type}`, async () => {
        prismaMock.supplier.findUnique.mockResolvedValue({ id: 'sup-1' } as never);
        prismaMock.supplierTransaction.create.mockResolvedValue({
          id: 'tx-new',
          type,
          amount: 1000,
          supplier: { code: 'TEST', name: 'Test' },
        } as never);

        const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
          method: 'POST',
          body: JSON.stringify({
            ...validTransactionData,
            type,
          }),
        });

        const response = await POST(request);
        expect(response.status).toBe(201);
      });
    });

    it('should return 400 for invalid type', async () => {
      const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
        method: 'POST',
        body: JSON.stringify({
          ...validTransactionData,
          type: 'INVALID_TYPE',
        }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.success).toBe(false);
      expect(data.error).toContain('Invalid type');
      expect(data.error).toContain('DEPOSIT, REFUND, ADJUSTMENT, FEE');
    });
  });

  it('should return 404 when supplier not found', async () => {
    prismaMock.supplier.findUnique.mockResolvedValue(null);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        ...validTransactionData,
        supplierId: 'non-existent',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.success).toBe(false);
    expect(data.error).toBe('Supplier not found');
  });

  it('should convert amount to number', async () => {
    prismaMock.supplier.findUnique.mockResolvedValue({ id: 'sup-1' } as never);
    prismaMock.supplierTransaction.create.mockResolvedValue({
      id: 'tx-new',
      amount: 5000000,
      supplier: { code: 'TEST', name: 'Test' },
    } as never);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        ...validTransactionData,
        amount: '5000000', // String instead of number
      }),
    });

    await POST(request);

    expect(prismaMock.supplierTransaction.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          amount: 5000000, // Should be converted to number
        }),
      })
    );
  });

  it('should parse transactionDate as Date', async () => {
    prismaMock.supplier.findUnique.mockResolvedValue({ id: 'sup-1' } as never);
    prismaMock.supplierTransaction.create.mockResolvedValue({
      id: 'tx-new',
      transactionDate: new Date('2024-01-15'),
      supplier: { code: 'TEST', name: 'Test' },
    } as never);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify(validTransactionData),
    });

    await POST(request);

    expect(prismaMock.supplierTransaction.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          transactionDate: new Date('2024-01-15'),
        }),
      })
    );
  });

  it('should use authenticated user ID as createdBy', async () => {
    prismaMock.supplier.findUnique.mockResolvedValue({ id: 'sup-1' } as never);
    prismaMock.supplierTransaction.create.mockResolvedValue({
      id: 'tx-new',
      createdBy: 'test-admin-id', // From mock auth-utils
      supplier: { code: 'TEST', name: 'Test' },
    } as never);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify(validTransactionData),
    });

    await POST(request);

    // createdBy should be set from authenticated user, not from body
    expect(prismaMock.supplierTransaction.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          createdBy: 'test-admin-id',
        }),
      })
    );
  });

  it('should ignore body createdBy and use authenticated user', async () => {
    prismaMock.supplier.findUnique.mockResolvedValue({ id: 'sup-1' } as never);
    prismaMock.supplierTransaction.create.mockResolvedValue({
      id: 'tx-new',
      createdBy: 'test-admin-id',
      supplier: { code: 'TEST', name: 'Test' },
    } as never);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        ...validTransactionData,
        createdBy: 'admin', // This should be ignored
      }),
    });

    await POST(request);

    // Should use authenticated user ID, not the provided createdBy
    expect(prismaMock.supplierTransaction.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          createdBy: 'test-admin-id',
        }),
      })
    );
  });

  it('should include optional fields when provided', async () => {
    prismaMock.supplier.findUnique.mockResolvedValue({ id: 'sup-1' } as never);
    prismaMock.supplierTransaction.create.mockResolvedValue({
      id: 'tx-new',
      proofLink: 'https://example.com/receipt.pdf',
      relatedBookingCode: 'BK-001',
      supplier: { code: 'TEST', name: 'Test' },
    } as never);

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify({
        ...validTransactionData,
        proofLink: 'https://example.com/receipt.pdf',
        relatedBookingCode: 'BK-001',
      }),
    });

    await POST(request);

    expect(prismaMock.supplierTransaction.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          proofLink: 'https://example.com/receipt.pdf',
          relatedBookingCode: 'BK-001',
        }),
      })
    );
  });

  it('should return 500 on database error', async () => {
    prismaMock.supplier.findUnique.mockResolvedValue({ id: 'sup-1' } as never);
    prismaMock.supplierTransaction.create.mockRejectedValue(new Error('Database write failed'));

    const request = createMockRequest('http://localhost:3000/api/supplier-transactions', {
      method: 'POST',
      body: JSON.stringify(validTransactionData),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.success).toBe(false);
    expect(data.error).toBe('Failed to create transaction');
  });
});
</file>

<file path="src/__tests__/api/suppliers.test.ts">
/**
 * @jest-environment node
 */

// Tests for Supplier API routes validation and error handling
// Covers: GET /api/suppliers, POST /api/suppliers

import { NextRequest } from 'next/server';
import { prismaMock } from '@/lib/__mocks__/db';
import type { Supplier } from '@prisma/client';

// Mock the db module
jest.mock('@/lib/db', () => ({
  prisma: prismaMock,
}));

// Mock auth-utils to avoid next-auth ESM import issues
jest.mock('@/lib/auth-utils');

// Mock supplier-balance module
jest.mock('@/lib/supplier-balance', () => ({
  calculateSupplierBalance: jest.fn().mockResolvedValue({
    deposits: 1000000,
    refunds: 0,
    adjustments: 0,
    fees: 0,
    costs: 0,
    balance: 1000000,
  }),
}));

import { GET, POST } from '@/app/api/suppliers/route';

// Helper to create mock NextRequest
function createMockRequest(url: string, options?: RequestInit): NextRequest {
  return new NextRequest(new URL(url, 'http://localhost:3000'), options as never);
}

describe('GET /api/suppliers', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return all suppliers with success response', async () => {
    const mockSuppliers: Supplier[] = [
      {
        id: 'sup-1',
        code: 'HOT-DN-ABC-0001',
        name: 'Hotel ABC',
        type: 'HOTEL',
        location: 'DA_NANG',
        paymentModel: 'PREPAID',
        creditLimit: null,
        paymentTermDays: null,
        contactName: 'John',
        contactPhone: '123456789',
        contactEmail: 'john@abc.com',
        bankAccount: null,
        isActive: true,
        notes: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ];

    prismaMock.supplier.findMany.mockResolvedValue(mockSuppliers);

    const request = createMockRequest('http://localhost:3000/api/suppliers');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data).toHaveLength(1);
    expect(data.data[0].code).toBe('HOT-DN-ABC-0001');
  });

  it('should filter by search term (code or name)', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/suppliers?search=hotel');
    await GET(request);

    expect(prismaMock.supplier.findMany).toHaveBeenCalledWith({
      where: {
        OR: [
          { code: { contains: 'hotel', mode: 'insensitive' } },
          { name: { contains: 'hotel', mode: 'insensitive' } },
        ],
      },
      orderBy: { code: 'asc' },
    });
  });

  it('should filter by type', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/suppliers?type=HOTEL');
    await GET(request);

    expect(prismaMock.supplier.findMany).toHaveBeenCalledWith({
      where: { type: 'HOTEL' },
      orderBy: { code: 'asc' },
    });
  });

  it('should filter by location', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/suppliers?location=DA_NANG');
    await GET(request);

    expect(prismaMock.supplier.findMany).toHaveBeenCalledWith({
      where: { location: 'DA_NANG' },
      orderBy: { code: 'asc' },
    });
  });

  it('should filter by paymentModel', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/suppliers?paymentModel=CREDIT');
    await GET(request);

    expect(prismaMock.supplier.findMany).toHaveBeenCalledWith({
      where: { paymentModel: 'CREDIT' },
      orderBy: { code: 'asc' },
    });
  });

  it('should filter by isActive=true', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/suppliers?isActive=true');
    await GET(request);

    expect(prismaMock.supplier.findMany).toHaveBeenCalledWith({
      where: { isActive: true },
      orderBy: { code: 'asc' },
    });
  });

  it('should filter by isActive=false', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/suppliers?isActive=false');
    await GET(request);

    expect(prismaMock.supplier.findMany).toHaveBeenCalledWith({
      where: { isActive: false },
      orderBy: { code: 'asc' },
    });
  });

  it('should handle multiple filters combined', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);

    const request = createMockRequest(
      'http://localhost:3000/api/suppliers?type=HOTEL&location=DA_NANG&isActive=true'
    );
    await GET(request);

    expect(prismaMock.supplier.findMany).toHaveBeenCalledWith({
      where: {
        type: 'HOTEL',
        location: 'DA_NANG',
        isActive: true,
      },
      orderBy: { code: 'asc' },
    });
  });

  it('should include balance when includeBalance=true', async () => {
    const mockSupplier: Supplier = {
      id: 'sup-1',
      code: 'HOT-DN-ABC-0001',
      name: 'Hotel ABC',
      type: 'HOTEL',
      location: 'DA_NANG',
      paymentModel: 'PREPAID',
      creditLimit: null,
      paymentTermDays: null,
      contactName: null,
      contactPhone: null,
      contactEmail: null,
      bankAccount: null,
      isActive: true,
      notes: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    prismaMock.supplier.findMany.mockResolvedValue([mockSupplier]);

    const request = createMockRequest('http://localhost:3000/api/suppliers?includeBalance=true');
    const response = await GET(request);
    const data = await response.json();

    expect(data.success).toBe(true);
    expect(data.data[0].balance).toBe(1000000);
  });

  it('should return 500 on database error', async () => {
    prismaMock.supplier.findMany.mockRejectedValue(new Error('Database connection failed'));

    const request = createMockRequest('http://localhost:3000/api/suppliers');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Failed to fetch suppliers');
  });

  it('should return empty array when no suppliers found', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);

    const request = createMockRequest('http://localhost:3000/api/suppliers');
    const response = await GET(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data).toEqual([]);
  });
});

describe('POST /api/suppliers', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should create supplier with valid data', async () => {
    const newSupplier: Supplier = {
      id: 'sup-new',
      code: 'HOT-DN-ANK-0001',
      name: 'Ankora Hotel',
      type: 'HOTEL',
      location: 'DA_NANG',
      paymentModel: 'PREPAID',
      creditLimit: null,
      paymentTermDays: null,
      contactName: 'Manager',
      contactPhone: '0905123456',
      contactEmail: 'manager@ankora.com',
      bankAccount: null,
      isActive: true,
      notes: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    prismaMock.supplier.findMany.mockResolvedValue([]);
    prismaMock.supplier.findUnique.mockResolvedValue(null);
    prismaMock.supplier.create.mockResolvedValue(newSupplier);

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Ankora Hotel',
        type: 'HOTEL',
        location: 'DA_NANG',
        contactName: 'Manager',
        contactPhone: '0905123456',
        contactEmail: 'manager@ankora.com',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    expect(data.success).toBe(true);
    expect(data.data.code).toBe('HOT-DN-ANK-0001');
  });

  it('should return 400 when name is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        type: 'HOTEL',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Thiếu thông tin bắt buộc');
  });

  it('should return 400 when type is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Test Supplier',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Thiếu thông tin bắt buộc');
  });

  it('should return 400 for invalid supplier type', async () => {
    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Test Supplier',
        type: 'INVALID_TYPE',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Loại NCC không hợp lệ');
  });

  it('should return 400 when code already exists', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);
    prismaMock.supplier.findUnique.mockResolvedValue({
      id: 'existing',
      code: 'HOT-DN-ANK-0001',
    } as never);

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Ankora Hotel',
        type: 'HOTEL',
        code: 'HOT-DN-ANK-0001',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Mã NCC đã tồn tại');
  });

  it('should auto-generate code when not provided', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);
    prismaMock.supplier.findUnique.mockResolvedValue(null);
    prismaMock.supplier.create.mockResolvedValue({
      id: 'sup-new',
      code: 'HOT-XX-TES-0001',
      name: 'Test Hotel',
      type: 'HOTEL',
      paymentModel: 'PREPAID',
      isActive: true,
    } as never);

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Test Hotel',
        type: 'HOTEL',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    expect(data.success).toBe(true);
    // Code should be auto-generated
    expect(prismaMock.supplier.create).toHaveBeenCalled();
  });

  it('should increment sequence for existing prefix', async () => {
    // Simulate existing supplier with sequence 0005
    prismaMock.supplier.findMany.mockResolvedValue([
      { code: 'HOT-DN-TES-0005' },
    ] as never);
    prismaMock.supplier.findUnique.mockResolvedValue(null);
    (prismaMock.supplier.create as jest.Mock).mockResolvedValue({
      id: 'sup-new',
      code: 'HOT-DN-TES-0006',
      name: 'Test Hotel',
      type: 'HOTEL',
      location: 'DA_NANG',
      paymentModel: 'PREPAID',
      isActive: true,
      creditLimit: null,
      contact: null,
      address: null,
      note: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Test Hotel',
        type: 'HOTEL',
        location: 'DA_NANG',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    // Code should have sequence 0006
    expect(data.data.code).toContain('0006');
  });

  it('should default paymentModel to PREPAID', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);
    prismaMock.supplier.findUnique.mockResolvedValue(null);
    (prismaMock.supplier.create as jest.Mock).mockResolvedValue({
      id: 'sup-new',
      code: 'HOT-DN-TES-0006',
      name: 'Test Hotel',
      type: 'HOTEL',
      location: 'DA_NANG',
      paymentModel: 'PREPAID',
      isActive: true,
      creditLimit: null,
      contact: null,
      address: null,
      note: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Test Hotel',
        type: 'HOTEL',
      }),
    });

    await POST(request);

    expect(prismaMock.supplier.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          paymentModel: 'PREPAID',
        }),
      })
    );
  });

  it('should default isActive to true', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);
    prismaMock.supplier.findUnique.mockResolvedValue(null);
    (prismaMock.supplier.create as jest.Mock).mockResolvedValue({
      id: 'sup-new',
      code: 'HOT-DN-TES-0006',
      name: 'Test Hotel',
      type: 'HOTEL',
      location: 'DA_NANG',
      paymentModel: 'PREPAID',
      isActive: true,
      creditLimit: null,
      contact: null,
      address: null,
      note: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Test Hotel',
        type: 'HOTEL',
      }),
    });

    await POST(request);

    expect(prismaMock.supplier.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          isActive: true,
        }),
      })
    );
  });

  it('should trim text fields', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);
    prismaMock.supplier.findUnique.mockResolvedValue(null);
    (prismaMock.supplier.create as jest.Mock).mockResolvedValue({
      id: 'sup-new',
      code: 'HOT-DN-TES-0006',
      name: 'Test Hotel',
      type: 'HOTEL',
      location: 'DA_NANG',
      paymentModel: 'PREPAID',
      isActive: true,
      creditLimit: null,
      contact: null,
      address: null,
      note: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: '  Test Hotel  ',
        type: 'HOTEL',
        contactName: '  Manager  ',
      }),
    });

    await POST(request);

    expect(prismaMock.supplier.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          name: 'Test Hotel',
          contactName: 'Manager',
        }),
      })
    );
  });

  it('should convert creditLimit to number', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);
    prismaMock.supplier.findUnique.mockResolvedValue(null);
    (prismaMock.supplier.create as jest.Mock).mockResolvedValue({
      id: 'sup-new',
      code: 'HOT-DN-TES-0006',
      name: 'Test Hotel',
      type: 'HOTEL',
      location: 'DA_NANG',
      paymentModel: 'PREPAID',
      isActive: true,
      creditLimit: null,
      contact: null,
      address: null,
      note: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    });

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Test Hotel',
        type: 'HOTEL',
        paymentModel: 'CREDIT',
        creditLimit: '10000000',
      }),
    });

    await POST(request);

    expect(prismaMock.supplier.create).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          creditLimit: 10000000,
        }),
      })
    );
  });

  it('should return 500 on database error', async () => {
    prismaMock.supplier.findMany.mockResolvedValue([]);
    prismaMock.supplier.findUnique.mockResolvedValue(null);
    prismaMock.supplier.create.mockRejectedValue(new Error('Database write failed'));

    const request = createMockRequest('http://localhost:3000/api/suppliers', {
      method: 'POST',
      body: JSON.stringify({
        name: 'Test Hotel',
        type: 'HOTEL',
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.success).toBe(false);
    expect(data.error).toContain('Lỗi tạo NCC');
  });
});
</file>

<file path="src/__tests__/lib/id-utils.test.ts">
import {
  removeDiacritics,
  formatTimestamp,
  formatDatePart,
  generateRequestId,
  generateServiceId,
  generateRevenueId,
} from '@/lib/id-utils';
import { prisma } from '@/lib/db';

// Mock Prisma
jest.mock('@/lib/db', () => ({
  prisma: {
    request: {
      findUnique: jest.fn(),
    },
    operator: {
      findUnique: jest.fn(),
    },
    revenue: {
      findMany: jest.fn(),
    },
  },
}));

// Type-safe mock accessors
const mockRequestFindUnique = prisma.request.findUnique as jest.Mock;
const mockOperatorFindUnique = prisma.operator.findUnique as jest.Mock;
const mockRevenueFindMany = prisma.revenue.findMany as jest.Mock;

describe('ID Utilities', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ============================================
  // Test: removeDiacritics
  // ============================================
  describe('removeDiacritics - Remove Vietnamese diacritics', () => {
    it('removes A diacritics', () => {
      expect(removeDiacritics('À')).toBe('A');
      expect(removeDiacritics('Á')).toBe('A');
      expect(removeDiacritics('à')).toBe('a');
      expect(removeDiacritics('á')).toBe('a');
    });

    it('removes E diacritics', () => {
      expect(removeDiacritics('È')).toBe('E');
      expect(removeDiacritics('É')).toBe('E');
      expect(removeDiacritics('è')).toBe('e');
      expect(removeDiacritics('é')).toBe('e');
    });

    it('removes I diacritics', () => {
      expect(removeDiacritics('Ì')).toBe('I');
      expect(removeDiacritics('Í')).toBe('I');
      expect(removeDiacritics('ì')).toBe('i');
      expect(removeDiacritics('í')).toBe('i');
    });

    it('removes O diacritics', () => {
      expect(removeDiacritics('Ò')).toBe('O');
      expect(removeDiacritics('Ó')).toBe('O');
      expect(removeDiacritics('ò')).toBe('o');
      expect(removeDiacritics('ó')).toBe('o');
    });

    it('removes all U variants', () => {
      expect(removeDiacritics('ÙÚỦŨỤ')).toBe('UUUUU');
      expect(removeDiacritics('ƯỪỨỬỮỰ')).toBe('UUUUUU');
    });

    it('removes all Y variants', () => {
      expect(removeDiacritics('ỲÝỶỸỴ')).toBe('YYYYY');
      expect(removeDiacritics('ỳýỷỹỵ')).toBe('yyyyy');
    });

    it('converts D with stroke (Đ/đ)', () => {
      expect(removeDiacritics('Đ')).toBe('D');
      expect(removeDiacritics('đ')).toBe('d');
    });

    it('preserves non-diacritic characters', () => {
      expect(removeDiacritics('ABC')).toBe('ABC');
      expect(removeDiacritics('123')).toBe('123');
      expect(removeDiacritics('@#$')).toBe('@#$');
    });

    it('handles mixed strings with diacritics and plain text', () => {
      expect(removeDiacritics('Lý - Jenny')).toBe('Ly - Jenny');
      expect(removeDiacritics('Tú - Tony')).toBe('Tu - Tony');
      expect(removeDiacritics('Nguyễn Văn A')).toBe('Nguyen Van A');
    });

    it('handles empty string', () => {
      expect(removeDiacritics('')).toBe('');
    });

    it('handles whitespace', () => {
      expect(removeDiacritics('  hello  ')).toBe('  hello  ');
    });
  });

  // ============================================
  // Test: formatTimestamp
  // ============================================
  describe('formatTimestamp - Format as yyyyMMddHHmmssSSS', () => {
    it('formats date correctly (17 chars)', () => {
      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = formatTimestamp(date);
      expect(result).toHaveLength(17);
      expect(/^\d{17}$/.test(result)).toBe(true);
    });

    it('pads single digit month correctly', () => {
      const date = new Date(2026, 2, 8, 14, 30, 45, 123);
      const result = formatTimestamp(date);
      expect(result).toMatch(/^202603/);
    });

    it('pads single digit date correctly', () => {
      const date = new Date(2026, 0, 5, 14, 30, 45, 123);
      const result = formatTimestamp(date);
      expect(result).toMatch(/^20260105/);
    });

    it('pads single digit hours/minutes/seconds', () => {
      const date = new Date(2026, 0, 8, 9, 5, 3, 7);
      const result = formatTimestamp(date);
      expect(result).toMatch(/090503007$/);
    });

    it('handles midnight (00:00:00)', () => {
      const date = new Date(2026, 0, 8, 0, 0, 0, 0);
      const result = formatTimestamp(date);
      expect(result).toMatch(/000000000$/);
    });

    it('handles milliseconds with 3 digits padding', () => {
      const date1 = new Date(2026, 0, 8, 14, 30, 45, 1);
      expect(formatTimestamp(date1)).toMatch(/001$/);

      const date2 = new Date(2026, 0, 8, 14, 30, 45, 10);
      expect(formatTimestamp(date2)).toMatch(/010$/);

      const date3 = new Date(2026, 0, 8, 14, 30, 45, 999);
      expect(formatTimestamp(date3)).toMatch(/999$/);
    });

    it('uses current date/time when not provided', () => {
      const result = formatTimestamp();
      expect(result).toHaveLength(17);
      expect(/^\d{17}$/.test(result)).toBe(true);
    });
  });

  // ============================================
  // Test: formatDatePart
  // ============================================
  describe('formatDatePart - Format as yyyyMMdd', () => {
    it('formats date correctly', () => {
      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = formatDatePart(date);
      expect(result).toBe('20260108');
      expect(result).toHaveLength(8);
    });

    it('pads single digit month', () => {
      const date = new Date(2026, 2, 15, 12, 0, 0, 0);
      expect(formatDatePart(date)).toMatch(/^202603/);
    });

    it('pads single digit date', () => {
      const date = new Date(2026, 0, 5, 12, 0, 0, 0);
      expect(formatDatePart(date)).toMatch(/^20260105/);
    });

    it('ignores time component', () => {
      const date1 = new Date(2026, 0, 8, 0, 0, 0, 0);
      const date2 = new Date(2026, 0, 8, 23, 59, 59, 999);
      expect(formatDatePart(date1)).toBe(formatDatePart(date2));
    });

    it('uses current date when not provided', () => {
      const result = formatDatePart();
      expect(result).toHaveLength(8);
      expect(/^\d{8}$/.test(result)).toBe(true);
    });
  });

  // ============================================
  // Test: generateRequestId
  // ============================================
  describe('generateRequestId - Generate {SellerCode}{yyyyMMddHHmmssSSS}', () => {
    it('generates valid requestId format', async () => {
      mockRequestFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRequestId('LY', date);
      expect(result).toMatch(/^LY\d{17}$/);
    });

    it('converts seller code to uppercase', async () => {
      mockRequestFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRequestId('ly', date);
      expect(result).toMatch(/^LY/);
    });

    it('removes diacritics from seller code', async () => {
      mockRequestFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRequestId('Lý', date);
      expect(result).toMatch(/^LY/);
    });

    it('removes whitespace from seller code', async () => {
      mockRequestFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRequestId('L Y', date);
      expect(result).toMatch(/^LY/);
    });

    it('checks uniqueness in database', async () => {
      mockRequestFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      await generateRequestId('LY', date);
      expect(mockRequestFindUnique).toHaveBeenCalled();
    });

    it('retries with new timestamp on collision', async () => {
      mockRequestFindUnique
        .mockResolvedValueOnce({ id: 'some-id' }) // First call: collision
        .mockResolvedValueOnce(null); // Second call: available

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRequestId('LY', date);
      expect(mockRequestFindUnique).toHaveBeenCalledTimes(2);
      expect(result).toMatch(/^LY\d{17}$/);
    });
  });

  // ============================================
  // Test: generateServiceId
  // ============================================
  describe('generateServiceId - Generate {bookingCode}-{yyyyMMddHHmmssSSS}', () => {
    it('generates valid serviceId format', async () => {
      mockOperatorFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateServiceId('20260108L0001', date);
      expect(result).toMatch(/^20260108L0001-\d{17}$/);
    });

    it('includes booking code in serviceId', async () => {
      mockOperatorFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateServiceId('ABC123', date);
      expect(result).toMatch(/^ABC123-/);
    });

    it('includes timestamp after hyphen', async () => {
      mockOperatorFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateServiceId('BC', date);
      expect(result).toMatch(/-\d{17}$/);
    });

    it('checks uniqueness in database', async () => {
      mockOperatorFindUnique.mockResolvedValue(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      await generateServiceId('BC', date);
      expect(mockOperatorFindUnique).toHaveBeenCalled();
    });

    it('retries on collision', async () => {
      mockOperatorFindUnique
        .mockResolvedValueOnce({ id: 'some-id' })
        .mockResolvedValueOnce(null);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateServiceId('BC', date);
      expect(mockOperatorFindUnique).toHaveBeenCalledTimes(2);
      expect(result).toMatch(/^BC-\d{17}$/);
    });
  });

  // ============================================
  // Test: generateRevenueId
  // ============================================
  describe('generateRevenueId - Generate {bookingCode}-{yyyyMMddHHmmss}-{rowNum}', () => {
    it('generates valid revenueId format', async () => {
      mockRevenueFindMany.mockResolvedValue([]);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRevenueId('20260108L0001', date);
      expect(result).toMatch(/^20260108L0001-\d{14}-\d+$/);
    });

    it('includes booking code', async () => {
      mockRevenueFindMany.mockResolvedValue([]);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRevenueId('ABC123', date);
      expect(result).toMatch(/^ABC123-/);
    });

    it('formats timestamp without milliseconds', async () => {
      mockRevenueFindMany.mockResolvedValue([]);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRevenueId('BC', date);
      expect(result).toMatch(/-\d{14}-/);
    });

    it('increments row number for same prefix', async () => {
      const existingRevenue = [
        { revenueId: 'BC-20260108143045-1' },
        { revenueId: 'BC-20260108143045-2' },
      ];
      mockRevenueFindMany.mockResolvedValue(existingRevenue as any);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRevenueId('BC', date);
      expect(result).toMatch(/-3$/);
    });

    it('starts with row 1 for new prefix', async () => {
      mockRevenueFindMany.mockResolvedValue([]);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      const result = await generateRevenueId('BC', date);
      expect(result).toMatch(/-1$/);
    });

    it('filters by prefix correctly', async () => {
      mockRevenueFindMany.mockResolvedValue([]);

      const date = new Date(2026, 0, 8, 14, 30, 45, 123);
      await generateRevenueId('BC', date);
      expect(mockRevenueFindMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            revenueId: expect.objectContaining({
              startsWith: expect.stringContaining('BC-202601081430'),
            }),
          }),
        })
      );
    });
  });

  // ============================================
  // Integration: ID generation flow
  // ============================================
  describe('ID generation flow', () => {
    it('generates unique IDs for multiple calls', async () => {
      mockRequestFindUnique.mockResolvedValue(null);

      const date1 = new Date(2026, 0, 8, 14, 30, 45, 100);
      const date2 = new Date(2026, 0, 8, 14, 30, 45, 200);

      const id1 = await generateRequestId('LY', date1);
      const id2 = await generateRequestId('LY', date2);

      expect(id1).not.toBe(id2);
      expect(id1).toMatch(/^LY\d{17}$/);
      expect(id2).toMatch(/^LY\d{17}$/);
    });

    it('handles concurrent ID generation', async () => {
      mockRequestFindUnique.mockResolvedValue(null);

      const date1 = new Date(2026, 0, 8, 14, 30, 45, 100);
      const date2 = new Date(2026, 0, 8, 14, 30, 45, 200);
      const date3 = new Date(2026, 0, 8, 14, 30, 45, 300);

      const promises = [
        generateRequestId('LY', date1),
        generateRequestId('LY', date2),
        generateRequestId('LY', date3),
      ];

      const results = await Promise.all(promises);
      const uniqueIds = new Set(results);

      expect(uniqueIds.size).toBe(3); // All should be unique
    });
  });
});
</file>

<file path="src/__tests__/lib/request-utils.test.ts">
/**
 * @jest-environment node
 */

/* eslint-disable @typescript-eslint/no-explicit-any */
// Tests for request module utilities
// Covers: generateRQID, generateBookingCode, calculateEndDate, calculateNextFollowUp, etc.

import { prismaMock } from '@/lib/__mocks__/db';

// Mock the db module before importing the module under test
jest.mock('@/lib/db', () => ({
  prisma: prismaMock,
}));

import {
  generateRQID,
  generateBookingCode,
  calculateEndDate,
  calculateNextFollowUp,
  getSellerCode,
  canUserViewAll,
  getFollowUpDateBoundaries,
} from '@/lib/request-utils';

describe('generateRQID', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should generate RQID with correct format RQ-YYMMDD-XXXX', async () => {
    // Mock today's count as 5
    prismaMock.request.count.mockResolvedValue(5);

    const result = await generateRQID();

    // Result should match RQ-YYMMDD-0006 format (5 + 1 = 6)
    expect(result).toMatch(/^RQ-\d{6}-\d{4}$/);
    expect(result.endsWith('-0006')).toBe(true);
  });

  it('should pad sequence number with zeros', async () => {
    prismaMock.request.count.mockResolvedValue(0);

    const result = await generateRQID();

    expect(result).toMatch(/-0001$/);
  });

  it('should pad sequence to 4 digits for count 999', async () => {
    prismaMock.request.count.mockResolvedValue(999);

    const result = await generateRQID();

    expect(result).toMatch(/-1000$/);
  });

  it('should query requests created today', async () => {
    prismaMock.request.count.mockResolvedValue(0);

    await generateRQID();

    const callArgs = prismaMock.request.count.mock.calls[0]?.[0];
    expect(callArgs).toBeDefined();
    const createdAt = callArgs?.where?.createdAt as { gte?: unknown; lte?: unknown } | undefined;
    expect(createdAt?.gte).toBeDefined();
    expect(createdAt?.lte).toBeDefined();
  });
});

describe('generateBookingCode - Phase 1 Schema Changes', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('with explicit sellerCode', () => {
    it('should use sellerCode when available', async () => {
      const startDate = new Date('2026-02-15');
      const sellerId = 'seller-1';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-1',
        userId: sellerId,
        sellerCode: 'L',
        sellerName: 'Le Quoc Anh',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Le Quoc Anh' },
      } as any);

      // Mock no existing booking codes
      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      // Format: YYYYMMDD + Code + Seq = 20260215L0001
      expect(result).toBe('20260215L0001');
    });

    it('should accept single char sellerCode', async () => {
      const startDate = new Date('2026-03-01');
      const sellerId = 'seller-2';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-2',
        userId: sellerId,
        sellerCode: 'N',
        sellerName: 'Nguyen Van B',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Nguyen Van B' },
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result).toBe('20260301N0001');
    });

    it('should handle multi-char sellerCode (edge case)', async () => {
      const startDate = new Date('2026-01-10');
      const sellerId = 'seller-3';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-3',
        userId: sellerId,
        sellerCode: 'LN', // Multi-char edge case
        sellerName: 'Le Nguyen',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Le Nguyen' },
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result).toBe('20260110LN0001');
    });
  });

  describe('fallback to sellerName first letter', () => {
    it('should use first letter of name when sellerCode is null', async () => {
      const startDate = new Date('2026-02-20');
      const sellerId = 'seller-4';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-4',
        userId: sellerId,
        sellerCode: null, // No explicit code
        sellerName: null,
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Tran Duc Hung' }, // Fallback to user.name
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      // Uses first letter 'T' from 'Tran Duc Hung'
      expect(result).toBe('20260220T0001');
    });

    it('should uppercase first letter of name', async () => {
      const startDate = new Date('2026-02-25');
      const sellerId = 'seller-5';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-5',
        userId: sellerId,
        sellerCode: null,
        sellerName: null,
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'pham van a' }, // lowercase
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      // First letter 'p' becomes 'P'
      expect(result).toBe('20260225P0001');
    });

    it('should handle single character name', async () => {
      const startDate = new Date('2026-03-05');
      const sellerId = 'seller-6';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-6',
        userId: sellerId,
        sellerCode: null,
        sellerName: null,
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'V' },
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result).toBe('20260305V0001');
    });
  });

  describe('ultimate fallback to X', () => {
    it('should use X when no sellerCode and no name', async () => {
      const startDate = new Date('2026-02-10');
      const sellerId = 'seller-7';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-7',
        userId: sellerId,
        sellerCode: null,
        sellerName: null,
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: null }, // No name
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result).toBe('20260210X0001');
    });

    it('should use X when config user not found', async () => {
      const startDate = new Date('2026-02-12');
      const sellerId = 'seller-8';

      prismaMock.configUser.findUnique.mockResolvedValue(null);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result).toBe('20260212X0001');
    });

    it('should use X when user object is missing', async () => {
      const startDate = new Date('2026-02-14');
      const sellerId = 'seller-9';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-9',
        userId: sellerId,
        sellerCode: null,
        sellerName: null,
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: undefined, // Missing user object
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result).toBe('20260214X0001');
    });
  });

  describe('sequence numbering', () => {
    it('should increment sequence for same date and code', async () => {
      const startDate = new Date('2026-02-01');
      const sellerId = 'seller-10';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-10',
        userId: sellerId,
        sellerCode: 'L',
        sellerName: 'Le Anh',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Le Anh' },
      } as any);

      // Mock existing booking codes
      prismaMock.request.findMany.mockResolvedValue([
        { bookingCode: '20260201L0005' },
      ] as any);

      const result = await generateBookingCode(startDate, sellerId);

      // Next sequence is 5 + 1 = 6
      expect(result).toBe('20260201L0006');
    });

    it('should start at 0001 when no existing codes', async () => {
      const startDate = new Date('2026-02-16');
      const sellerId = 'seller-11';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-11',
        userId: sellerId,
        sellerCode: 'T',
        sellerName: 'Tran A',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Tran A' },
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result).toBe('20260216T0001');
    });

    it('should pad sequence with zeros', async () => {
      const startDate = new Date('2026-02-17');
      const sellerId = 'seller-12';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-12',
        userId: sellerId,
        sellerCode: 'N',
        sellerName: 'Nguyen B',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Nguyen B' },
      } as any);

      // Existing code with sequence 99
      prismaMock.request.findMany.mockResolvedValue([
        { bookingCode: '20260217N0099' },
      ] as any);

      const result = await generateBookingCode(startDate, sellerId);

      // Next is 99 + 1 = 100
      expect(result).toBe('20260217N0100');
    });

    it('should handle max 4-digit sequence (9999)', async () => {
      const startDate = new Date('2026-02-18');
      const sellerId = 'seller-13';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-13',
        userId: sellerId,
        sellerCode: 'V',
        sellerName: 'Vu C',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Vu C' },
      } as any);

      // Existing code with sequence 9999
      prismaMock.request.findMany.mockResolvedValue([
        { bookingCode: '20260218V9999' },
      ] as any);

      const result = await generateBookingCode(startDate, sellerId);

      // Next is 9999 + 1 = 10000 (overflow to 5 digits)
      expect(result).toBe('20260218V10000');
    });
  });

  describe('date formatting', () => {
    it('should format date as YYYYMMDD', async () => {
      const startDate = new Date('2026-01-05');
      const sellerId = 'seller-14';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-14',
        userId: sellerId,
        sellerCode: 'L',
        sellerName: 'Le D',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Le D' },
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result).toMatch(/^20260105L\d+$/);
    });

    it('should pad month and day with zeros', async () => {
      const startDate = new Date('2026-03-09'); // March 9th
      const sellerId = 'seller-15';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-15',
        userId: sellerId,
        sellerCode: 'N',
        sellerName: 'Nguyen C',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Nguyen C' },
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result.startsWith('20260309')).toBe(true);
    });

    it('should handle December dates', async () => {
      const startDate = new Date('2026-12-31');
      const sellerId = 'seller-16';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-16',
        userId: sellerId,
        sellerCode: 'X',
        sellerName: 'Xe D',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Xe D' },
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      const result = await generateBookingCode(startDate, sellerId);

      expect(result.startsWith('20261231')).toBe(true);
    });
  });

  describe('existing booking codes preservation', () => {
    it('should not modify existing booking codes', async () => {
      const startDate = new Date('2026-02-19');
      const sellerId = 'seller-17';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-17',
        userId: sellerId,
        sellerCode: 'L',
        sellerName: 'Le E',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Le E' },
      } as any);

      // Mock existing codes - findMany returns results ordered by bookingCode DESC, take: 1
      // So it only returns the highest sequence for the given prefix
      prismaMock.request.findMany.mockResolvedValue([
        { bookingCode: '20260219L0003' }, // Highest sequence for this prefix
      ] as any);

      const result = await generateBookingCode(startDate, sellerId);

      // Should increment from 3 to 4
      expect(result).toBe('20260219L0004');
    });

    it('should query correctly with startsWith filter', async () => {
      const startDate = new Date('2026-02-20');
      const sellerId = 'seller-18';

      prismaMock.configUser.findUnique.mockResolvedValue({
        id: 'config-18',
        userId: sellerId,
        sellerCode: 'T',
        sellerName: 'Tran E',
        canViewAll: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        user: { name: 'Tran E' },
      } as any);

      prismaMock.request.findMany.mockResolvedValue([]);

      await generateBookingCode(startDate, sellerId);

      const findManyCall = prismaMock.request.findMany.mock.calls[0]?.[0];
      expect(findManyCall).toBeDefined();
      const bookingCodeFilter = findManyCall?.where?.bookingCode as { startsWith?: string } | undefined;
      expect(bookingCodeFilter?.startsWith).toBe('20260220T');
    });
  });
});

describe('calculateEndDate', () => {
  it('should calculate end date as startDate + tourDays - 1', () => {
    const startDate = new Date('2026-02-01');
    const tourDays = 5;

    const result = calculateEndDate(startDate, tourDays);

    const expectedEnd = new Date('2026-02-05');
    expect(result).toEqual(expectedEnd);
  });

  it('should handle single day tour', () => {
    const startDate = new Date('2026-02-10');
    const tourDays = 1;

    const result = calculateEndDate(startDate, tourDays);

    expect(result).toEqual(startDate);
  });

  it('should handle two day tour', () => {
    const startDate = new Date('2026-02-15');
    const tourDays = 2;

    const result = calculateEndDate(startDate, tourDays);

    const expectedEnd = new Date('2026-02-16');
    expect(result).toEqual(expectedEnd);
  });

  it('should handle long tour (cross month)', () => {
    const startDate = new Date('2026-02-25');
    const tourDays = 10;

    const result = calculateEndDate(startDate, tourDays);

    const expectedEnd = new Date('2026-03-06');
    expect(result).toEqual(expectedEnd);
  });

  it('should not mutate original date', () => {
    const startDate = new Date('2026-02-20');
    const originalTime = startDate.getTime();
    const tourDays = 5;

    calculateEndDate(startDate, tourDays);

    expect(startDate.getTime()).toBe(originalTime);
  });
});

describe('calculateNextFollowUp', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should calculate next follow-up date based on config', async () => {
    const stage = 'F1';
    const lastContactDate = new Date('2026-02-01');

    prismaMock.configFollowUp.findUnique.mockResolvedValue({
      id: 'config-f1',
      stage: 'F1',
      daysToWait: 3,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as any);

    const result = await calculateNextFollowUp(stage, lastContactDate);

    const expectedDate = new Date('2026-02-04');
    expect(result).toEqual(expectedDate);
  });

  it('should return null when config is not found', async () => {
    const stage = 'F2';
    const lastContactDate = new Date('2026-02-01');

    prismaMock.configFollowUp.findUnique.mockResolvedValue(null);

    const result = await calculateNextFollowUp(stage, lastContactDate);

    expect(result).toBeNull();
  });

  it('should return null when config is inactive', async () => {
    const stage = 'F3';
    const lastContactDate = new Date('2026-02-01');

    prismaMock.configFollowUp.findUnique.mockResolvedValue({
      id: 'config-f3',
      stage: 'F3',
      daysToWait: 5,
      isActive: false,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as any);

    const result = await calculateNextFollowUp(stage, lastContactDate);

    expect(result).toBeNull();
  });

  it('should handle 0 days to wait', async () => {
    const stage = 'F4';
    const lastContactDate = new Date('2026-02-01');

    prismaMock.configFollowUp.findUnique.mockResolvedValue({
      id: 'config-f4',
      stage: 'F4',
      daysToWait: 0,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as any);

    const result = await calculateNextFollowUp(stage, lastContactDate);

    expect(result).toEqual(lastContactDate);
  });

  it('should handle large days to wait', async () => {
    const stage = 'F1';
    const lastContactDate = new Date('2026-02-01');

    prismaMock.configFollowUp.findUnique.mockResolvedValue({
      id: 'config-f1',
      stage: 'F1',
      daysToWait: 30,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
    } as any);

    const result = await calculateNextFollowUp(stage, lastContactDate);

    const expectedDate = new Date('2026-03-03');
    expect(result).toEqual(expectedDate);
  });
});

describe('getSellerCode', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return seller code when available', async () => {
    const userId = 'user-1';

    prismaMock.configUser.findUnique.mockResolvedValue({
      sellerCode: 'L',
    } as any);

    const result = await getSellerCode(userId);

    expect(result).toBe('L');
  });

  it('should return null when seller code is null', async () => {
    const userId = 'user-2';

    prismaMock.configUser.findUnique.mockResolvedValue({
      sellerCode: null,
    } as any);

    const result = await getSellerCode(userId);

    expect(result).toBeNull();
  });

  it('should return null when config not found', async () => {
    const userId = 'user-3';

    prismaMock.configUser.findUnique.mockResolvedValue(null);

    const result = await getSellerCode(userId);

    expect(result).toBeNull();
  });

  it('should call findUnique with correct userId', async () => {
    const userId = 'user-4';

    prismaMock.configUser.findUnique.mockResolvedValue({
      sellerCode: 'N',
    } as any);

    await getSellerCode(userId);

    expect(prismaMock.configUser.findUnique).toHaveBeenCalledWith({
      where: { userId },
      select: { sellerCode: true },
    });
  });
});

describe('canUserViewAll', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return true when canViewAll is true', async () => {
    const userId = 'user-5';

    prismaMock.configUser.findUnique.mockResolvedValue({
      canViewAll: true,
    } as any);

    const result = await canUserViewAll(userId);

    expect(result).toBe(true);
  });

  it('should return false when canViewAll is false', async () => {
    const userId = 'user-6';

    prismaMock.configUser.findUnique.mockResolvedValue({
      canViewAll: false,
    } as any);

    const result = await canUserViewAll(userId);

    expect(result).toBe(false);
  });

  it('should return false when config not found', async () => {
    const userId = 'user-7';

    prismaMock.configUser.findUnique.mockResolvedValue(null);

    const result = await canUserViewAll(userId);

    expect(result).toBe(false);
  });
});

describe('getFollowUpDateBoundaries', () => {
  it('should return today start and end dates', () => {
    const result = getFollowUpDateBoundaries();

    expect(result.todayStart).toBeDefined();
    expect(result.todayEnd).toBeDefined();
    expect(result.threeDaysLater).toBeDefined();
  });

  it('todayStart should be at 00:00:00', () => {
    const result = getFollowUpDateBoundaries();

    expect(result.todayStart.getHours()).toBe(0);
    expect(result.todayStart.getMinutes()).toBe(0);
    expect(result.todayStart.getSeconds()).toBe(0);
    expect(result.todayStart.getMilliseconds()).toBe(0);
  });

  it('todayEnd should be at 23:59:59.999', () => {
    const result = getFollowUpDateBoundaries();

    expect(result.todayEnd.getHours()).toBe(23);
    expect(result.todayEnd.getMinutes()).toBe(59);
    expect(result.todayEnd.getSeconds()).toBe(59);
    expect(result.todayEnd.getMilliseconds()).toBe(999);
  });

  it('threeDaysLater should be 3 days after todayStart', () => {
    const result = getFollowUpDateBoundaries();

    const expectedDate = new Date(result.todayStart);
    expectedDate.setDate(expectedDate.getDate() + 3);

    // Compare only year, month, day
    expect(result.threeDaysLater.getFullYear()).toBe(expectedDate.getFullYear());
    expect(result.threeDaysLater.getMonth()).toBe(expectedDate.getMonth());
    expect(result.threeDaysLater.getDate()).toBe(expectedDate.getDate());
  });

  it('should have same date for todayStart and todayEnd', () => {
    const result = getFollowUpDateBoundaries();

    expect(result.todayStart.getFullYear()).toBe(result.todayEnd.getFullYear());
    expect(result.todayStart.getMonth()).toBe(result.todayEnd.getMonth());
    expect(result.todayStart.getDate()).toBe(result.todayEnd.getDate());
  });
});
</file>

<file path="src/__tests__/lib/sheet-mappers.test.ts">
/**
 * Tests for sheet-mappers.ts
 * Verifies request sync mapping, enum key conversion, and booking code inclusion
 */

import { mapRequestRow } from "@/lib/sheet-mappers";
import { prisma } from "@/lib/db";
import { Prisma } from "@prisma/client";

// Mock Prisma
jest.mock("@/lib/db", () => ({
  prisma: {
    user: {
      findFirst: jest.fn(),
    },
  },
}));

// Type-safe mock accessor
const mockUserFindFirst = prisma.user.findFirst as jest.Mock;

const mockSeller = {
  id: "seller-1",
  email: "seller@test.com",
  password: null,
  name: "Test Seller",
  role: "SELLER" as const,
  avatar: null,
  createdAt: new Date(),
  updatedAt: new Date(),
};

describe("sheet-mappers.ts - Request Row Mapping", () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockUserFindFirst.mockResolvedValue(mockSeller);
  });

  describe("mapRequestRow - Basic Structure", () => {
    test("should extract all required and optional fields from row", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[2] = "john@example.com";
      row[4] = "2";
      row[5] = "United States";
      row[6] = "Website";
      row[7] = "Đã báo giá";
      row[9] = "5";
      row[10] = "15/01/2025";
      row[11] = "5000000";
      row[12] = "3000000";
      row[13] = "VIP customer";
      row[19] = "JOHN-001";
      row[25] = "20/01/2025";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result).not.toBeNull();
      expect(result).toEqual(
        expect.objectContaining({
          code: "RQ-250115-0001",
          customerName: "John Doe",
          contact: "john@example.com",
          pax: 2,
          country: "United States",
          source: "Website",
          notes: "VIP customer",
          sheetRowIndex: 2,
          sellerId: "seller-1",
        })
      );
    });

    test("should include bookingCode in output", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[19] = "BOOKING-CODE-123";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result).not.toBeNull();
      expect(result?.bookingCode).toBe("BOOKING-CODE-123");
    });

    test("should handle null bookingCode when not provided", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[19] = "";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result).not.toBeNull();
      expect(result?.bookingCode).toBeNull();
    });
  });

  describe("mapRequestRow - Vietnamese Status Mapping to Enum Keys", () => {
    const createTestRow = (vietnameseStatus: string) => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[7] = vietnameseStatus;
      row[43] = "RQ-250115-0001";
      return row;
    };

    test("should map 'Đã báo giá' to DA_BAO_GIA enum key", async () => {
      const result = await mapRequestRow(createTestRow("Đã báo giá"), 2);
      expect(result?.status).toBe("DA_BAO_GIA");
    });

    test("should map 'Đang xây Tour' to DANG_XAY_TOUR enum key", async () => {
      const result = await mapRequestRow(createTestRow("Đang xây Tour"), 2);
      expect(result?.status).toBe("DANG_XAY_TOUR");
    });

    test("should map 'F1' to F1 enum key", async () => {
      const result = await mapRequestRow(createTestRow("F1"), 2);
      expect(result?.status).toBe("F1");
    });

    test("should map 'F2' to F2 enum key", async () => {
      const result = await mapRequestRow(createTestRow("F2"), 2);
      expect(result?.status).toBe("F2");
    });

    test("should map 'F3' to F3 enum key", async () => {
      const result = await mapRequestRow(createTestRow("F3"), 2);
      expect(result?.status).toBe("F3");
    });

    test("should map 'F4' variations to F4 enum key", async () => {
      expect((await mapRequestRow(createTestRow("F4"), 2))?.status).toBe("F4");
      expect(
        (await mapRequestRow(createTestRow("F4: Lần cuối"), 2))?.status
      ).toBe("F4");
      expect((await mapRequestRow(createTestRow("Lần cuối"), 2))?.status).toBe(
        "F4"
      );
    });

    test("should map 'Booking' to BOOKING enum key", async () => {
      const result = await mapRequestRow(createTestRow("Booking"), 2);
      expect(result?.status).toBe("BOOKING");
    });

    test("should map 'Khách hoãn' to KHACH_HOAN enum key", async () => {
      const result = await mapRequestRow(createTestRow("Khách hoãn"), 2);
      expect(result?.status).toBe("KHACH_HOAN");
    });

    test("should map 'Đang suy nghĩ' to KHACH_SUY_NGHI enum key", async () => {
      const result = await mapRequestRow(createTestRow("Đang suy nghĩ"), 2);
      expect(result?.status).toBe("KHACH_SUY_NGHI");
    });

    test("should map 'Không đủ TC' to KHONG_DU_TC enum key", async () => {
      const result = await mapRequestRow(createTestRow("Không đủ TC"), 2);
      expect(result?.status).toBe("KHONG_DU_TC");
    });

    test("should map 'Đã kết thúc' to DA_KET_THUC enum key", async () => {
      const result = await mapRequestRow(createTestRow("Đã kết thúc"), 2);
      expect(result?.status).toBe("DA_KET_THUC");
    });

    test("should map 'Cancel' to CANCEL enum key", async () => {
      const result = await mapRequestRow(createTestRow("Cancel"), 2);
      expect(result?.status).toBe("CANCEL");
    });

    test("should map 'Đang LL - khách chưa trả lời' to DANG_LL_CHUA_TL enum key",
      async () => {
        const result = await mapRequestRow(
          createTestRow("Đang LL - khách chưa trả lời"),
          2
        );
        expect(result?.status).toBe("DANG_LL_CHUA_TL");
      }
    );

    test("should map 'Đang LL - khách đã trả lời' to DANG_LL_DA_TL enum key",
      async () => {
        const result = await mapRequestRow(
          createTestRow("Đang LL - khách đã trả lời"),
          2
        );
        expect(result?.status).toBe("DANG_LL_DA_TL");
      }
    );

    test("should default to DANG_LL_CHUA_TL for unknown status", async () => {
      const result = await mapRequestRow(createTestRow("UNKNOWN_STATUS"), 2);
      expect(result?.status).toBe("DANG_LL_CHUA_TL");
    });

    test("should default to DANG_LL_CHUA_TL for empty status", async () => {
      const result = await mapRequestRow(createTestRow(""), 2);
      expect(result?.status).toBe("DANG_LL_CHUA_TL");
    });

    test("should always return string enum key (not Vietnamese label)", async () => {
      const result = await mapRequestRow(createTestRow("Đã báo giá"), 2);
      expect(typeof result?.status).toBe("string");
      expect(result?.status).toMatch(/^[A-Z_0-9]+$/);
    });
  });

  describe("mapRequestRow - Decimal Fields", () => {
    test("should convert expectedRevenue to Prisma.Decimal", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[11] = "5000000";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.expectedRevenue).toBeInstanceOf(Prisma.Decimal);
      expect(result?.expectedRevenue?.toString()).toBe("5000000");
    });

    test("should convert expectedCost to Prisma.Decimal", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[12] = "3000000";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.expectedCost).toBeInstanceOf(Prisma.Decimal);
      expect(result?.expectedCost?.toString()).toBe("3000000");
    });

    test("should handle Vietnamese decimal format (comma as decimal separator)", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[11] = "5.000.000,50";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.expectedRevenue).toBeInstanceOf(Prisma.Decimal);
      expect(result?.expectedRevenue?.toNumber()).toBeCloseTo(5000000.5, 1);
    });

    test("should handle empty Decimal fields as null", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[11] = "";
      row[12] = "";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.expectedRevenue).toBeNull();
      expect(result?.expectedCost).toBeNull();
    });
  });

  describe("mapRequestRow - Validation & Filtering", () => {
    test("should return null when Request ID (AR) is empty", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[43] = "";

      const result = await mapRequestRow(row, 2);
      expect(result).toBeNull();
    });

    test("should return null when Seller (A) is empty", async () => {
      mockUserFindFirst.mockResolvedValueOnce(null);

      const row = Array(44).fill("");
      row[0] = "";
      row[1] = "John Doe";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);
      expect(result).toBeNull();
    });

    test("should return null when customer name (B) is empty", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);
      expect(result).toBeNull();
    });

    test("should return null for header rows", async () => {
      const row = [
        "Seller",
        "Name",
        "Contact",
        ...Array(41).fill(""),
        "Request ID",
      ];

      const result = await mapRequestRow(row, 1);
      expect(result).toBeNull();
    });

    test("should throw error when no SELLER user found", async () => {
      mockUserFindFirst.mockResolvedValueOnce(null);

      const row = Array(44).fill("");
      row[0] = "Non-existent Seller";
      row[1] = "John Doe";
      row[43] = "RQ-250115-0001";

      await expect(mapRequestRow(row, 2)).rejects.toThrow(
        "No SELLER user found for import"
      );
    });
  });

  describe("mapRequestRow - Data Types & Conversions", () => {
    test("should convert pax string to number", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[4] = "2";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.pax).toBe(2);
      expect(typeof result?.pax).toBe("number");
    });

    test("should default pax to 1 if empty", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[4] = "";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.pax).toBe(1);
    });

    test("should parse tourDays as number", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[9] = "5";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.tourDays).toBe(5);
      expect(typeof result?.tourDays).toBe("number");
    });

    test("should handle null tourDays when empty", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[9] = "";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.tourDays).toBeNull();
    });

    test("should parse dates in DD/MM/YYYY format", async () => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[10] = "15/01/2025";
      row[43] = "RQ-250115-0001";

      const result = await mapRequestRow(row, 2);

      expect(result?.startDate).toBeInstanceOf(Date);
      expect(result?.startDate?.getFullYear()).toBe(2025);
      expect(result?.startDate?.getMonth()).toBe(0);
      expect(result?.startDate?.getDate()).toBe(15);
    });

    test("should trim whitespace from text fields", async () => {
      const row = Array(44).fill("");
      row[0] = "  Test Seller  ";
      row[1] = "  John Doe  ";
      row[2] = "  john@example.com  ";
      row[43] = "  RQ-250115-0001  ";

      const result = await mapRequestRow(row, 2);

      expect(result?.code).toBe("RQ-250115-0001");
      expect(result?.customerName).toBe("John Doe");
      expect(result?.contact).toBe("john@example.com");
    });
  });

  describe("mapRequestRow - Stage Mapping", () => {
    const createTestRow = (vietnameseStatus: string) => {
      const row = Array(44).fill("");
      row[0] = "Test Seller";
      row[1] = "John Doe";
      row[7] = vietnameseStatus;
      row[43] = "RQ-250115-0001";
      return row;
    };

    test("should map quote statuses to QUOTE stage", async () => {
      const result1 = await mapRequestRow(createTestRow("Đã báo giá"), 2);
      const result2 = await mapRequestRow(
        createTestRow("Đang xây Tour"),
        2
      );

      expect(result1?.stage).toBe("QUOTE");
      expect(result2?.stage).toBe("QUOTE");
    });

    test("should map F1-F4 statuses to FOLLOWUP stage", async () => {
      const result1 = await mapRequestRow(createTestRow("F1"), 2);
      const result2 = await mapRequestRow(createTestRow("F4"), 2);

      expect(result1?.stage).toBe("FOLLOWUP");
      expect(result2?.stage).toBe("FOLLOWUP");
    });

    test("should map booking/cancel statuses to OUTCOME stage", async () => {
      const result1 = await mapRequestRow(createTestRow("Booking"), 2);
      const result2 = await mapRequestRow(createTestRow("Cancel"), 2);
      const result3 = await mapRequestRow(
        createTestRow("Đã kết thúc"),
        2
      );

      expect(result1?.stage).toBe("OUTCOME");
      expect(result2?.stage).toBe("OUTCOME");
      expect(result3?.stage).toBe("OUTCOME");
    });

    test("should default to LEAD stage for unknown status", async () => {
      const result = await mapRequestRow(createTestRow("UNKNOWN"), 2);

      expect(result?.stage).toBe("LEAD");
    });
  });

  describe("mapRequestRow - Real-world Integration", () => {
    test("should handle complete real-world request row", async () => {
      mockUserFindFirst.mockResolvedValueOnce({
        id: "seller-123",
        email: "phuong@vivatour.com",
        password: null,
        name: "Phuong Nguyen",
        role: "SELLER" as const,
        avatar: null,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      const row = [
        "Phuong Nguyen",
        "Sarah Johnson",
        "sarah@gmail.com",
        "",
        "4",
        "United States",
        "TripAdvisor",
        "F2",
        "",
        "10",
        "01/03/2025",
        "50000000",
        "30000000",
        "VIP client, needs visa",
        "",
        "",
        "",
        "",
        "",
        "JOHN-VIP-001",
        ...Array(5).fill(""),
        "10/03/2025",
        ...Array(17).fill(""),
        "RQ-250301-0015",
      ];

      const result = await mapRequestRow(row, 10);

      expect(result).toEqual({
        code: "RQ-250301-0015",
        bookingCode: "JOHN-VIP-001",
        customerName: "Sarah Johnson",
        contact: "sarah@gmail.com",
        country: "United States",
        source: "TripAdvisor",
        status: "F2",
        stage: "FOLLOWUP",
        pax: 4,
        tourDays: 10,
        startDate: expect.any(Date),
        endDate: expect.any(Date),
        expectedRevenue: expect.any(Prisma.Decimal),
        expectedCost: expect.any(Prisma.Decimal),
        notes: "VIP client, needs visa",
        sellerId: "seller-123",
        sheetRowIndex: 10,
      });
    });
  });
});
</file>

<file path="src/app/(dashboard)/operators/reports/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Button } from '@/components/ui/button';
import { BarChart3, RefreshCw, TrendingUp } from 'lucide-react';
import { CostByServiceChart } from '@/components/operators/reports/cost-by-service-chart';
import { CostBySupplierTable } from '@/components/operators/reports/cost-by-supplier-table';
import { MonthlyTrend } from '@/components/operators/reports/monthly-trend';
import { PaymentStatusCards } from '@/components/operators/reports/payment-status-cards';
import { ProfitReportTable } from '@/components/operators/reports/profit-report-table';
import { ProfitChart } from '@/components/operators/reports/profit-chart';
import { ErrorFallback } from '@/components/ui/error-fallback';
import { safeFetch } from '@/lib/api/fetch-utils';
import { formatCurrency } from '@/lib/utils';
import type { OperatorCostReport, PaymentStatusReport, ProfitReport } from '@/types';

type ReportTab = 'cost' | 'profit';

export default function OperatorReportsPage() {
  const [activeTab, setActiveTab] = useState<ReportTab>('cost');
  const [costReport, setCostReport] = useState<OperatorCostReport | null>(null);
  const [paymentReport, setPaymentReport] = useState<PaymentStatusReport | null>(null);
  const [profitReport, setProfitReport] = useState<ProfitReport | null>(null);
  const [fromDate, setFromDate] = useState('');
  const [toDate, setToDate] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch reports function
  const fetchReports = async () => {
    setLoading(true);
    setError(null);

    const costParams = new URLSearchParams();
    if (fromDate) costParams.set('fromDate', fromDate);
    if (toDate) costParams.set('toDate', toDate);

    const profitParams = new URLSearchParams();
    if (fromDate) profitParams.set('startDate', fromDate);
    if (toDate) profitParams.set('endDate', toDate);

    const [costResult, paymentResult, profitResult] = await Promise.all([
      safeFetch<OperatorCostReport>(`/api/reports/operator-costs?${costParams}`),
      safeFetch<PaymentStatusReport>('/api/reports/operator-payments'),
      safeFetch<ProfitReport>(`/api/reports/profit?${profitParams}`),
    ]);

    // Handle errors
    if (costResult.error || paymentResult.error || profitResult.error) {
      setError(costResult.error || paymentResult.error || profitResult.error);
    }

    // Set data if available
    if (costResult.data) setCostReport(costResult.data);
    if (paymentResult.data) setPaymentReport(paymentResult.data);
    if (profitResult.data) setProfitReport(profitResult.data);

    setLoading(false);
  };

  // Initial load and when date filters change
  useEffect(() => {
    fetchReports();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [fromDate, toDate]);

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <BarChart3 className="h-6 w-6" />
            Báo Cáo Điều Hành
          </h1>
          <p className="text-muted-foreground">Phân tích chi phí và lợi nhuận theo booking</p>
        </div>
        <Button variant="outline" onClick={fetchReports} disabled={loading}>
          <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
          Làm mới
        </Button>
      </div>

      {/* Main Report Tabs */}
      <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as ReportTab)}>
        <TabsList className="grid w-full max-w-md grid-cols-2">
          <TabsTrigger value="cost" className="flex items-center gap-2">
            <BarChart3 className="h-4 w-4" />
            Chi phí
          </TabsTrigger>
          <TabsTrigger value="profit" className="flex items-center gap-2">
            <TrendingUp className="h-4 w-4" />
            Lợi nhuận
          </TabsTrigger>
        </TabsList>

        {/* Date filters */}
        <Card className="mt-4">
          <CardContent className="pt-6">
            <div className="flex flex-wrap gap-4 items-end">
              <div className="space-y-2">
                <Label>Từ ngày</Label>
                <Input
                  type="date"
                  value={fromDate}
                  onChange={(e) => setFromDate(e.target.value)}
                  className="w-40"
                />
              </div>
              <div className="space-y-2">
                <Label>Đến ngày</Label>
                <Input
                  type="date"
                  value={toDate}
                  onChange={(e) => setToDate(e.target.value)}
                  className="w-40"
                />
              </div>
              {(fromDate || toDate) && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setFromDate('');
                    setToDate('');
                  }}
                >
                  Xóa bộ lọc
                </Button>
              )}
            </div>
          </CardContent>
        </Card>

        {/* Loading state */}
        {loading && (
          <div className="text-center py-8 text-muted-foreground">
            Đang tải báo cáo...
          </div>
        )}

        {/* Error state */}
        {!loading && error && (
          <ErrorFallback
            title="Lỗi tải báo cáo"
            message={error}
            onRetry={fetchReports}
            retryLabel="Tải lại"
          />
        )}

        {/* Cost Report Tab */}
        <TabsContent value="cost" className="mt-4 space-y-6">
          {/* Payment status */}
          {paymentReport && <PaymentStatusCards data={paymentReport} />}

          {/* Cost report content */}
          {!loading && !error && costReport && (
            <>
              {/* Summary */}
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <Card>
                  <CardContent className="pt-6">
                    <p className="text-sm text-muted-foreground">Tổng chi phí</p>
                    <p className="text-2xl font-bold text-red-600">
                      {formatCurrency(costReport.summary.totalCost)} ₫
                    </p>
                  </CardContent>
                </Card>
                <Card>
                  <CardContent className="pt-6">
                    <p className="text-sm text-muted-foreground">Số dịch vụ</p>
                    <p className="text-2xl font-bold">{costReport.summary.totalCount}</p>
                  </CardContent>
                </Card>
                <Card>
                  <CardContent className="pt-6">
                    <p className="text-sm text-muted-foreground">Chi phí TB/dịch vụ</p>
                    <p className="text-2xl font-bold">
                      {formatCurrency(costReport.summary.avgCost)} ₫
                    </p>
                  </CardContent>
                </Card>
              </div>

              <Tabs defaultValue="service">
                <TabsList>
                  <TabsTrigger value="service">Theo loại DV</TabsTrigger>
                  <TabsTrigger value="supplier">Theo NCC</TabsTrigger>
                  <TabsTrigger value="month">Theo tháng</TabsTrigger>
                </TabsList>

                <TabsContent value="service" className="mt-4">
                  <CostByServiceChart
                    data={costReport.byServiceType}
                    totalCost={costReport.summary.totalCost}
                  />
                </TabsContent>

                <TabsContent value="supplier" className="mt-4">
                  <CostBySupplierTable data={costReport.bySupplier} />
                </TabsContent>

                <TabsContent value="month" className="mt-4">
                  <MonthlyTrend data={costReport.byMonth} />
                </TabsContent>
              </Tabs>
            </>
          )}

          {/* Empty state */}
          {!loading && !error && costReport && costReport.summary.totalCount === 0 && (
            <Card>
              <CardContent className="pt-6">
                <p className="text-center text-muted-foreground py-8">
                  Không có dữ liệu chi phí trong khoảng thời gian đã chọn
                </p>
              </CardContent>
            </Card>
          )}
        </TabsContent>

        {/* Profit Report Tab */}
        <TabsContent value="profit" className="mt-4 space-y-6">
          {!loading && !error && profitReport && (
            <>
              {/* Profit Chart */}
              <ProfitChart data={profitReport.bookings} />

              {/* Profit Table */}
              <ProfitReportTable
                data={profitReport.bookings}
                summary={profitReport.summary}
              />
            </>
          )}

          {/* Empty state */}
          {!loading && !error && profitReport && profitReport.summary.bookingCount === 0 && (
            <Card>
              <CardContent className="pt-6">
                <p className="text-center text-muted-foreground py-8">
                  Không có dữ liệu lợi nhuận trong khoảng thời gian đã chọn
                </p>
              </CardContent>
            </Card>
          )}
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/requests/[id]/page.tsx">
import { redirect } from 'next/navigation';

interface PageProps {
  params: Promise<{ id: string }>;
}

/**
 * Redirect old detail URLs to new 2-panel layout.
 * /requests/[id] → /requests?id=[id]
 */
export default async function RequestDetailRedirect({ params }: PageProps) {
  const { id } = await params;

  // Safe params validation - redirect to list if invalid ID
  if (!id || typeof id !== 'string') {
    redirect('/requests');
  }

  redirect(`/requests?id=${id}`);
}
</file>

<file path="src/app/(dashboard)/requests/create/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';
import { RequestForm } from '@/components/requests';
import { safeFetch, safePost } from '@/lib/api/fetch-utils';
import type { Request, RequestFormData } from '@/types';

interface UserConfig {
  userId: string;
  canViewAll?: boolean;
}

export default function CreateRequestPage() {
  const router = useRouter();
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchCurrentUser() {
      const { data, error: fetchError } = await safeFetch<UserConfig>('/api/config/user/me');

      if (fetchError) {
        setError(fetchError);
      } else if (data?.userId) {
        setCurrentUserId(data.userId);
      } else {
        setError('Không thể xác định người dùng hiện tại');
      }

      setLoading(false);
    }
    fetchCurrentUser();
  }, []);

  const handleSubmit = async (data: RequestFormData) => {
    if (!currentUserId) {
      throw new Error('Không thể xác định người dùng hiện tại');
    }

    const { data: result, error: submitError } = await safePost<Request>('/api/requests', {
      ...data,
      sellerId: currentUserId,
    });

    if (submitError) {
      toast.error(`Có lỗi xảy ra: ${submitError}`);
      throw new Error(submitError);
    }

    if (result?.id) {
      toast.success('Đã tạo yêu cầu thành công');
      router.push(`/requests/${result.id}`);
    }
  };

  if (loading) {
    return (
      <div className="max-w-3xl mx-auto p-8 text-center text-muted-foreground">
        Đang tải...
      </div>
    );
  }

  if (error) {
    return (
      <div className="max-w-3xl mx-auto p-8 text-center">
        <p className="text-red-600 mb-4">{error}</p>
        <button
          onClick={() => router.back()}
          className="text-blue-600 hover:underline"
        >
          Quay lại
        </button>
      </div>
    );
  }

  return (
    <div className="max-w-3xl mx-auto space-y-6">
      <div>
        <h1 className="text-2xl font-bold">Thêm yêu cầu mới</h1>
        <p className="text-muted-foreground">Nhập thông tin yêu cầu từ khách hàng</p>
      </div>

      <RequestForm
        onSubmit={handleSubmit}
        onCancel={() => router.back()}
      />
    </div>
  );
}
</file>

<file path="src/app/api/config/sellers/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { sellerSchema, transformSellerData } from '@/lib/validations/config-validation';

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET /api/config/sellers/[id] - Get single seller
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;

    const seller = await prisma.seller.findUnique({
      where: { id },
    });

    if (!seller) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy seller' },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: seller });
  } catch (error) {
    console.error('Error fetching seller:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải seller: ${message}` },
      { status: 500 }
    );
  }
}

// PUT /api/config/sellers/[id] - Update seller
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;
    const body = await request.json();

    // Validate input
    const result = sellerSchema.safeParse(body);
    if (!result.success) {
      const errors = result.error.issues.map((e) => e.message).join(', ');
      return NextResponse.json(
        { success: false, error: errors },
        { status: 400 }
      );
    }

    const data = transformSellerData(result.data);

    // Check if seller exists
    const existing = await prisma.seller.findUnique({
      where: { id },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy seller' },
        { status: 404 }
      );
    }

    // Check if telegramId is used by another seller
    if (data.telegramId !== existing.telegramId) {
      const existingTelegram = await prisma.seller.findUnique({
        where: { telegramId: data.telegramId },
      });

      if (existingTelegram && existingTelegram.id !== id) {
        return NextResponse.json(
          { success: false, error: `Telegram ID "${data.telegramId}" đã tồn tại` },
          { status: 400 }
        );
      }
    }

    // Check if sellerCode is used by another seller
    if (data.sellerCode !== existing.sellerCode) {
      const existingCode = await prisma.seller.findUnique({
        where: { sellerCode: data.sellerCode },
      });

      if (existingCode && existingCode.id !== id) {
        return NextResponse.json(
          { success: false, error: `Mã seller "${data.sellerCode}" đã được sử dụng` },
          { status: 400 }
        );
      }
    }

    const seller = await prisma.seller.update({
      where: { id },
      data,
    });

    return NextResponse.json({ success: true, data: seller });
  } catch (error) {
    console.error('Error updating seller:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi cập nhật seller: ${message}` },
      { status: 500 }
    );
  }
}

// DELETE /api/config/sellers/[id] - Delete seller
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const { id } = await params;

    const existing = await prisma.seller.findUnique({
      where: { id },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy seller' },
        { status: 404 }
      );
    }

    await prisma.seller.delete({
      where: { id },
    });

    return NextResponse.json({
      success: true,
      message: 'Đã xóa seller thành công',
    });
  } catch (error) {
    console.error('Error deleting seller:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi xóa seller: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/config/sellers/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { sellerSchema, transformSellerData } from '@/lib/validations/config-validation';

// GET /api/config/sellers - List all sellers with pagination
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1', 10);
    const limit = parseInt(searchParams.get('limit') || '10', 10);
    const search = searchParams.get('search') || '';
    const isActive = searchParams.get('isActive');

    // Validate search length to prevent performance issues
    if (search.length > 100) {
      return NextResponse.json(
        { success: false, error: 'Từ khóa tìm kiếm quá dài (tối đa 100 ký tự)' },
        { status: 400 }
      );
    }

    const skip = (page - 1) * limit;

    // Build where clause
    const where: Record<string, unknown> = {};

    if (search) {
      where.OR = [
        { telegramId: { contains: search, mode: 'insensitive' } },
        { sellerName: { contains: search, mode: 'insensitive' } },
        { sheetName: { contains: search, mode: 'insensitive' } },
        { email: { contains: search, mode: 'insensitive' } },
        { sellerCode: { contains: search, mode: 'insensitive' } },
      ];
    }

    if (isActive !== null && isActive !== undefined && isActive !== '') {
      where.isActive = isActive === 'true';
    }

    const [sellers, total] = await Promise.all([
      prisma.seller.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
      }),
      prisma.seller.count({ where }),
    ]);

    return NextResponse.json({
      success: true,
      data: sellers,
      total,
      page,
      limit,
      hasMore: skip + sellers.length < total,
    });
  } catch (error) {
    console.error('Error fetching sellers:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải danh sách seller: ${message}` },
      { status: 500 }
    );
  }
}

// POST /api/config/sellers - Create new seller
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate input
    const result = sellerSchema.safeParse(body);
    if (!result.success) {
      const errors = result.error.issues.map((e) => e.message).join(', ');
      return NextResponse.json(
        { success: false, error: errors },
        { status: 400 }
      );
    }

    const data = transformSellerData(result.data);

    // Check if telegramId already exists
    const existingTelegram = await prisma.seller.findUnique({
      where: { telegramId: data.telegramId },
    });

    if (existingTelegram) {
      return NextResponse.json(
        { success: false, error: `Telegram ID "${data.telegramId}" đã tồn tại` },
        { status: 400 }
      );
    }

    // Check if sellerCode already exists
    const existingCode = await prisma.seller.findUnique({
      where: { sellerCode: data.sellerCode },
    });

    if (existingCode) {
      return NextResponse.json(
        { success: false, error: `Mã seller "${data.sellerCode}" đã được sử dụng` },
        { status: 400 }
      );
    }

    const seller = await prisma.seller.create({
      data,
    });

    return NextResponse.json(
      { success: true, data: seller },
      { status: 201 }
    );
  } catch (error) {
    console.error('Error creating seller:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo seller: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/config/user/me/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { getSessionUser, unauthorizedResponse } from '@/lib/auth-utils';

/**
 * GET /api/config/user/me
 * Get current user's configuration (permissions, settings)
 */
export async function GET(_request: NextRequest) {
  try {
    // Get current user from session
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    // Fetch user config from database
    const config = await prisma.configUser.findUnique({
      where: { userId: user.id },
    });

    return NextResponse.json({
      success: true,
      data: {
        userId: user.id,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          role: user.role,
        },
        canViewAll: config?.canViewAll ?? user.role !== 'SELLER',
        sellerCode: config?.sellerCode ?? null,
      },
    });
  } catch (error) {
    console.error('Error fetching user config:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to fetch user config' },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/config/user/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { requireAdmin } from '@/lib/auth-utils';

// GET /api/config/user - List all user configs (admin only)
export async function GET(_request: NextRequest) {
  try {
    // Verify admin role
    const { error } = await requireAdmin();
    if (error) return error;

    const configs = await prisma.configUser.findMany({
      include: {
        user: { select: { id: true, name: true, email: true, role: true } },
      },
      orderBy: { createdAt: 'desc' },
    });

    return NextResponse.json({ success: true, data: configs });
  } catch (error) {
    console.error('Error fetching user configs:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải cấu hình người dùng: ${message}` },
      { status: 500 }
    );
  }
}

// POST /api/config/user - Create/update user config (admin only)
export async function POST(request: NextRequest) {
  try {
    // Verify admin role
    const { error } = await requireAdmin();
    if (error) return error;

    const body = await request.json();

    // Validate required fields
    if (!body.userId || !body.sellerCode) {
      return NextResponse.json(
        { success: false, error: 'Thiếu thông tin bắt buộc: userId, sellerCode' },
        { status: 400 }
      );
    }

    // Validate sellerCode format (single char A-Z)
    if (!/^[A-Z]$/.test(body.sellerCode)) {
      return NextResponse.json(
        { success: false, error: 'Mã seller phải là 1 ký tự chữ in hoa (A-Z)' },
        { status: 400 }
      );
    }

    // Check if user exists
    const user = await prisma.user.findUnique({
      where: { id: body.userId },
      select: { id: true, name: true },
    });

    if (!user) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy người dùng' },
        { status: 404 }
      );
    }

    // Check if sellerCode is already used by another user
    const existingCode = await prisma.configUser.findFirst({
      where: {
        sellerCode: body.sellerCode,
        userId: { not: body.userId },
      },
    });

    if (existingCode) {
      return NextResponse.json(
        { success: false, error: `Mã seller "${body.sellerCode}" đã được sử dụng` },
        { status: 400 }
      );
    }

    const config = await prisma.configUser.upsert({
      where: { userId: body.userId },
      update: {
        sellerCode: body.sellerCode,
        canViewAll: body.canViewAll ?? false,
      },
      create: {
        userId: body.userId,
        sellerCode: body.sellerCode,
        canViewAll: body.canViewAll ?? false,
      },
      include: {
        user: { select: { id: true, name: true, email: true, role: true } },
      },
    });

    return NextResponse.json({ success: true, data: config });
  } catch (error) {
    console.error('Error upserting user config:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi lưu cấu hình người dùng: ${message}` },
      { status: 500 }
    );
  }
}

// DELETE /api/config/user - Delete user config (admin only)
export async function DELETE(request: NextRequest) {
  try {
    // Verify admin role
    const { error } = await requireAdmin();
    if (error) return error;

    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');

    if (!userId) {
      return NextResponse.json(
        { success: false, error: 'Thiếu userId' },
        { status: 400 }
      );
    }

    const existing = await prisma.configUser.findUnique({
      where: { userId },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy cấu hình người dùng' },
        { status: 404 }
      );
    }

    await prisma.configUser.delete({ where: { userId } });

    return NextResponse.json({ success: true, message: 'Đã xóa cấu hình người dùng' });
  } catch (error) {
    console.error('Error deleting user config:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi xóa cấu hình người dùng: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createOperatorHistory, diffObjects } from '@/lib/operator-history';
import {
  updateOperatorApiSchema,
  extractOperatorZodErrors,
} from '@/lib/validations/operator-validation';

// GET /api/operators/[id]
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;

    const operator = await prisma.operator.findUnique({
      where: { id },
      include: {
        request: { select: { code: true, customerName: true, status: true } },
        supplierRef: { select: { code: true, name: true, paymentModel: true, bankAccount: true } },
        history: {
          orderBy: { createdAt: 'desc' },
          take: 20,
        },
      },
    });

    if (!operator) {
      return NextResponse.json(
        { success: false, error: 'Dịch vụ không tồn tại' },
        { status: 404 }
      );
    }

    // Compute debt = totalCost - paidAmount
    const totalCost = Number(operator.totalCost) || 0;
    const paidAmount = Number(operator.paidAmount) || 0;
    const debt = totalCost - paidAmount;

    return NextResponse.json({
      success: true,
      data: { ...operator, debt }
    });
  } catch (error) {
    console.error('Error fetching operator:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải dịch vụ: ${message}` },
      { status: 500 }
    );
  }
}

// PUT /api/operators/[id]
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();

    // Validate with Zod schema
    const validation = updateOperatorApiSchema.safeParse(body);
    if (!validation.success) {
      const errors = extractOperatorZodErrors(validation.error);
      return NextResponse.json(
        { success: false, error: 'Dữ liệu không hợp lệ', errors },
        { status: 400 }
      );
    }

    const validatedData = validation.data;

    // Get existing operator
    const existing = await prisma.operator.findUnique({ where: { id } });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Dịch vụ không tồn tại' },
        { status: 404 }
      );
    }

    // Check if locked
    if (existing.isLocked) {
      return NextResponse.json(
        { success: false, error: 'Dịch vụ đã khóa, không thể chỉnh sửa' },
        { status: 403 }
      );
    }

    // Prepare update data from validated input
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateData: Record<string, any> = {};

    if (validatedData.supplierId !== undefined) updateData.supplierId = validatedData.supplierId || null;
    if (validatedData.serviceDate !== undefined) updateData.serviceDate = new Date(validatedData.serviceDate);
    if (validatedData.serviceType !== undefined) updateData.serviceType = validatedData.serviceType;
    if (validatedData.serviceName !== undefined) updateData.serviceName = validatedData.serviceName.trim();
    if (validatedData.supplier !== undefined) updateData.supplier = validatedData.supplier?.trim() || null;
    if (validatedData.costBeforeTax !== undefined) updateData.costBeforeTax = validatedData.costBeforeTax;
    if (validatedData.vat !== undefined) updateData.vat = validatedData.vat ?? null;
    if (validatedData.totalCost !== undefined) updateData.totalCost = validatedData.totalCost;
    if (validatedData.paymentDeadline !== undefined) {
      updateData.paymentDeadline = validatedData.paymentDeadline ? new Date(validatedData.paymentDeadline) : null;
    }
    if (validatedData.bankAccount !== undefined) updateData.bankAccount = validatedData.bankAccount?.trim() || null;
    if (validatedData.notes !== undefined) updateData.notes = validatedData.notes?.trim() || null;

    // Handle paidAmount with cross-field validation
    if (validatedData.paidAmount !== undefined) {
      const paidAmount = validatedData.paidAmount;
      const totalCost = validatedData.totalCost !== undefined
        ? validatedData.totalCost
        : Number(existing.totalCost);

      // Additional cross-field validation
      if (paidAmount > totalCost) {
        return NextResponse.json(
          { success: false, error: 'Số tiền thanh toán không được lớn hơn tổng chi phí', errors: { paidAmount: 'Vượt quá tổng chi phí' } },
          { status: 400 }
        );
      }
      updateData.paidAmount = paidAmount;

      // Auto-update paymentStatus based on paidAmount
      if (paidAmount === 0) {
        updateData.paymentStatus = 'PENDING';
      } else if (paidAmount >= totalCost) {
        updateData.paymentStatus = 'PAID';
      } else {
        updateData.paymentStatus = 'PARTIAL';
      }
    }

    // Update operator
    const operator = await prisma.operator.update({
      where: { id },
      data: updateData,
      include: {
        request: { select: { code: true, customerName: true } },
        supplierRef: { select: { code: true, name: true } },
      },
    });

    // Create history entry if there are changes
    const changes = diffObjects(
      JSON.parse(JSON.stringify(existing)),
      JSON.parse(JSON.stringify(operator))
    );

    if (Object.keys(changes).length > 0) {
      await createOperatorHistory({
        operatorId: id,
        action: 'UPDATE',
        changes,
        userId: validatedData.userId || 'system',
      });
    }

    return NextResponse.json({ success: true, data: operator });
  } catch (error) {
    console.error('Error updating operator:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi cập nhật: ${message}` },
      { status: 500 }
    );
  }
}

// DELETE /api/operators/[id]
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId') || 'system';

    // Get existing
    const existing = await prisma.operator.findUnique({ where: { id } });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Dịch vụ không tồn tại' },
        { status: 404 }
      );
    }

    // Check if locked
    if (existing.isLocked) {
      return NextResponse.json(
        { success: false, error: 'Dịch vụ đã khóa, không thể xóa' },
        { status: 403 }
      );
    }

    // Create history before delete
    await createOperatorHistory({
      operatorId: id,
      action: 'DELETE',
      changes: { deleted: { before: { id: existing.id, serviceName: existing.serviceName }, after: null } },
      userId,
    });

    // Delete operator (history will cascade delete)
    await prisma.operator.delete({ where: { id } });

    return NextResponse.json({ success: true, data: { id } });
  } catch (error) {
    console.error('Error deleting operator:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi xóa: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/[id]/unlock/route.ts">
// POST /api/operators/[id]/unlock - Unlock operator at specific tier
import { NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createOperatorHistory } from '@/lib/operator-history';
import { getSessionUser, unauthorizedResponse, forbiddenResponse } from '@/lib/auth-utils';
import {
  canUnlock,
  canUnlockTier,
  getLockFields,
  getLockHistoryAction,
  hasAnyLock,
  type LockTier,
  LOCK_TIERS,
} from '@/lib/lock-utils';

export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const { id } = await params;
    const body = await request.json();
    const tier = (body.tier as LockTier) || 'KT';

    // Validate tier
    if (!LOCK_TIERS.includes(tier)) {
      return NextResponse.json(
        { success: false, error: `Tier không hợp lệ: ${tier}` },
        { status: 400 }
      );
    }

    // Check permission for this tier
    if (!canUnlock(user.role, tier)) {
      return forbiddenResponse(`Không có quyền mở khóa tier: ${tier}`);
    }

    // Get current operator state
    const operator = await prisma.operator.findUnique({
      where: { id },
      select: {
        id: true,
        lockKT: true,
        lockAdmin: true,
        lockFinal: true,
        serviceName: true,
      },
    });

    if (!operator) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy dịch vụ' },
        { status: 404 }
      );
    }

    // Validate unlock order (reverse: Final → Admin → KT)
    const lockState = {
      lockKT: operator.lockKT,
      lockAdmin: operator.lockAdmin,
      lockFinal: operator.lockFinal,
    };

    if (!canUnlockTier(lockState, tier)) {
      return NextResponse.json(
        {
          success: false,
          error: `Không thể mở khóa tier ${tier}. Phải theo thứ tự ngược: Final → Admin → KT`,
          currentState: lockState,
        },
        { status: 400 }
      );
    }

    // Apply unlock
    const unlockFields = getLockFields(tier, user.id, false);
    
    // Calculate new lock state after unlock
    const newLockState = {
      lockKT: tier === 'KT' ? false : lockState.lockKT,
      lockAdmin: tier === 'Admin' ? false : lockState.lockAdmin,
      lockFinal: tier === 'Final' ? false : lockState.lockFinal,
    };
    
    // Update legacy isLocked based on whether any locks remain
    const anyLockRemains = hasAnyLock(newLockState);
    
    const updated = await prisma.operator.update({
      where: { id },
      data: {
        ...unlockFields,
        isLocked: anyLockRemains, // Sync legacy field
        lockedAt: anyLockRemains ? undefined : null,
        lockedBy: anyLockRemains ? undefined : null,
      },
    });

    // Create history entry
    await createOperatorHistory({
      operatorId: id,
      action: getLockHistoryAction(tier, false),
      changes: { tier, ...unlockFields },
      userId: user.id,
    });

    return NextResponse.json({
      success: true,
      data: { tier, operator: updated },
    });
  } catch (error) {
    console.error('Unlock operator error:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi mở khóa dịch vụ: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/operators/lock-period/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { getSessionUser, unauthorizedResponse, forbiddenResponse } from '@/lib/auth-utils';
import {
  canLock,
  getLockFields,
  getLockHistoryAction,
  type LockTier,
  LOCK_TIERS,
} from '@/lib/lock-utils';

// POST /api/operators/lock-period - Lock operators in a period at specific tier
export async function POST(request: NextRequest) {
  try {
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const body = await request.json();
    const tier = (body.tier as LockTier) || 'KT';

    // Validate month format YYYY-MM
    if (!body.month || !/^\d{4}-\d{2}$/.test(body.month)) {
      return NextResponse.json(
        { success: false, error: 'Định dạng tháng không hợp lệ (YYYY-MM)' },
        { status: 400 }
      );
    }

    // Validate tier
    if (!LOCK_TIERS.includes(tier)) {
      return NextResponse.json(
        { success: false, error: `Tier không hợp lệ: ${tier}` },
        { status: 400 }
      );
    }

    // Check permission for this tier
    if (!canLock(user.role, tier)) {
      return forbiddenResponse(`Không có quyền khóa tier: ${tier}`);
    }

    // Parse month range
    const [year, month] = body.month.split('-').map(Number);
    const startDate = new Date(year, month - 1, 1);
    const endDate = new Date(year, month, 0, 23, 59, 59, 999);

    // Build where clause based on tier progression
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const whereClause: Record<string, any> = {
      serviceDate: { gte: startDate, lte: endDate },
    };

    // KT: not yet locked at KT
    // Admin: locked at KT but not Admin
    // Final: locked at Admin but not Final
    if (tier === 'KT') {
      whereClause.lockKT = false;
    } else if (tier === 'Admin') {
      whereClause.lockKT = true;
      whereClause.lockAdmin = false;
    } else if (tier === 'Final') {
      whereClause.lockAdmin = true;
      whereClause.lockFinal = false;
    }

    // Find operators eligible for this tier lock
    const operators = await prisma.operator.findMany({
      where: whereClause,
      select: { id: true },
    });

    if (operators.length === 0) {
      return NextResponse.json({
        success: true,
        data: { count: 0, tier, message: 'Không có dịch vụ cần khóa tier này' },
      });
    }

    // Apply lock in transaction
    const lockFields = getLockFields(tier, user.id, true);
    const lockedAt = new Date();

    await prisma.$transaction(async (tx) => {
      // Update all operators with tier lock + legacy sync
      await tx.operator.updateMany({
        where: { id: { in: operators.map((o) => o.id) } },
        data: {
          ...lockFields,
          isLocked: true, // Sync legacy field
          lockedAt,
          lockedBy: user.id,
        },
      });

      // Create history entries
      await tx.operatorHistory.createMany({
        data: operators.map((op) => ({
          operatorId: op.id,
          action: getLockHistoryAction(tier, true),
          changes: { tier, batch: true, month: body.month },
          userId: user.id,
        })),
      });
    });

    return NextResponse.json({
      success: true,
      data: {
        count: operators.length,
        tier,
        period: body.month,
        lockedAt,
      },
    });
  } catch (error) {
    console.error('Error locking period:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi khóa kỳ: ${message}` },
      { status: 500 }
    );
  }
}

// GET /api/operators/lock-period - Get lock status by month with tier breakdown
export async function GET(request: NextRequest) {
  try {
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const { searchParams } = new URL(request.url);
    const month = searchParams.get('month');
    const tier = searchParams.get('tier') as LockTier | null;

    if (!month || !/^\d{4}-\d{2}$/.test(month)) {
      return NextResponse.json(
        { success: false, error: 'Định dạng tháng không hợp lệ' },
        { status: 400 }
      );
    }

    const [year, m] = month.split('-').map(Number);
    const startDate = new Date(year, m - 1, 1);
    const endDate = new Date(year, m, 0, 23, 59, 59, 999);

    const baseWhere = { serviceDate: { gte: startDate, lte: endDate } };

    // If specific tier requested, return operators eligible for that tier
    if (tier && LOCK_TIERS.includes(tier)) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const whereClause: Record<string, any> = { ...baseWhere };

      if (tier === 'KT') {
        whereClause.lockKT = false;
      } else if (tier === 'Admin') {
        whereClause.lockKT = true;
        whereClause.lockAdmin = false;
      } else if (tier === 'Final') {
        whereClause.lockAdmin = true;
        whereClause.lockFinal = false;
      }

      const operators = await prisma.operator.findMany({
        where: whereClause,
        select: {
          id: true,
          serviceName: true,
          serviceDate: true,
          totalCost: true,
          lockKT: true,
          lockAdmin: true,
          lockFinal: true,
        },
        orderBy: { serviceDate: 'asc' },
      });

      return NextResponse.json({
        success: true,
        data: { month, tier, count: operators.length, operators },
      });
    }

    // Return full tier breakdown
    const [total, lockedKT, lockedAdmin, lockedFinal, unlocked] = await Promise.all([
      prisma.operator.count({ where: baseWhere }),
      prisma.operator.count({ where: { ...baseWhere, lockKT: true } }),
      prisma.operator.count({ where: { ...baseWhere, lockAdmin: true } }),
      prisma.operator.count({ where: { ...baseWhere, lockFinal: true } }),
      prisma.operator.count({ where: { ...baseWhere, lockKT: false } }),
    ]);

    return NextResponse.json({
      success: true,
      data: {
        month,
        total,
        tiers: {
          KT: lockedKT,
          Admin: lockedAdmin,
          Final: lockedFinal,
        },
        unlocked,
        isFullyLocked: lockedFinal === total && total > 0,
      },
    });
  } catch (error) {
    console.error('Error getting lock status:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: message },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/login/__tests__/login-form.test.tsx">
import { render, screen, fireEvent, waitFor, act } from "@testing-library/react";
import { LoginForm } from "../login-form";

/**
 * Test suite for LoginForm component
 *
 * Note: This test suite has limitations due to mocking next-auth/react which uses ESM.
 * The component is tested through integration testing rather than full unit mocking.
 * Key scenarios tested:
 * - Form rendering
 * - Validation schema (tested separately)
 * - User interactions
 */

// Mock next-auth/react with simple module mock
// Return resolved promise to prevent async state update warnings
jest.mock("next-auth/react", () => ({
  signIn: jest.fn().mockResolvedValue({ ok: true }),
}));

// Mock next/navigation
jest.mock("next/navigation", () => ({
  useRouter: () => ({
    push: jest.fn(),
    refresh: jest.fn(),
  }),
  useSearchParams: () => ({
    get: jest.fn(() => null),
  }),
}));

// Mock sonner toast
jest.mock("sonner", () => ({
  toast: {
    error: jest.fn(),
    success: jest.fn(),
  },
}));

describe("LoginForm Component", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("Rendering", () => {
    it("renders login form without errors", () => {
      render(<LoginForm />);

      expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/mat khau/i)).toBeInTheDocument();
      expect(screen.getByRole("button", { name: /dang nhap/i })).toBeInTheDocument();
    });

    it("renders email and password inputs with correct attributes", () => {
      render(<LoginForm />);

      const emailInput = screen.getByPlaceholderText("email@example.com") as HTMLInputElement;
      const passwordInput = screen.getByPlaceholderText("••••••••") as HTMLInputElement;

      expect(emailInput).toBeInTheDocument();
      expect(emailInput.type).toBe("email");
      expect(emailInput).toHaveAttribute("id", "email");

      expect(passwordInput).toBeInTheDocument();
      expect(passwordInput.type).toBe("password");
      expect(passwordInput).toHaveAttribute("id", "password");
    });

    it("renders submit button in initial state", () => {
      render(<LoginForm />);

      const button = screen.getByRole("button", { name: /dang nhap/i });
      expect(button).not.toBeDisabled();
      expect(button).toHaveTextContent("Dang nhap");
    });

    it("renders form labels", () => {
      render(<LoginForm />);

      expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/mat khau/i)).toBeInTheDocument();
    });
  });

  describe("Form Validation - Email", () => {
    it("validates empty email field on submit", async () => {
      render(<LoginForm />);

      const submitButton = screen.getByRole("button", { name: /dang nhap/i });

      // Leave email empty and submit
      fireEvent.click(submitButton);

      // Expect validation error (email is required)
      await waitFor(() => {
        const errors = screen.queryAllByText(/email|khong hop le|bat buoc/i);
        expect(errors.length).toBeGreaterThan(0);
      });
    });

    it("allows typing invalid email format into field", () => {
      render(<LoginForm />);

      const emailInput = screen.getByLabelText(/email/i) as HTMLInputElement;
      fireEvent.change(emailInput, { target: { value: "invalid-email" } });

      // Verify value was set (validation happens on submit, tested in validation schema tests)
      expect(emailInput.value).toBe("invalid-email");
    });

    it("accepts valid email format", async () => {
      render(<LoginForm />);

      const emailInput = screen.getByLabelText(/email/i) as HTMLInputElement;
      const passwordInput = screen.getByLabelText(/mat khau/i) as HTMLInputElement;

      fireEvent.change(emailInput, { target: { value: "test@example.com" } });
      fireEvent.change(passwordInput, { target: { value: "password123" } });

      // Should not show email validation error
      expect(screen.queryByText(/email khong hop le/i)).not.toBeInTheDocument();
    });
  });

  describe("Form Validation - Password", () => {
    it("validates empty password field on submit", async () => {
      render(<LoginForm />);

      const emailInput = screen.getByLabelText(/email/i) as HTMLInputElement;
      const submitButton = screen.getByRole("button", { name: /dang nhap/i });

      await act(async () => {
        fireEvent.change(emailInput, { target: { value: "test@example.com" } });
        fireEvent.click(submitButton);
      });

      await waitFor(() => {
        expect(screen.getByText(/mat khau bat buoc/i)).toBeInTheDocument();
      });
    });

    it("accepts non-empty password", async () => {
      render(<LoginForm />);

      const emailInput = screen.getByLabelText(/email/i) as HTMLInputElement;
      const passwordInput = screen.getByLabelText(/mat khau/i) as HTMLInputElement;

      fireEvent.change(emailInput, { target: { value: "test@example.com" } });
      fireEvent.change(passwordInput, { target: { value: "password123" } });

      // Should not show password validation error
      expect(screen.queryByText(/mat khau bat buoc/i)).not.toBeInTheDocument();
    });
  });

  describe("Form Structure", () => {
    it("renders form with proper structure", () => {
      const { container } = render(<LoginForm />);

      const form = container.querySelector("form");
      expect(form).toBeInTheDocument();
      expect(form).toHaveClass("space-y-4");
    });

    it("groups form inputs in container divs", () => {
      const { container } = render(<LoginForm />);

      const spaceDivs = container.querySelectorAll(".space-y-2");
      expect(spaceDivs.length).toBeGreaterThanOrEqual(2); // At least email and password groups
    });

    it("renders input elements within form", () => {
      const { container } = render(<LoginForm />);

      const form = container.querySelector("form");
      expect(form).toContainElement(screen.getByPlaceholderText("email@example.com"));
      expect(form).toContainElement(screen.getByPlaceholderText("••••••••"));
    });
  });

  describe("User Interaction Handling", () => {
    it("allows user to type in email field", () => {
      render(<LoginForm />);

      const emailInput = screen.getByPlaceholderText("email@example.com") as HTMLInputElement;
      fireEvent.change(emailInput, { target: { value: "user@example.com" } });

      expect(emailInput.value).toBe("user@example.com");
    });

    it("allows user to type in password field", () => {
      render(<LoginForm />);

      const passwordInput = screen.getByPlaceholderText("••••••••") as HTMLInputElement;
      fireEvent.change(passwordInput, { target: { value: "secret123" } });

      expect(passwordInput.value).toBe("secret123");
    });

    it("handles form submission event", async () => {
      render(<LoginForm />);

      const emailInput = screen.getByLabelText(/email/i) as HTMLInputElement;
      const passwordInput = screen.getByLabelText(/mat khau/i) as HTMLInputElement;
      const submitButton = screen.getByRole("button", { name: /dang nhap/i });

      await act(async () => {
        fireEvent.change(emailInput, { target: { value: "test@example.com" } });
        fireEvent.change(passwordInput, { target: { value: "password123" } });
        fireEvent.click(submitButton);
      });

      // Wait for async state updates to complete
      await waitFor(() => {
        expect(submitButton).toBeInTheDocument();
      });
    });
  });

  describe("Accessibility", () => {
    it("associates labels with input fields", () => {
      render(<LoginForm />);

      const emailLabel = screen.getByLabelText(/email/i);
      const passwordLabel = screen.getByLabelText(/mat khau/i);

      expect(emailLabel).toHaveAttribute("type", "email");
      expect(passwordLabel).toHaveAttribute("type", "password");
    });

    it("submit button is accessible via keyboard", () => {
      render(<LoginForm />);

      const button = screen.getByRole("button", { name: /dang nhap/i });
      expect(button).not.toBeDisabled();
    });

    it("uses proper ARIA attributes on inputs", () => {
      render(<LoginForm />);

      const emailInput = screen.getByLabelText(/email/i);
      const passwordInput = screen.getByLabelText(/mat khau/i);

      // Inputs should be associated with labels
      expect(emailInput.id).toBeTruthy();
      expect(passwordInput.id).toBeTruthy();
    });
  });

  describe("Error Display", () => {
    it("displays validation errors below fields", async () => {
      render(<LoginForm />);

      const submitButton = screen.getByRole("button", { name: /dang nhap/i });
      fireEvent.click(submitButton);

      await waitFor(() => {
        // Should show at least one validation error
        const errors = screen.queryAllByText(/khong hop le|bat buoc/i);
        expect(errors.length).toBeGreaterThan(0);
      });
    });

    it("displays errors in red text", async () => {
      render(<LoginForm />);

      const submitButton = screen.getByRole("button", { name: /dang nhap/i });
      fireEvent.click(submitButton);

      await waitFor(() => {
        const errorElements = screen.queryAllByText(/khong hop le|bat buoc/i);
        errorElements.forEach((el) => {
          expect(el).toHaveClass("text-red-500");
        });
      });
    });
  });

  describe("Button State Management", () => {
    it("button is clickable in initial state", () => {
      render(<LoginForm />);

      const button = screen.getByRole("button", { name: /dang nhap/i });
      expect(button).not.toBeDisabled();
    });

    it("button text is Dang nhap in initial state", () => {
      render(<LoginForm />);

      const button = screen.getByRole("button", { name: /dang nhap/i });
      expect(button.textContent).toContain("Dang nhap");
    });
  });
});
</file>

<file path="src/auth.ts">
/**
 * Full NextAuth configuration with database access
 *
 * This file contains the complete auth setup including:
 * - Database user lookup (Prisma)
 * - Password verification (bcryptjs)
 *
 * Used by: API routes, server components (Node.js runtime only)
 * For edge runtime (middleware), use auth.config.ts instead
 */
import NextAuth from "next-auth";
import Credentials from "next-auth/providers/credentials";
import { compare } from "bcryptjs";
import { prisma } from "@/lib/db";
import { authConfig } from "./auth.config";

// Validate AUTH_SECRET at startup
if (!process.env.AUTH_SECRET || process.env.AUTH_SECRET.length < 32) {
  throw new Error(
    "AUTH_SECRET must be set and at least 32 characters. Generate: openssl rand -base64 32"
  );
}

// Dummy hash for timing attack prevention
const DUMMY_HASH = "$2a$10$dummyHashToPreventTimingAttackXXXXXXXXXXXXXX";

export const { handlers, signIn, signOut, auth } = NextAuth({
  ...authConfig,
  // Override providers with full authorize function (requires Node.js)
  providers: [
    Credentials({
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email as string },
          select: {
            id: true,
            email: true,
            name: true,
            password: true,
            role: true,
          },
        });

        // Always run bcrypt to prevent timing attacks
        const hashedPassword = user?.password ?? DUMMY_HASH;
        const isValid = await compare(
          credentials.password as string,
          hashedPassword
        );

        if (!user || !user.password || !isValid) {
          return null;
        }

        return {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
        };
      },
    }),
  ],
});
</file>

<file path="src/components/operators/operator-approval-table.tsx">
'use client';

import { useState } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Checkbox } from '@/components/ui/checkbox';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ErrorFallback } from '@/components/ui/error-fallback';
import { safeParseFloat } from '@/lib/utils/parse-utils';
import type { ApprovalQueueItem } from '@/types';

interface Props {
  items: ApprovalQueueItem[];
  onApprove: (ids: string[], paymentDate: Date) => Promise<void>;
  loading?: boolean;
  error?: string | null;
  onRetry?: () => void;
}

const formatCurrency = (value: number) => {
  return new Intl.NumberFormat('vi-VN').format(value);
};

const formatDate = (date: Date | string | null) => {
  if (!date) return '-';
  return new Date(date).toLocaleDateString('vi-VN');
};

export function OperatorApprovalTable({ items, onApprove, loading, error, onRetry }: Props) {
  const [selected, setSelected] = useState<Set<string>>(new Set());
  const [approving, setApproving] = useState(false);

  const toggleSelect = (id: string) => {
    const newSelected = new Set(selected);
    if (newSelected.has(id)) {
      newSelected.delete(id);
    } else {
      newSelected.add(id);
    }
    setSelected(newSelected);
  };

  const toggleAll = () => {
    if (selected.size === items.length) {
      setSelected(new Set());
    } else {
      setSelected(new Set(items.map((i) => i.id)));
    }
  };

  const handleBatchApprove = async () => {
    if (selected.size === 0) return;
    setApproving(true);
    try {
      await onApprove(Array.from(selected), new Date());
      setSelected(new Set());
    } finally {
      setApproving(false);
    }
  };

  const handleSingleApprove = async (id: string) => {
    setApproving(true);
    try {
      await onApprove([id], new Date());
    } finally {
      setApproving(false);
    }
  };

  if (error) {
    return (
      <ErrorFallback
        title="Lỗi tải danh sách duyệt"
        message={error}
        onRetry={onRetry}
        retryLabel="Thử lại"
      />
    );
  }

  if (loading) {
    return <div className="text-center py-10 text-muted-foreground">Đang tải...</div>;
  }

  if (items.length === 0) {
    return (
      <div className="text-center py-10 text-muted-foreground">
        Không có dịch vụ nào chờ duyệt
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* Batch actions */}
      {selected.size > 0 && (
        <div className="flex items-center gap-4 p-4 bg-blue-50 rounded-lg">
          <span className="text-sm">Đã chọn {selected.size} dịch vụ</span>
          <Button onClick={handleBatchApprove} disabled={approving} size="sm">
            {approving ? 'Đang xử lý...' : 'Duyệt tất cả'}
          </Button>
          <Button variant="outline" onClick={() => setSelected(new Set())} size="sm">
            Bỏ chọn
          </Button>
        </div>
      )}

      {/* Table */}
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead className="w-12">
              <Checkbox
                checked={selected.size === items.length && items.length > 0}
                onCheckedChange={toggleAll}
              />
            </TableHead>
            <TableHead>Booking</TableHead>
            <TableHead>Ngày DV</TableHead>
            <TableHead>Dịch vụ</TableHead>
            <TableHead>NCC</TableHead>
            <TableHead className="text-right">Tổng CP</TableHead>
            <TableHead className="text-right">Đã TT</TableHead>
            <TableHead className="text-right">Còn nợ</TableHead>
            <TableHead>Hạn TT</TableHead>
            <TableHead className="text-center">Trạng thái</TableHead>
            <TableHead></TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {items.map((item) => (
            <TableRow
              key={item.id}
              className={item.daysOverdue > 0 ? 'bg-red-50' : ''}
            >
              <TableCell>
                <Checkbox
                  checked={selected.has(item.id)}
                  onCheckedChange={() => toggleSelect(item.id)}
                  disabled={item.isLocked}
                />
              </TableCell>
              <TableCell>
                <div className="font-medium">{item.requestCode}</div>
                <div className="text-sm text-gray-500">{item.customerName}</div>
              </TableCell>
              <TableCell className="whitespace-nowrap">
                {formatDate(item.serviceDate)}
              </TableCell>
              <TableCell>
                <div>{item.serviceName}</div>
                <div className="text-sm text-gray-500">{item.serviceType}</div>
              </TableCell>
              <TableCell>{item.supplierName || '-'}</TableCell>
              <TableCell className="text-right font-medium">
                {formatCurrency(safeParseFloat(item.totalCost, 0))} ₫
              </TableCell>
              <TableCell className="text-right text-green-600">
                {formatCurrency(safeParseFloat(item.paidAmount, 0))} ₫
              </TableCell>
              <TableCell className={`text-right font-medium ${safeParseFloat(item.debt, 0) > 0 ? 'text-red-600' : 'text-green-600'}`}>
                {formatCurrency(safeParseFloat(item.debt, 0))} ₫
              </TableCell>
              <TableCell className="whitespace-nowrap">
                {formatDate(item.paymentDeadline)}
              </TableCell>
              <TableCell className="text-center">
                {item.daysOverdue > 0 ? (
                  <Badge variant="destructive">Quá hạn {item.daysOverdue} ngày</Badge>
                ) : item.daysOverdue === 0 ? (
                  <Badge className="bg-yellow-500 hover:bg-yellow-500">Hôm nay</Badge>
                ) : (
                  <Badge variant="secondary">Còn {Math.abs(item.daysOverdue)} ngày</Badge>
                )}
              </TableCell>
              <TableCell>
                <Button
                  size="sm"
                  onClick={() => handleSingleApprove(item.id)}
                  disabled={item.isLocked || approving}
                >
                  Duyệt
                </Button>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}
</file>

<file path="src/components/operators/operator-history-panel.tsx">
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { History, Plus, Edit, Trash2, Lock, Unlock, CheckCircle, Users } from 'lucide-react';
import { HISTORY_ACTIONS, type HistoryActionKey } from '@/config/operator-config';
import type { OperatorHistoryEntry } from '@/types';

interface OperatorHistoryPanelProps {
  history: OperatorHistoryEntry[];
}

// Icon mapping for all action types (including 3-tier locks)
const ACTION_ICONS: Record<string, typeof Plus> = {
  CREATE: Plus,
  UPDATE: Edit,
  DELETE: Trash2,
  LOCK: Lock,
  UNLOCK: Unlock,
  LOCK_KT: Lock,
  UNLOCK_KT: Unlock,
  LOCK_ADMIN: Lock,
  UNLOCK_ADMIN: Unlock,
  LOCK_FINAL: Lock,
  UNLOCK_FINAL: Unlock,
  APPROVE: CheckCircle,
};

export function OperatorHistoryPanel({ history }: OperatorHistoryPanelProps) {
  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleString('vi-VN', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const formatFieldName = (field: string): string => {
    const fieldLabels: Record<string, string> = {
      serviceName: 'Tên dịch vụ',
      serviceType: 'Loại dịch vụ',
      serviceDate: 'Ngày dịch vụ',
      supplier: 'Nhà cung cấp',
      supplierId: 'ID NCC',
      costBeforeTax: 'Chi phí trước thuế',
      vat: 'VAT',
      totalCost: 'Tổng chi phí',
      paymentDeadline: 'Hạn thanh toán',
      paymentStatus: 'Trạng thái TT',
      paidAmount: 'Số tiền đã TT',
      paidAt: 'Ngày thanh toán',
      bankAccount: 'TK ngân hàng',
      notes: 'Ghi chú',
      isLocked: 'Khóa sổ',
      lockedAt: 'Ngày khóa',
      lockedBy: 'Người khóa',
      // 3-tier lock fields
      lockKT: 'Khóa KT',
      lockKTAt: 'Ngày khóa KT',
      lockKTBy: 'Người khóa KT',
      lockAdmin: 'Khóa Admin',
      lockAdminAt: 'Ngày khóa Admin',
      lockAdminBy: 'Người khóa Admin',
      lockFinal: 'Khóa Cuối',
      lockFinalAt: 'Ngày khóa Cuối',
      lockFinalBy: 'Người khóa Cuối',
      tier: 'Mức khóa',
      batch: 'Hàng loạt',
      month: 'Tháng',
      created: 'Tạo mới',
      deleted: 'Xóa',
    };
    return fieldLabels[field] || field;
  };

  const formatValue = (value: unknown): string => {
    if (value === null || value === undefined) return '(trống)';
    if (typeof value === 'boolean') return value ? 'Có' : 'Không';
    if (typeof value === 'number') {
      return new Intl.NumberFormat('vi-VN').format(value);
    }
    if (typeof value === 'string') {
      // Check if date
      if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
        return new Date(value).toLocaleDateString('vi-VN');
      }
      return value;
    }
    if (typeof value === 'object') {
      return JSON.stringify(value);
    }
    return String(value);
  };

  const getActionInfo = (action: string) => {
    const actionKey = action as HistoryActionKey;
    return HISTORY_ACTIONS[actionKey] || { label: action, color: 'gray' };
  };

  const getActionIcon = (action: string) => {
    const Icon = ACTION_ICONS[action] || Edit;
    return <Icon className="h-4 w-4" />;
  };

  // Check if action is a tier-specific lock action
  const isTierLockAction = (action: string): boolean => {
    return ['LOCK_KT', 'UNLOCK_KT', 'LOCK_ADMIN', 'UNLOCK_ADMIN', 'LOCK_FINAL', 'UNLOCK_FINAL'].includes(action);
  };

  if (!history || history.length === 0) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2 text-lg">
            <History className="h-5 w-5" />
            Lịch sử thay đổi
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground text-center py-4">
            Chưa có lịch sử thay đổi
          </p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2 text-lg">
          <History className="h-5 w-5" />
          Lịch sử thay đổi ({history.length})
        </CardTitle>
      </CardHeader>
      <CardContent>
        <ScrollArea className="h-[400px] pr-4">
          <div className="space-y-4">
            {history.map((entry) => {
              const actionInfo = getActionInfo(entry.action);
              const changes = entry.changes as Record<string, unknown>;
              const isBatchLock = changes?.batch === true;
              const tierFromChanges = changes?.tier as string | undefined;
              const monthFromChanges = changes?.month as string | undefined;

              return (
                <div
                  key={entry.id}
                  className="border-l-2 border-muted pl-4 pb-4 relative"
                >
                  {/* Timeline dot */}
                  <div className="absolute -left-[9px] top-0 h-4 w-4 rounded-full bg-background border-2 border-muted flex items-center justify-center">
                    <div className="h-2 w-2 rounded-full bg-muted" />
                  </div>

                  {/* Header */}
                  <div className="flex items-center gap-2 mb-2 flex-wrap">
                    <Badge
                      variant="outline"
                      className={`
                        ${actionInfo.color === 'green' && 'border-green-500 text-green-600'}
                        ${actionInfo.color === 'blue' && 'border-blue-500 text-blue-600'}
                        ${actionInfo.color === 'red' && 'border-red-500 text-red-600'}
                        ${actionInfo.color === 'amber' && 'border-amber-500 text-amber-600'}
                        ${actionInfo.color === 'orange' && 'border-orange-500 text-orange-600'}
                        ${actionInfo.color === 'purple' && 'border-purple-500 text-purple-600'}
                        ${actionInfo.color === 'emerald' && 'border-emerald-500 text-emerald-600'}
                      `}
                    >
                      {getActionIcon(entry.action)}
                      <span className="ml-1">{actionInfo.label}</span>
                    </Badge>

                    {/* Batch indicator */}
                    {isBatchLock && (
                      <Badge variant="secondary" className="text-xs gap-1">
                        <Users className="h-3 w-3" />
                        Hàng loạt
                      </Badge>
                    )}

                    <span className="text-sm text-muted-foreground">
                      {formatDate(entry.createdAt)}
                    </span>
                  </div>

                  {/* User */}
                  <p className="text-sm text-muted-foreground mb-2">
                    Bởi: <span className="font-medium">{entry.userId}</span>
                  </p>

                  {/* Tier-specific info for lock actions */}
                  {isTierLockAction(entry.action) && monthFromChanges && (
                    <div className="text-xs text-muted-foreground mb-2 bg-muted/50 rounded px-2 py-1 inline-block">
                      Tháng: {monthFromChanges}
                      {tierFromChanges && ` • Tier: ${tierFromChanges}`}
                    </div>
                  )}

                  {/* Changes - filter out tier/batch/month for tier locks */}
                  {changes && Object.keys(changes).length > 0 && (
                    <div className="bg-muted/50 rounded-md p-3 space-y-1">
                      {Object.entries(changes)
                        .filter(([field]) => {
                          // For tier lock actions, skip displaying these meta fields
                          if (isTierLockAction(entry.action)) {
                            return !['tier', 'batch', 'month'].includes(field);
                          }
                          return true;
                        })
                        .map(([field, change]) => {
                          // Handle both {before, after} format and direct values
                          const isObjectChange = change && typeof change === 'object' && ('before' in change || 'after' in change);
                          const changeObj = isObjectChange ? (change as { before?: unknown; after?: unknown }) : null;

                          return (
                            <div key={field} className="text-sm">
                              <span className="font-medium">{formatFieldName(field)}:</span>{' '}
                              {entry.action === 'CREATE' || entry.action === 'DELETE' || !changeObj ? (
                                <span className="text-muted-foreground">
                                  {formatValue(changeObj ? (changeObj.after ?? changeObj.before) : change)}
                                </span>
                              ) : (
                                <>
                                  <span className="line-through text-red-500/70">
                                    {formatValue(changeObj.before)}
                                  </span>
                                  {' → '}
                                  <span className="text-green-600">
                                    {formatValue(changeObj.after)}
                                  </span>
                                </>
                              )}
                            </div>
                          );
                        })}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        </ScrollArea>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/operators/operator-lock-dialog.tsx">
'use client';

import { useState } from 'react';
import { toast } from 'sonner';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Lock, Loader2, AlertCircle, Info } from 'lucide-react';
import { LOCK_TIER_LABELS } from '@/config/lock-config';
import type { LockTier } from '@/lib/lock-utils';
import type { Role } from '@/types';

interface Props {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess?: () => void;
  userRole?: Role; // To control which tiers are visible
}

interface PreviewData {
  month: string;
  tier: LockTier;
  count: number;
  operators: Array<{
    id: string;
    serviceName: string;
    serviceDate: string;
    totalCost: number;
  }>;
}

export function OperatorLockDialog({ open, onOpenChange, onSuccess, userRole = 'ACCOUNTANT' }: Props) {
  // Default month to current month
  const getDefaultMonth = () => {
    const d = new Date();
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
  };

  const [month, setMonth] = useState(getDefaultMonth);
  const [tier, setTier] = useState<LockTier>('KT');
  const [preview, setPreview] = useState<PreviewData | null>(null);
  const [loading, setLoading] = useState(false);
  const [confirming, setConfirming] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Available tiers based on role
  const availableTiers: LockTier[] =
    userRole === 'ADMIN' ? ['KT', 'Admin', 'Final'] : ['KT'];

  const handlePreview = async () => {
    setLoading(true);
    setError(null);

    try {
      const res = await fetch(
        `/api/operators/lock-period?month=${month}&tier=${tier}`
      );
      const data = await res.json();

      if (!data.success) {
        throw new Error(data.error || 'Không thể xem trước');
      }

      setPreview({
        month,
        tier,
        count: data.data.count,
        operators: data.data.operators || [],
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Lỗi xem trước');
    } finally {
      setLoading(false);
    }
  };

  const handleConfirm = async () => {
    setConfirming(true);
    setError(null);

    try {
      const res = await fetch('/api/operators/lock-period', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ month, tier }),
      });

      const data = await res.json();

      if (!data.success) {
        throw new Error(data.error || 'Không thể khóa');
      }

      toast.success(
        `Đã khóa ${data.data.count} dịch vụ với mức ${LOCK_TIER_LABELS[tier]}`
      );
      handleClose();
      onSuccess?.();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Lỗi khóa');
    } finally {
      setConfirming(false);
    }
  };

  const handleClose = () => {
    onOpenChange(false);
    // Reset state after animation
    setTimeout(() => {
      setPreview(null);
      setError(null);
      setMonth(getDefaultMonth());
      setTier('KT');
    }, 200);
  };

  const formatCurrency = (value: number) =>
    new Intl.NumberFormat('vi-VN').format(value);

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Lock className="h-5 w-5" />
            Khóa Operator theo tháng
          </DialogTitle>
          <DialogDescription>
            Chọn tháng và mức khóa để khóa tất cả operator trong kỳ
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="month">Tháng</Label>
              <Input
                id="month"
                type="month"
                value={month}
                onChange={(e) => {
                  setMonth(e.target.value);
                  setPreview(null);
                }}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="tier">Mức khóa</Label>
              <Select
                value={tier}
                onValueChange={(v) => {
                  setTier(v as LockTier);
                  setPreview(null);
                }}
              >
                <SelectTrigger id="tier">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  {availableTiers.map((t) => (
                    <SelectItem key={t} value={t}>
                      {LOCK_TIER_LABELS[t]}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Tier info */}
          <div className="flex items-start gap-2 p-3 bg-muted rounded-md">
            <Info className="h-4 w-4 text-muted-foreground mt-0.5 shrink-0" />
            <div className="text-sm text-muted-foreground">
              {tier === 'KT' && (
                <>
                  <strong>Khóa KT:</strong> Khóa các operator chưa có khóa nào.
                  KT và Admin đều có thể mở khóa.
                </>
              )}
              {tier === 'Admin' && (
                <>
                  <strong>Khóa Admin:</strong> Khóa các operator đã khóa KT nhưng chưa khóa Admin.
                  Chỉ Admin có thể mở khóa.
                </>
              )}
              {tier === 'Final' && (
                <>
                  <strong>Khóa Cuối:</strong> Khóa vĩnh viễn các operator đã khóa Admin.
                  Chỉ Admin có thể mở khóa.
                </>
              )}
            </div>
          </div>

          {error && (
            <div className="flex items-center gap-2 text-sm text-destructive p-3 bg-destructive/10 rounded-md">
              <AlertCircle className="h-4 w-4 shrink-0" />
              {error}
            </div>
          )}

          {preview && (
            <div className="rounded-lg border p-4 space-y-3">
              <div className="flex items-center justify-between">
                <span className="text-sm font-medium">Số lượng cần khóa:</span>
                <span className="text-lg font-bold">{preview.count}</span>
              </div>

              {preview.count > 0 ? (
                <>
                  <p className="text-sm text-muted-foreground">
                    Sẽ khóa {preview.count} operator với mức{' '}
                    <strong>{LOCK_TIER_LABELS[tier]}</strong>
                  </p>

                  {/* Show preview list if count <= 10 */}
                  {preview.operators.length > 0 && preview.operators.length <= 10 && (
                    <div className="mt-2 space-y-1 max-h-[150px] overflow-y-auto">
                      {preview.operators.map((op) => (
                        <div
                          key={op.id}
                          className="text-xs text-muted-foreground flex justify-between"
                        >
                          <span className="truncate flex-1">{op.serviceName}</span>
                          <span className="ml-2 shrink-0">
                            {formatCurrency(op.totalCost)} ₫
                          </span>
                        </div>
                      ))}
                    </div>
                  )}
                </>
              ) : (
                <p className="text-sm text-muted-foreground">
                  Không có operator nào cần khóa với mức {LOCK_TIER_LABELS[tier]}.
                  {tier !== 'KT' && ' Có thể cần khóa tier thấp hơn trước.'}
                </p>
              )}
            </div>
          )}
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={handleClose}>
            Hủy
          </Button>

          {!preview ? (
            <Button onClick={handlePreview} disabled={loading || !month}>
              {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Xem trước
            </Button>
          ) : (
            <Button
              onClick={handleConfirm}
              disabled={confirming || preview.count === 0}
              variant="destructive"
            >
              {confirming && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Xác nhận khóa
            </Button>
          )}
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/operators/reports/profit-report-table.tsx">
'use client';

import { useState, useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { ArrowUpDown, TrendingUp, TrendingDown, Download } from 'lucide-react';
import { formatCurrency } from '@/lib/utils';
import type { ProfitByBooking, ProfitReportSummary } from '@/types';

interface Props {
  data: ProfitByBooking[];
  summary: ProfitReportSummary;
}

type SortField = 'profit' | 'profitMargin' | 'totalCost' | 'totalRevenue';
type SortOrder = 'asc' | 'desc';

// Sort icon component - defined outside to avoid re-creation during render
function SortIcon({ field, currentField }: { field: SortField; currentField: SortField }) {
  return (
    <ArrowUpDown
      className={`h-3 w-3 ml-1 inline ${currentField === field ? 'text-primary' : 'text-muted-foreground'}`}
    />
  );
}

export function ProfitReportTable({ data, summary }: Props) {
  const [sortField, setSortField] = useState<SortField>('profit');
  const [sortOrder, setSortOrder] = useState<SortOrder>('desc');

  // Memoized sorted data for performance
  const sortedData = useMemo(() => {
    return [...data].sort((a, b) => {
      const multiplier = sortOrder === 'desc' ? -1 : 1;
      return (a[sortField] - b[sortField]) * multiplier;
    });
  }, [data, sortField, sortOrder]);

  // Toggle sort
  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortOrder(sortOrder === 'desc' ? 'asc' : 'desc');
    } else {
      setSortField(field);
      setSortOrder('desc');
    }
  };

  // Export to CSV
  const handleExportCSV = () => {
    if (data.length === 0) return;

    // CSV headers
    const headers = ['Mã Booking', 'Khách hàng', 'Chi phí (VND)', 'Doanh thu (VND)', 'Lợi nhuận (VND)', 'Tỷ suất (%)'];

    // Data rows
    const rows = sortedData.map((item) => [
      item.bookingCode,
      `"${item.customerName}"`, // Wrap in quotes in case of commas
      item.totalCost,
      item.totalRevenue,
      item.profit,
      item.profitMargin.toFixed(1),
    ]);

    // Summary row
    const summaryRow = [
      'TỔNG CỘNG',
      `${summary.bookingCount} bookings`,
      summary.totalCost,
      summary.totalRevenue,
      summary.totalProfit,
      summary.avgProfitMargin.toFixed(1),
    ];

    // Build CSV content with BOM for Excel UTF-8
    const csvContent = '\uFEFF' + [headers.join(','), ...rows.map((r) => r.join(',')), summaryRow.join(',')].join('\n');

    // Create download
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `bao-cao-loi-nhuan-${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  return (
    <Card>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle className="flex items-center gap-2">
          <TrendingUp className="h-5 w-5" />
          Chi tiết lợi nhuận theo Booking
        </CardTitle>
        {data.length > 0 && (
          <Button variant="outline" size="sm" onClick={handleExportCSV}>
            <Download className="h-4 w-4 mr-2" />
            Xuất CSV
          </Button>
        )}
      </CardHeader>
      <CardContent>
        {/* Summary Row */}
        <div className="mb-4 p-4 bg-muted/50 rounded-lg grid grid-cols-2 md:grid-cols-5 gap-4">
          <div>
            <p className="text-xs text-muted-foreground">Số booking</p>
            <p className="text-lg font-semibold">{summary.bookingCount}</p>
          </div>
          <div>
            <p className="text-xs text-muted-foreground">Tổng chi phí</p>
            <p className="text-lg font-semibold text-red-600">
              {formatCurrency(summary.totalCost)} ₫
            </p>
          </div>
          <div>
            <p className="text-xs text-muted-foreground">Tổng doanh thu</p>
            <p className="text-lg font-semibold text-blue-600">
              {formatCurrency(summary.totalRevenue)} ₫
            </p>
          </div>
          <div>
            <p className="text-xs text-muted-foreground">Tổng lợi nhuận</p>
            <p className={`text-lg font-semibold ${summary.totalProfit >= 0 ? 'text-green-600' : 'text-red-600'}`}>
              {formatCurrency(summary.totalProfit)} ₫
            </p>
          </div>
          <div>
            <p className="text-xs text-muted-foreground">Tỷ suất TB</p>
            <p className={`text-lg font-semibold ${summary.avgProfitMargin >= 0 ? 'text-green-600' : 'text-red-600'}`}>
              {summary.avgProfitMargin.toFixed(1)}%
            </p>
          </div>
        </div>

        {/* Table */}
        {data.length === 0 ? (
          <p className="text-muted-foreground text-center py-8">
            Không có dữ liệu lợi nhuận trong khoảng thời gian đã chọn
          </p>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full text-sm">
              <thead>
                <tr className="border-b">
                  <th className="text-left py-3 px-2 font-medium">Booking</th>
                  <th className="text-left py-3 px-2 font-medium">Khách hàng</th>
                  <th className="text-right py-3 px-2 font-medium">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 hover:bg-transparent"
                      onClick={() => handleSort('totalCost')}
                    >
                      Chi phí <SortIcon field="totalCost" currentField={sortField} />
                    </Button>
                  </th>
                  <th className="text-right py-3 px-2 font-medium">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 hover:bg-transparent"
                      onClick={() => handleSort('totalRevenue')}
                    >
                      Doanh thu <SortIcon field="totalRevenue" currentField={sortField} />
                    </Button>
                  </th>
                  <th className="text-right py-3 px-2 font-medium">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 hover:bg-transparent"
                      onClick={() => handleSort('profit')}
                    >
                      Lợi nhuận <SortIcon field="profit" currentField={sortField} />
                    </Button>
                  </th>
                  <th className="text-right py-3 px-2 font-medium">
                    <Button
                      variant="ghost"
                      size="sm"
                      className="h-auto p-0 hover:bg-transparent"
                      onClick={() => handleSort('profitMargin')}
                    >
                      Tỷ suất <SortIcon field="profitMargin" currentField={sortField} />
                    </Button>
                  </th>
                </tr>
              </thead>
              <tbody>
                {sortedData.map((item) => (
                  <tr
                    key={item.bookingCode}
                    className={`border-b hover:bg-muted/30 ${
                      item.profit > 0
                        ? 'bg-green-50/50'
                        : item.profit < 0
                        ? 'bg-red-50/50'
                        : ''
                    }`}
                  >
                    <td className="py-3 px-2 font-mono text-xs">
                      {item.bookingCode}
                    </td>
                    <td className="py-3 px-2">{item.customerName}</td>
                    <td className="py-3 px-2 text-right text-red-600">
                      {formatCurrency(item.totalCost)} ₫
                    </td>
                    <td className="py-3 px-2 text-right text-blue-600">
                      {formatCurrency(item.totalRevenue)} ₫
                    </td>
                    <td className="py-3 px-2 text-right">
                      <span
                        className={`inline-flex items-center gap-1 font-medium ${
                          item.profit > 0 ? 'text-green-600' : item.profit < 0 ? 'text-red-600' : ''
                        }`}
                      >
                        {item.profit > 0 ? (
                          <TrendingUp className="h-3 w-3" />
                        ) : item.profit < 0 ? (
                          <TrendingDown className="h-3 w-3" />
                        ) : null}
                        {formatCurrency(item.profit)} ₫
                      </span>
                    </td>
                    <td className="py-3 px-2 text-right">
                      <span
                        className={`px-2 py-0.5 rounded text-xs font-medium ${
                          item.profitMargin > 20
                            ? 'bg-green-100 text-green-700'
                            : item.profitMargin > 0
                            ? 'bg-green-50 text-green-600'
                            : item.profitMargin < 0
                            ? 'bg-red-100 text-red-700'
                            : 'bg-gray-100 text-gray-600'
                        }`}
                      >
                        {item.profitMargin.toFixed(1)}%
                      </span>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/requests/index.ts">
// Request Module Components
// Export all components for easy import

export { RequestStatusBadge } from './request-status-badge';
export { RequestFilters } from './request-filters';
export { RequestTable } from './request-table';
export { RequestForm } from './request-form';

// Phase 2: 2-Panel Layout Components
export { RequestListItem } from './request-list-item';
export { RequestListPanel } from './request-list-panel';
export { RequestDetailPanel } from './request-detail-panel';

// Phase 4: Inline Services Table
export { RequestServicesTable } from './request-services-table';
</file>

<file path="src/components/requests/request-form.tsx">
'use client';

import React, { useState, useMemo, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import {
  REQUEST_STAGES,
  REQUEST_STAGE_KEYS,
  getStatusesByStage,
  REQUEST_STATUSES,
} from '@/config/request-config';
import type { Request, RequestFormData, RequestStatus } from '@/types';
import {
  requestFormSchema,
  type RequestFormErrors,
  parseIntegerInput,
  parseNumericInput,
} from '@/lib/validations/request-validation';
import { cn } from '@/lib/utils';
import { safePositiveInt, parseOptionalInt, parseOptionalFloat } from '@/lib/utils/parse-utils';

// Client-safe utility - calculate end date from start + tourDays
function calculateEndDate(startDate: Date, tourDays: number): Date {
  const end = new Date(startDate);
  end.setDate(end.getDate() + tourDays - 1);
  return end;
}

interface RequestFormProps {
  initialData?: Partial<Request>;
  onSubmit: (data: RequestFormData) => Promise<void>;
  onCancel?: () => void;
  isEditing?: boolean;
}

// Helper: format date for input field (YYYY-MM-DD)
function formatDateInput(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

// FormField wrapper component with error display
function FormField({
  label,
  required,
  error,
  children,
}: {
  label: string;
  required?: boolean;
  error?: string;
  children: React.ReactNode;
}) {
  return (
    <div className="space-y-1.5">
      <Label className={cn(error && 'text-destructive')}>
        {label}
        {required && <span className="text-destructive ml-1">*</span>}
      </Label>
      {children}
      {error && <p className="text-xs text-destructive">{error}</p>}
    </div>
  );
}

export function RequestForm({ initialData, onSubmit, onCancel, isEditing = false }: RequestFormProps) {
  const [formData, setFormData] = useState<RequestFormData>({
    customerName: initialData?.customerName || '',
    contact: initialData?.contact || '',
    whatsapp: initialData?.whatsapp || '',
    pax: initialData?.pax || 1,
    country: initialData?.country || '',
    source: initialData?.source || '',
    status: initialData?.status || 'DANG_LL_CHUA_TL',
    tourDays: initialData?.tourDays || undefined,
    startDate: initialData?.startDate ? formatDateInput(initialData.startDate) : '',
    expectedRevenue: initialData?.expectedRevenue || undefined,
    expectedCost: initialData?.expectedCost || undefined,
    notes: initialData?.notes || '',
  });

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [fieldErrors, setFieldErrors] = useState<RequestFormErrors>({});

  // Auto-calculate endDate display
  const calculatedEndDate = useMemo(() => {
    if (formData.startDate && formData.tourDays) {
      const end = calculateEndDate(new Date(formData.startDate), formData.tourDays);
      return formatDateInput(end);
    }
    return '';
  }, [formData.startDate, formData.tourDays]);

  // Validate single field
  const validateField = useCallback((field: keyof RequestFormData, value: unknown) => {
    // Create partial data for field validation
    const testData = { ...formData, [field]: value };
    const result = requestFormSchema.safeParse(testData);

    if (!result.success) {
      const fieldError = result.error.issues.find((issue) => issue.path[0] === field);
      if (fieldError) {
        setFieldErrors((prev) => ({ ...prev, [field]: fieldError.message }));
        return false;
      }
    }
    // Clear error if valid
    setFieldErrors((prev) => {
      const next = { ...prev };
      delete next[field as keyof RequestFormErrors];
      return next;
    });
    return true;
  }, [formData]);

  // Handle blur - validate field
  const handleBlur = useCallback((field: keyof RequestFormData) => {
    validateField(field, formData[field]);
  }, [formData, validateField]);

  // Handle field change - clear error on edit
  const handleChange = useCallback(<K extends keyof RequestFormData>(field: K, value: RequestFormData[K]) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    // Clear field error when user starts typing
    if (fieldErrors[field as keyof RequestFormErrors]) {
      setFieldErrors((prev) => {
        const next = { ...prev };
        delete next[field as keyof RequestFormErrors];
        return next;
      });
    }
    // Clear general error
    if (error) setError('');
  }, [fieldErrors, error]);

  // Check if form has errors
  const hasErrors = Object.keys(fieldErrors).length > 0;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    // Prepare data with proper type conversions
    const dataToValidate = {
      ...formData,
      pax: parseIntegerInput(formData.pax, 1) ?? 1,
      tourDays: parseIntegerInput(formData.tourDays, null),
      expectedRevenue: parseNumericInput(formData.expectedRevenue, null),
      expectedCost: parseNumericInput(formData.expectedCost, null),
      // Convert empty strings to undefined for optional date fields
      startDate: formData.startDate || undefined,
      whatsapp: formData.whatsapp || undefined,
      notes: formData.notes || undefined,
    };

    // Validate with Zod
    const result = requestFormSchema.safeParse(dataToValidate);

    if (!result.success) {
      // Extract field-level errors
      const errors: RequestFormErrors = {};
      for (const issue of result.error.issues) {
        const field = issue.path[0] as keyof RequestFormErrors;
        if (field && !errors[field]) {
          errors[field] = issue.message;
        }
      }
      setFieldErrors(errors);
      setError('Vui lòng kiểm tra lại thông tin');
      return;
    }

    setLoading(true);
    try {
      // Submit validated data
      await onSubmit(result.data as RequestFormData);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Có lỗi xảy ra');
    } finally {
      setLoading(false);
    }
  };

  // Helper for input className with error state
  const inputClassName = (field: keyof RequestFormErrors) =>
    cn(fieldErrors[field] && 'border-destructive focus-visible:ring-destructive');

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="p-3 bg-destructive/10 text-destructive rounded-md text-sm">{error}</div>
      )}

      {/* Customer Info Section */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin khách hàng</CardTitle>
        </CardHeader>
        <CardContent className="grid grid-cols-2 gap-4">
          <FormField label="Tên khách" required error={fieldErrors.customerName}>
            <Input
              value={formData.customerName}
              onChange={(e) => handleChange('customerName', e.target.value)}
              onBlur={() => handleBlur('customerName')}
              placeholder="Nguyen Van A"
              className={inputClassName('customerName')}
            />
          </FormField>
          <FormField label="Liên hệ" required error={fieldErrors.contact}>
            <Input
              value={formData.contact}
              onChange={(e) => handleChange('contact', e.target.value)}
              onBlur={() => handleBlur('contact')}
              placeholder="email@example.com hoặc SĐT"
              className={inputClassName('contact')}
            />
          </FormField>
          <FormField label="WhatsApp" error={fieldErrors.whatsapp}>
            <Input
              value={formData.whatsapp || ''}
              onChange={(e) => handleChange('whatsapp', e.target.value)}
              onBlur={() => handleBlur('whatsapp')}
              placeholder="+84..."
              className={inputClassName('whatsapp')}
            />
          </FormField>
          <FormField label="Số khách (Pax)" required error={fieldErrors.pax}>
            <Input
              type="number"
              min="1"
              max="100"
              value={formData.pax}
              onChange={(e) => handleChange('pax', safePositiveInt(e.target.value, 1))}
              onBlur={() => handleBlur('pax')}
              className={inputClassName('pax')}
            />
          </FormField>
          <FormField label="Quốc gia" required error={fieldErrors.country}>
            <Input
              value={formData.country}
              onChange={(e) => handleChange('country', e.target.value)}
              onBlur={() => handleBlur('country')}
              placeholder="USA, UK, France..."
              className={inputClassName('country')}
            />
          </FormField>
          <FormField label="Nguồn" required error={fieldErrors.source}>
            <Input
              value={formData.source}
              onChange={(e) => handleChange('source', e.target.value)}
              onBlur={() => handleBlur('source')}
              placeholder="TripAdvisor, Zalo, Email..."
              className={inputClassName('source')}
            />
          </FormField>
        </CardContent>
      </Card>

      {/* Tour Info Section */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin Tour</CardTitle>
        </CardHeader>
        <CardContent className="grid grid-cols-2 gap-4">
          <FormField label="Số ngày" error={fieldErrors.tourDays}>
            <Input
              type="number"
              min="1"
              max="365"
              value={formData.tourDays || ''}
              onChange={(e) => handleChange('tourDays', parseOptionalInt(e.target.value))}
              onBlur={() => handleBlur('tourDays')}
              className={inputClassName('tourDays')}
            />
          </FormField>
          <FormField label="Ngày bắt đầu" error={fieldErrors.startDate}>
            <Input
              type="date"
              value={formData.startDate || ''}
              onChange={(e) => handleChange('startDate', e.target.value)}
              onBlur={() => handleBlur('startDate')}
              className={inputClassName('startDate')}
            />
          </FormField>
          <FormField label="Ngày kết thúc (tự động)">
            <Input type="date" value={calculatedEndDate} disabled className="bg-muted" />
          </FormField>
          <FormField label="Doanh thu dự kiến" error={fieldErrors.expectedRevenue}>
            <Input
              type="number"
              min="0"
              value={formData.expectedRevenue || ''}
              onChange={(e) => handleChange('expectedRevenue', parseOptionalFloat(e.target.value))}
              onBlur={() => handleBlur('expectedRevenue')}
              placeholder="VND"
              className={inputClassName('expectedRevenue')}
            />
          </FormField>
          <FormField label="Chi phí dự kiến" error={fieldErrors.expectedCost}>
            <Input
              type="number"
              min="0"
              value={formData.expectedCost || ''}
              onChange={(e) => handleChange('expectedCost', parseOptionalFloat(e.target.value))}
              onBlur={() => handleBlur('expectedCost')}
              placeholder="VND"
              className={inputClassName('expectedCost')}
            />
          </FormField>
        </CardContent>
      </Card>

      {/* Status Section */}
      <Card>
        <CardHeader>
          <CardTitle>Trạng thái</CardTitle>
        </CardHeader>
        <CardContent>
          <FormField label="Trạng thái" required error={fieldErrors.status}>
            <Select
              value={formData.status}
              onValueChange={(v) => handleChange('status', v as RequestStatus)}
            >
              <SelectTrigger className={inputClassName('status')}>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {REQUEST_STAGE_KEYS.map((stage) => (
                  <SelectGroup key={stage}>
                    <SelectLabel>{REQUEST_STAGES[stage].label}</SelectLabel>
                    {getStatusesByStage(stage).map((status) => (
                      <SelectItem key={status} value={status}>
                        {REQUEST_STATUSES[status].label}
                      </SelectItem>
                    ))}
                  </SelectGroup>
                ))}
              </SelectContent>
            </Select>
          </FormField>
        </CardContent>
      </Card>

      {/* Notes Section */}
      <Card>
        <CardHeader>
          <CardTitle>Ghi chú</CardTitle>
        </CardHeader>
        <CardContent>
          <FormField label="Ghi chú" error={fieldErrors.notes}>
            <Textarea
              value={formData.notes || ''}
              onChange={(e) => handleChange('notes', e.target.value)}
              onBlur={() => handleBlur('notes')}
              placeholder="Ghi chú thêm..."
              rows={4}
              maxLength={1000}
              className={inputClassName('notes')}
            />
            <p className="text-xs text-muted-foreground mt-1">
              {(formData.notes?.length || 0)}/1000 ký tự
            </p>
          </FormField>
        </CardContent>
      </Card>

      {/* Actions */}
      <div className="flex justify-end gap-3">
        {onCancel && (
          <Button type="button" variant="outline" onClick={onCancel}>
            Hủy
          </Button>
        )}
        <Button type="submit" disabled={loading || hasErrors}>
          {loading ? 'Đang lưu...' : isEditing ? 'Cập nhật' : 'Tạo mới'}
        </Button>
      </div>
    </form>
  );
}
</file>

<file path="src/components/requests/request-list-item.tsx">
'use client';

import { cn, formatDate } from '@/lib/utils';
import { RequestStatusBadge } from './request-status-badge';
import { Bell, User, Globe, Calendar } from 'lucide-react';
import type { Request, RequestStatus } from '@/types';

interface RequestListItemProps {
  request: Request;
  isSelected: boolean;
  onClick: () => void;
}

/**
 * Single request item in the left panel list.
 * Shows: ID, status, customer name, seller, country, received date, follow-up indicator
 */
export function RequestListItem({ request, isSelected, onClick }: RequestListItemProps) {
  // Show booking code if available, otherwise RQID or code
  const displayId = request.bookingCode || request.rqid || request.code;

  // Follow-up indicator: show bell if nextFollowUp is overdue
  const hasOverdueFollowUp = request.nextFollowUp && new Date(request.nextFollowUp) < new Date();

  return (
    <div
      onClick={onClick}
      className={cn(
        'p-3 border-b cursor-pointer hover:bg-muted/50 transition-colors',
        isSelected && 'bg-muted border-l-2 border-l-primary'
      )}
    >
      {/* Row 1: ID + Status */}
      <div className="flex items-center justify-between gap-2">
        <span className="font-mono text-sm font-medium truncate">{displayId}</span>
        <div className="flex items-center gap-2">
          {hasOverdueFollowUp && (
            <Bell className="h-4 w-4 text-orange-500 flex-shrink-0" />
          )}
          <RequestStatusBadge status={request.status as RequestStatus} />
        </div>
      </div>

      {/* Row 2: Customer name */}
      <div className="font-medium mt-1 truncate">{request.customerName}</div>

      {/* Row 3: Meta info - Seller, Country, Date */}
      <div className="flex items-center gap-3 text-xs text-muted-foreground mt-1">
        <span className="flex items-center gap-1 truncate">
          <User className="h-3 w-3 flex-shrink-0" />
          {request.seller?.name || 'N/A'}
        </span>
        <span className="flex items-center gap-1">
          <Globe className="h-3 w-3 flex-shrink-0" />
          {request.country || 'N/A'}
        </span>
        <span className="flex items-center gap-1">
          <Calendar className="h-3 w-3 flex-shrink-0" />
          {request.receivedDate ? formatDate(request.receivedDate) : 'N/A'}
        </span>
      </div>
    </div>
  );
}
</file>

<file path="src/components/requests/request-services-table.tsx">
'use client';

import { useState } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Plus, Edit2, Trash2, Check, X } from 'lucide-react';
import { toast } from 'sonner';
import { SERVICE_TYPES } from '@/config/operator-config';
import { formatCurrency, formatDate } from '@/lib/utils';
import { safeNonNegativeFloat } from '@/lib/utils/parse-utils';
import type { Operator } from '@/types';

interface RequestServicesTableProps {
  requestId: string;
  operators: Operator[];
  onUpdate?: () => void;
}

interface EditingRow {
  id: string | null; // null = new row
  serviceDate: string;
  serviceType: string;
  serviceName: string;
  supplier: string;
  totalCost: string;
}

const emptyRow: EditingRow = {
  id: null,
  serviceDate: '',
  serviceType: '',
  serviceName: '',
  supplier: '',
  totalCost: '',
};

export function RequestServicesTable({
  requestId,
  operators,
  onUpdate,
}: RequestServicesTableProps) {
  const [editingRow, setEditingRow] = useState<EditingRow | null>(null);
  const [saving, setSaving] = useState(false);

  const handleEdit = (op: Operator) => {
    setEditingRow({
      id: op.id,
      serviceDate: new Date(op.serviceDate).toISOString().split('T')[0],
      serviceType: op.serviceType,
      serviceName: op.serviceName,
      supplier: op.supplier || '',
      totalCost: String(op.totalCost),
    });
  };

  const handleAddNew = () => {
    setEditingRow({ ...emptyRow });
  };

  const handleCancel = () => {
    setEditingRow(null);
  };

  const handleSave = async () => {
    if (!editingRow) return;

    setSaving(true);
    try {
      const payload = {
        requestId,
        serviceDate: new Date(editingRow.serviceDate).toISOString(),
        serviceType: editingRow.serviceType,
        serviceName: editingRow.serviceName,
        supplier: editingRow.supplier,
        costBeforeTax: safeNonNegativeFloat(editingRow.totalCost),
        vat: 0,
        totalCost: safeNonNegativeFloat(editingRow.totalCost),
      };

      const url = editingRow.id
        ? `/api/operators/${editingRow.id}`
        : '/api/operators';
      const method = editingRow.id ? 'PUT' : 'POST';

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });

      const result = await res.json();
      if (result.success) {
        setEditingRow(null);
        onUpdate?.();
        toast.success('Đã lưu thành công');
      } else {
        toast.error(result.error || 'Lỗi khi lưu');
      }
    } catch (err) {
      console.error('Error saving operator:', err);
      toast.error('Lỗi khi lưu');
    } finally {
      setSaving(false);
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm('Xác nhận xóa dịch vụ này?')) return;

    try {
      const res = await fetch(`/api/operators/${id}`, { method: 'DELETE' });
      const result = await res.json();
      if (result.success) {
        onUpdate?.();
        toast.success('Đã xóa dịch vụ');
      } else {
        toast.error(result.error || 'Lỗi khi xóa');
      }
    } catch (err) {
      console.error('Error deleting operator:', err);
      toast.error('Lỗi khi xóa');
    }
  };

  const handleChange = (field: keyof EditingRow, value: string) => {
    if (!editingRow) return;
    setEditingRow({ ...editingRow, [field]: value });
  };

  return (
    <div>
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead className="w-[100px]">Ngày</TableHead>
            <TableHead className="w-[120px]">Loại</TableHead>
            <TableHead>Tên dịch vụ</TableHead>
            <TableHead>NCC</TableHead>
            <TableHead className="w-[120px] text-right">Chi phí</TableHead>
            <TableHead className="w-[100px]"></TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {operators.map((op) =>
            editingRow?.id === op.id ? (
              <EditableRow
                key={op.id}
                row={editingRow}
                onChange={handleChange}
                onSave={handleSave}
                onCancel={handleCancel}
                saving={saving}
              />
            ) : (
              <TableRow key={op.id}>
                <TableCell>{formatDate(op.serviceDate)}</TableCell>
                <TableCell>
                  {SERVICE_TYPES[op.serviceType as keyof typeof SERVICE_TYPES]?.label || op.serviceType}
                </TableCell>
                <TableCell>{op.serviceName}</TableCell>
                <TableCell>{op.supplierRef?.name || op.supplier || '-'}</TableCell>
                <TableCell className="text-right font-mono">
                  {formatCurrency(op.totalCost)}
                </TableCell>
                <TableCell>
                  <div className="flex gap-1">
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleEdit(op)}
                      disabled={op.isLocked}
                    >
                      <Edit2 className="h-4 w-4" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => handleDelete(op.id)}
                      disabled={op.isLocked}
                    >
                      <Trash2 className="h-4 w-4 text-red-500" />
                    </Button>
                  </div>
                </TableCell>
              </TableRow>
            )
          )}

          {/* New row */}
          {editingRow && editingRow.id === null && (
            <EditableRow
              row={editingRow}
              onChange={handleChange}
              onSave={handleSave}
              onCancel={handleCancel}
              saving={saving}
            />
          )}

          {/* Add button row */}
          {!editingRow && (
            <TableRow>
              <TableCell colSpan={6}>
                <Button
                  variant="ghost"
                  className="w-full justify-start text-muted-foreground"
                  onClick={handleAddNew}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Thêm dịch vụ
                </Button>
              </TableCell>
            </TableRow>
          )}
        </TableBody>
      </Table>

      {operators.length === 0 && !editingRow && (
        <p className="text-center text-muted-foreground py-4">
          Chưa có dịch vụ nào
        </p>
      )}
    </div>
  );
}

// Editable row component
function EditableRow({
  row,
  onChange,
  onSave,
  onCancel,
  saving,
}: {
  row: EditingRow;
  onChange: (field: keyof EditingRow, value: string) => void;
  onSave: () => void;
  onCancel: () => void;
  saving: boolean;
}) {
  return (
    <TableRow className="bg-muted/50">
      <TableCell>
        <Input
          type="date"
          value={row.serviceDate}
          onChange={(e) => onChange('serviceDate', e.target.value)}
          className="h-8"
        />
      </TableCell>
      <TableCell>
        <Select
          value={row.serviceType}
          onValueChange={(v) => onChange('serviceType', v)}
        >
          <SelectTrigger className="h-8">
            <SelectValue placeholder="Chọn" />
          </SelectTrigger>
          <SelectContent>
            {Object.entries(SERVICE_TYPES).map(([key, { label }]) => (
              <SelectItem key={key} value={key}>
                {label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </TableCell>
      <TableCell>
        <Input
          value={row.serviceName}
          onChange={(e) => onChange('serviceName', e.target.value)}
          placeholder="Tên dịch vụ"
          className="h-8"
        />
      </TableCell>
      <TableCell>
        <Input
          value={row.supplier}
          onChange={(e) => onChange('supplier', e.target.value)}
          placeholder="NCC"
          className="h-8"
        />
      </TableCell>
      <TableCell>
        <Input
          type="number"
          value={row.totalCost}
          onChange={(e) => onChange('totalCost', e.target.value)}
          placeholder="0"
          className="h-8 text-right"
        />
      </TableCell>
      <TableCell>
        <div className="flex gap-1">
          <Button
            variant="ghost"
            size="icon"
            onClick={onSave}
            disabled={saving}
          >
            <Check className="h-4 w-4 text-green-600" />
          </Button>
          <Button
            variant="ghost"
            size="icon"
            onClick={onCancel}
            disabled={saving}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      </TableCell>
    </TableRow>
  );
}
</file>

<file path="src/components/revenues/revenue-history-panel.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Badge } from '@/components/ui/badge';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Skeleton } from '@/components/ui/skeleton';
import {
  Lock,
  Unlock,
  Plus,
  Edit,
  Trash,
  Info,
  History,
} from 'lucide-react';
import { HISTORY_ACTION_LABELS } from '@/config/lock-config';
import { formatDistanceToNow } from 'date-fns';
import { vi } from 'date-fns/locale';

interface HistoryEntry {
  id: string;
  revenueId: string;
  action: string;
  changes: Record<string, unknown>;
  userId: string;
  userName?: string;
  createdAt: string;
}

interface RevenueHistoryPanelProps {
  revenueId: string;
}

const ACTION_CONFIG: Record<
  string,
  { color: string; icon: React.ReactNode }
> = {
  CREATE: {
    color: 'bg-blue-100 text-blue-800',
    icon: <Plus className="h-3 w-3" />,
  },
  UPDATE: {
    color: 'bg-gray-100 text-gray-800',
    icon: <Edit className="h-3 w-3" />,
  },
  DELETE: {
    color: 'bg-red-100 text-red-800',
    icon: <Trash className="h-3 w-3" />,
  },
  LOCK_KT: {
    color: 'bg-amber-100 text-amber-800',
    icon: <Lock className="h-3 w-3" />,
  },
  UNLOCK_KT: {
    color: 'bg-amber-50 text-amber-700',
    icon: <Unlock className="h-3 w-3" />,
  },
  LOCK_ADMIN: {
    color: 'bg-orange-100 text-orange-800',
    icon: <Lock className="h-3 w-3" />,
  },
  UNLOCK_ADMIN: {
    color: 'bg-orange-50 text-orange-700',
    icon: <Unlock className="h-3 w-3" />,
  },
  LOCK_FINAL: {
    color: 'bg-red-100 text-red-800',
    icon: <Lock className="h-3 w-3" />,
  },
  UNLOCK_FINAL: {
    color: 'bg-red-50 text-red-700',
    icon: <Unlock className="h-3 w-3" />,
  },
};

function formatDate(dateStr: string): string {
  try {
    return formatDistanceToNow(new Date(dateStr), {
      addSuffix: true,
      locale: vi,
    });
  } catch {
    return dateStr;
  }
}

export function RevenueHistoryPanel({ revenueId }: RevenueHistoryPanelProps) {
  const [history, setHistory] = useState<HistoryEntry[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchHistory() {
      try {
        const res = await fetch(`/api/revenues/${revenueId}/history`);
        if (!res.ok) {
          throw new Error('Failed to fetch history');
        }
        const data = await res.json();
        setHistory(data.data || data || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Lỗi tải lịch sử');
      } finally {
        setLoading(false);
      }
    }

    fetchHistory();
  }, [revenueId]);

  if (loading) {
    return (
      <div className="space-y-3 p-4">
        {[1, 2, 3].map((i) => (
          <div key={i} className="flex items-start gap-3">
            <Skeleton className="h-8 w-8 rounded-full" />
            <div className="space-y-1.5 flex-1">
              <Skeleton className="h-4 w-24" />
              <Skeleton className="h-3 w-32" />
            </div>
          </div>
        ))}
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 text-center text-sm text-muted-foreground">
        {error}
      </div>
    );
  }

  if (history.length === 0) {
    return (
      <div className="p-4 text-center text-sm text-muted-foreground">
        <History className="h-8 w-8 mx-auto mb-2 opacity-50" />
        Chưa có lịch sử
      </div>
    );
  }

  return (
    <ScrollArea className="h-[300px]">
      <div className="p-4 space-y-3">
        {history.map((entry) => {
          const config = ACTION_CONFIG[entry.action] || {
            color: 'bg-gray-100 text-gray-800',
            icon: <Info className="h-3 w-3" />,
          };
          const label =
            HISTORY_ACTION_LABELS[entry.action] || entry.action;

          return (
            <div key={entry.id} className="flex items-start gap-3">
              <div className={`rounded-full p-1.5 ${config.color}`}>
                {config.icon}
              </div>
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2">
                  <span className="font-medium text-sm">{label}</span>
                </div>
                <p className="text-xs text-muted-foreground">
                  {entry.userName || entry.userId} • {formatDate(entry.createdAt)}
                </p>
                {typeof entry.changes?.tier === 'string' && (
                  <Badge variant="outline" className="mt-1 text-xs">
                    {entry.changes.tier}
                  </Badge>
                )}
              </div>
            </div>
          );
        })}
      </div>
    </ScrollArea>
  );
}
</file>

<file path="src/components/revenues/revenue-summary-card.tsx">
'use client';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { formatCurrency } from '@/lib/utils';
import { DollarSign, TrendingUp, Shield, ShieldCheck, ShieldAlert } from 'lucide-react';

interface Revenue {
  amountVND: number;
  paymentType: string;
  // 3-tier lock fields
  lockKT?: boolean;
  lockAdmin?: boolean;
  lockFinal?: boolean;
  // Legacy field for backward compatibility
  isLocked?: boolean;
}

interface RevenueSummaryCardProps {
  revenues: Revenue[];
  className?: string;
}

export function RevenueSummaryCard({ revenues, className }: RevenueSummaryCardProps) {
  // Calculate totals
  const totalVND = revenues.reduce((sum, r) => {
    const amount = Number(r.amountVND) || 0;
    // Refunds are negative
    return r.paymentType === 'REFUND' ? sum - amount : sum + amount;
  }, 0);

  const depositTotal = revenues
    .filter((r) => r.paymentType === 'DEPOSIT')
    .reduce((sum, r) => sum + (Number(r.amountVND) || 0), 0);

  // Helper to check if any lock is active
  const hasAnyLock = (r: Revenue) =>
    r.lockKT || r.lockAdmin || r.lockFinal || r.isLocked;

  // Calculate lock tier totals
  const lockedKTTotal = revenues
    .filter((r) => r.lockKT && !r.lockAdmin && !r.lockFinal)
    .reduce((sum, r) => {
      const amount = Number(r.amountVND) || 0;
      return r.paymentType === 'REFUND' ? sum - amount : sum + amount;
    }, 0);

  const lockedAdminTotal = revenues
    .filter((r) => r.lockAdmin && !r.lockFinal)
    .reduce((sum, r) => {
      const amount = Number(r.amountVND) || 0;
      return r.paymentType === 'REFUND' ? sum - amount : sum + amount;
    }, 0);

  const lockedFinalTotal = revenues
    .filter((r) => r.lockFinal)
    .reduce((sum, r) => {
      const amount = Number(r.amountVND) || 0;
      return r.paymentType === 'REFUND' ? sum - amount : sum + amount;
    }, 0);

  // Total locked (any tier)
  const totalLocked = revenues
    .filter(hasAnyLock)
    .reduce((sum, r) => {
      const amount = Number(r.amountVND) || 0;
      return r.paymentType === 'REFUND' ? sum - amount : sum + amount;
    }, 0);

  // Count by tier
  const countKT = revenues.filter((r) => r.lockKT && !r.lockAdmin && !r.lockFinal).length;
  const countAdmin = revenues.filter((r) => r.lockAdmin && !r.lockFinal).length;
  const countFinal = revenues.filter((r) => r.lockFinal).length;
  const totalLockedCount = revenues.filter(hasAnyLock).length;

  return (
    <div className={`grid grid-cols-2 md:grid-cols-4 gap-4 ${className}`}>
      {/* Total Revenue */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Tong thu nhap</CardTitle>
          <DollarSign className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-green-600">
            {formatCurrency(totalVND)} d
          </div>
          <p className="text-xs text-muted-foreground">
            {revenues.length} giao dich
          </p>
        </CardContent>
      </Card>

      {/* Deposit Total */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Dat coc</CardTitle>
          <TrendingUp className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-blue-600">
            {formatCurrency(depositTotal)} d
          </div>
          <p className="text-xs text-muted-foreground">
            {revenues.filter((r) => r.paymentType === 'DEPOSIT').length} giao dich
          </p>
        </CardContent>
      </Card>

      {/* Locked by Tier - Summary */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Da khoa</CardTitle>
          <Shield className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold text-amber-600">
            {formatCurrency(totalLocked)} d
          </div>
          <p className="text-xs text-muted-foreground">
            {totalLockedCount} giao dich
          </p>
        </CardContent>
      </Card>

      {/* Lock Tier Breakdown */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Phan bo khoa</CardTitle>
          <ShieldAlert className="h-4 w-4 text-muted-foreground" />
        </CardHeader>
        <CardContent>
          <div className="space-y-1">
            <div className="flex items-center justify-between text-xs">
              <div className="flex items-center gap-1">
                <Shield className="h-3 w-3 text-amber-600" />
                <span className="text-amber-600">KT</span>
              </div>
              <span className="font-medium">{countKT}</span>
            </div>
            <div className="flex items-center justify-between text-xs">
              <div className="flex items-center gap-1">
                <ShieldCheck className="h-3 w-3 text-orange-600" />
                <span className="text-orange-600">Admin</span>
              </div>
              <span className="font-medium">{countAdmin}</span>
            </div>
            <div className="flex items-center justify-between text-xs">
              <div className="flex items-center gap-1">
                <ShieldAlert className="h-3 w-3 text-red-600" />
                <span className="text-red-600">Cuoi</span>
              </div>
              <span className="font-medium">{countFinal}</span>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/components/settings/followup-status-form-modal.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Checkbox } from '@/components/ui/checkbox';
import { Badge } from '@/components/ui/badge';
import { toast } from 'sonner';
import { X } from 'lucide-react';
import { FollowUpStatus } from '@/types';

interface FollowUpStatusFormModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  status?: FollowUpStatus | null;
  onSuccess: () => void;
}

// Zod schema for validation
const formSchema = z.object({
  status: z.string().min(1, 'Tên trạng thái không được để trống'),
  daysToFollowup: z.number().min(0, 'Số ngày phải >= 0'),
  isActive: z.boolean(),
});

type FormData = z.infer<typeof formSchema>;

export function FollowUpStatusFormModal({
  open,
  onOpenChange,
  status,
  onSuccess,
}: FollowUpStatusFormModalProps) {
  const [loading, setLoading] = useState(false);
  const [aliases, setAliases] = useState<string[]>([]);
  const [aliasInput, setAliasInput] = useState('');

  const isEditMode = status !== null && status !== undefined;

  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      status: '',
      daysToFollowup: 0,
      isActive: true,
    },
  });

  // Initialize form when modal opens
  useEffect(() => {
    if (open) {
      if (status) {
        form.reset({
          status: status.status,
          daysToFollowup: status.daysToFollowup,
          isActive: status.isActive,
        });
        setAliases(status.aliases || []);
      } else {
        form.reset({
          status: '',
          daysToFollowup: 0,
          isActive: true,
        });
        setAliases([]);
      }
      setAliasInput('');
    }
  }, [open, status, form]);

  const handleAliasKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && aliasInput.trim()) {
      e.preventDefault();
      const trimmed = aliasInput.trim();
      if (!aliases.includes(trimmed)) {
        setAliases([...aliases, trimmed]);
        setAliasInput('');
      } else {
        toast.error('Alias đã tồn tại');
      }
    }
  };

  const removeAlias = (index: number) => {
    setAliases(aliases.filter((_, i) => i !== index));
  };

  const onSubmit = async (data: FormData) => {
    setLoading(true);
    try {
      const url = isEditMode
        ? `/api/config/follow-up-statuses/${status.id}`
        : '/api/config/follow-up-statuses';
      const method = isEditMode ? 'PUT' : 'POST';

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          status: data.status.trim(),
          aliases: aliases,
          daysToFollowup: data.daysToFollowup,
          isActive: data.isActive,
        }),
      });

      const result = await res.json();

      if (!result.success) {
        toast.error(result.error || 'Có lỗi xảy ra');
        return;
      }

      toast.success(
        isEditMode ? 'Cập nhật trạng thái thành công' : 'Tạo trạng thái thành công'
      );
      onOpenChange(false);
      onSuccess();
    } catch {
      toast.error('Có lỗi xảy ra khi lưu dữ liệu');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>
            {isEditMode ? 'Sửa trạng thái' : 'Thêm trạng thái mới'}
          </DialogTitle>
        </DialogHeader>

        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
          {/* Status Name */}
          <div className="space-y-2">
            <Label htmlFor="status">Tên trạng thái *</Label>
            <Input
              id="status"
              {...form.register('status')}
              placeholder="VD: Mới"
              autoComplete="off"
            />
            {form.formState.errors.status && (
              <p className="text-sm text-destructive">{form.formState.errors.status.message}</p>
            )}
          </div>

          {/* Aliases */}
          <div className="space-y-2">
            <Label htmlFor="aliases">
              Aliases
              <span className="ml-2 text-xs text-muted-foreground">(Nhấn Enter để thêm)</span>
            </Label>
            <Input
              id="aliases"
              value={aliasInput}
              onChange={(e) => setAliasInput(e.target.value)}
              onKeyDown={handleAliasKeyDown}
              placeholder="VD: mới, new, moi"
              autoComplete="off"
            />
            {aliases.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-2">
                {aliases.map((alias, index) => (
                  <Badge
                    key={index}
                    variant="outline"
                    className="inline-flex items-center gap-1 px-2 py-0.5 rounded text-xs bg-slate-100 text-slate-700"
                  >
                    {alias}
                    <button
                      type="button"
                      onClick={() => removeAlias(index)}
                      className="hover:text-destructive"
                    >
                      <X className="h-3 w-3" />
                    </button>
                  </Badge>
                ))}
              </div>
            )}
          </div>

          {/* Days to Follow-up */}
          <div className="space-y-2">
            <Label htmlFor="daysToFollowup">Số ngày follow-up *</Label>
            <Input
              id="daysToFollowup"
              type="number"
              min="0"
              {...form.register('daysToFollowup', { valueAsNumber: true })}
              placeholder="VD: 3"
            />
            {form.formState.errors.daysToFollowup && (
              <p className="text-sm text-destructive">
                {form.formState.errors.daysToFollowup.message}
              </p>
            )}
          </div>

          {/* Active Status */}
          <div className="flex items-center space-x-2">
            <Checkbox
              id="isActive"
              checked={form.watch('isActive')}
              onCheckedChange={(checked) => form.setValue('isActive', checked === true)}
            />
            <Label htmlFor="isActive" className="cursor-pointer">
              Đang hoạt động
            </Label>
          </div>

          {/* Actions */}
          <div className="flex justify-end gap-2 pt-4">
            <Button type="button" variant="outline" onClick={() => onOpenChange(false)}>
              Hủy
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? 'Đang lưu...' : isEditMode ? 'Lưu thay đổi' : 'Tạo mới'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/settings/seller-form-modal.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Checkbox } from '@/components/ui/checkbox';
import { toast } from 'sonner';
import type { Seller } from '@/types';

interface SellerFormModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  seller: Seller | null; // null = create mode
  onSuccess: () => void;
}

interface FormData {
  telegramId: string;
  sellerName: string;
  sheetName: string;
  metaName: string;
  email: string;
  gender: 'MALE' | 'FEMALE';
  sellerCode: string;
  isActive: boolean;
}

const INITIAL_FORM_DATA: FormData = {
  telegramId: '',
  sellerName: '',
  sheetName: '',
  metaName: '',
  email: '',
  gender: 'MALE',
  sellerCode: '',
  isActive: true,
};

export function SellerFormModal({
  open,
  onOpenChange,
  seller,
  onSuccess,
}: SellerFormModalProps) {
  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState<FormData>(INITIAL_FORM_DATA);

  const isEditMode = seller !== null;

  // Initialize form when modal opens
  const getFormDataFromSeller = useCallback(
    (s: Seller | null): FormData => {
      if (!s) return INITIAL_FORM_DATA;
      return {
        telegramId: s.telegramId,
        sellerName: s.sellerName,
        sheetName: s.sheetName,
        metaName: s.metaName || '',
        email: s.email || '',
        gender: s.gender,
        sellerCode: s.sellerCode,
        isActive: s.isActive,
      };
    },
    []
  );

  useEffect(() => {
    if (open) {
      setFormData(getFormDataFromSeller(seller));
    }
  }, [open, seller, getFormDataFromSeller]);

  const updateField = (field: keyof FormData, value: string | boolean) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();

    // Client-side validation
    if (!formData.telegramId.trim()) {
      toast.error('Telegram ID không được để trống');
      return;
    }
    if (!formData.sellerName.trim()) {
      toast.error('Tên seller không được để trống');
      return;
    }
    if (!formData.sheetName.trim()) {
      toast.error('Tên sheet không được để trống');
      return;
    }
    if (!formData.sellerCode.trim()) {
      toast.error('Mã seller không được để trống');
      return;
    }
    if (!/^[A-Z]{1,2}$/.test(formData.sellerCode)) {
      toast.error('Mã seller phải là 1-2 ký tự in hoa (A-Z)');
      return;
    }

    setLoading(true);
    try {
      const url = isEditMode
        ? `/api/config/sellers/${seller.id}`
        : '/api/config/sellers';
      const method = isEditMode ? 'PUT' : 'POST';

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          telegramId: formData.telegramId.trim(),
          sellerName: formData.sellerName.trim(),
          sheetName: formData.sheetName.trim(),
          metaName: formData.metaName.trim() || null,
          email: formData.email.trim() || null,
          gender: formData.gender,
          sellerCode: formData.sellerCode.trim().toUpperCase(),
          isActive: formData.isActive,
        }),
      });

      const data = await res.json();

      if (!data.success) {
        toast.error(data.error || 'Có lỗi xảy ra');
        return;
      }

      toast.success(isEditMode ? 'Cập nhật seller thành công' : 'Tạo seller thành công');
      onOpenChange(false);
      onSuccess();
    } catch {
      toast.error('Có lỗi xảy ra khi lưu dữ liệu');
    } finally {
      setLoading(false);
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle>
            {isEditMode ? 'Sửa thông tin Seller' : 'Thêm Seller mới'}
          </DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Telegram ID */}
          <div className="space-y-2">
            <Label htmlFor="telegramId">Telegram ID *</Label>
            <Input
              id="telegramId"
              value={formData.telegramId}
              onChange={(e) => updateField('telegramId', e.target.value)}
              placeholder="VD: 123456789"
              required
            />
          </div>

          {/* Seller Name & Code */}
          <div className="grid grid-cols-3 gap-4">
            <div className="col-span-2 space-y-2">
              <Label htmlFor="sellerName">Tên Seller *</Label>
              <Input
                id="sellerName"
                value={formData.sellerName}
                onChange={(e) => updateField('sellerName', e.target.value)}
                placeholder="VD: Ly - Jenny"
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="sellerCode">Mã *</Label>
              <Input
                id="sellerCode"
                value={formData.sellerCode}
                onChange={(e) =>
                  updateField('sellerCode', e.target.value.toUpperCase())
                }
                placeholder="VD: J"
                maxLength={2}
                required
              />
            </div>
          </div>

          {/* Sheet Name */}
          <div className="space-y-2">
            <Label htmlFor="sheetName">Tên Sheet *</Label>
            <Input
              id="sheetName"
              value={formData.sheetName}
              onChange={(e) => updateField('sheetName', e.target.value)}
              placeholder="VD: Ly - Jenny"
              required
            />
          </div>

          {/* Meta Name */}
          <div className="space-y-2">
            <Label htmlFor="metaName">Tên Meta (Facebook)</Label>
            <Input
              id="metaName"
              value={formData.metaName}
              onChange={(e) => updateField('metaName', e.target.value)}
              placeholder="VD: Jenny Nguyen"
            />
          </div>

          {/* Email & Gender */}
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                value={formData.email}
                onChange={(e) => updateField('email', e.target.value)}
                placeholder="VD: jenny@vivatour.vn"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="gender">Giới tính *</Label>
              <Select
                value={formData.gender}
                onValueChange={(v) => updateField('gender', v as 'MALE' | 'FEMALE')}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="MALE">Nam</SelectItem>
                  <SelectItem value="FEMALE">Nữ</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Active Status */}
          <div className="flex items-center space-x-2">
            <Checkbox
              id="isActive"
              checked={formData.isActive}
              onCheckedChange={(checked) =>
                updateField('isActive', checked === true)
              }
            />
            <Label htmlFor="isActive" className="cursor-pointer">
              Đang hoạt động
            </Label>
          </div>

          {/* Actions */}
          <div className="flex justify-end gap-2 pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
            >
              Hủy
            </Button>
            <Button type="submit" disabled={loading}>
              {loading ? 'Đang lưu...' : isEditMode ? 'Lưu thay đổi' : 'Tạo mới'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/settings/seller-table.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import { Plus, Edit, Trash2, Search, ChevronLeft, ChevronRight } from 'lucide-react';
import { toast } from 'sonner';
import type { Seller } from '@/types';
import { SellerFormModal } from './seller-form-modal';

interface SellerTableProps {
  refreshKey?: number;
}

export function SellerTable({ refreshKey = 0 }: SellerTableProps) {
  const [sellers, setSellers] = useState<Seller[]>([]);
  const [loading, setLoading] = useState(true);
  const [search, setSearch] = useState('');
  const [page, setPage] = useState(1);
  const [total, setTotal] = useState(0);
  const [hasMore, setHasMore] = useState(false);
  const limit = 10;

  // Modal state
  const [modalOpen, setModalOpen] = useState(false);
  const [editingSeller, setEditingSeller] = useState<Seller | null>(null);

  // Delete dialog state
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [deletingSeller, setDeletingSeller] = useState<Seller | null>(null);
  const [deleting, setDeleting] = useState(false);

  const fetchSellers = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams({
        page: page.toString(),
        limit: limit.toString(),
      });
      if (search) params.set('search', search);

      const res = await fetch(`/api/config/sellers?${params}`);
      const data = await res.json();

      if (data.success) {
        setSellers(data.data);
        setTotal(data.total);
        setHasMore(data.hasMore);
      } else {
        toast.error(data.error || 'Lỗi tải danh sách');
      }
    } catch {
      toast.error('Lỗi kết nối server');
    } finally {
      setLoading(false);
    }
  }, [page, search]);

  useEffect(() => {
    fetchSellers();
  }, [fetchSellers, refreshKey]);

  // Debounced search
  useEffect(() => {
    const timer = setTimeout(() => {
      setPage(1); // Reset to first page on search
    }, 300);
    return () => clearTimeout(timer);
  }, [search]);

  const handleAdd = () => {
    setEditingSeller(null);
    setModalOpen(true);
  };

  const handleEdit = (seller: Seller) => {
    setEditingSeller(seller);
    setModalOpen(true);
  };

  const handleDeleteClick = (seller: Seller) => {
    setDeletingSeller(seller);
    setDeleteDialogOpen(true);
  };

  const handleDeleteConfirm = async () => {
    if (!deletingSeller) return;

    setDeleting(true);
    try {
      const res = await fetch(`/api/config/sellers/${deletingSeller.id}`, {
        method: 'DELETE',
      });
      const data = await res.json();

      if (data.success) {
        toast.success('Đã xóa seller thành công');
        fetchSellers();
      } else {
        toast.error(data.error || 'Lỗi xóa seller');
      }
    } catch {
      toast.error('Lỗi kết nối server');
    } finally {
      setDeleting(false);
      setDeleteDialogOpen(false);
      setDeletingSeller(null);
    }
  };

  const totalPages = Math.ceil(total / limit);

  return (
    <div className="space-y-4">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="relative w-64">
          <Search className="absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-muted-foreground" />
          <Input
            placeholder="Tìm kiếm seller..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            className="pl-9"
          />
        </div>
        <Button onClick={handleAdd}>
          <Plus className="mr-2 h-4 w-4" />
          Thêm Seller
        </Button>
      </div>

      {/* Table */}
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[120px]">Telegram ID</TableHead>
              <TableHead className="w-[150px]">Tên Seller</TableHead>
              <TableHead className="w-[150px]">Tên Sheet</TableHead>
              <TableHead className="w-[180px]">Email</TableHead>
              <TableHead className="w-[80px]">Giới tính</TableHead>
              <TableHead className="w-[60px]">Mã</TableHead>
              <TableHead className="w-[100px]">Trạng thái</TableHead>
              <TableHead className="w-[100px] text-right">Thao tác</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {loading ? (
              <TableRow>
                <TableCell colSpan={8} className="text-center py-8">
                  Đang tải...
                </TableCell>
              </TableRow>
            ) : sellers.length === 0 ? (
              <TableRow>
                <TableCell colSpan={8} className="text-center py-8 text-muted-foreground">
                  Không có seller nào
                </TableCell>
              </TableRow>
            ) : (
              sellers.map((seller) => (
                <TableRow key={seller.id}>
                  <TableCell className="font-mono text-sm">
                    {seller.telegramId}
                  </TableCell>
                  <TableCell className="font-medium">
                    {seller.sellerName}
                  </TableCell>
                  <TableCell>{seller.sheetName}</TableCell>
                  <TableCell className="text-muted-foreground">
                    {seller.email || '-'}
                  </TableCell>
                  <TableCell>
                    <Badge
                      variant="outline"
                      className={
                        seller.gender === 'MALE'
                          ? 'bg-blue-50 text-blue-700 border-blue-200'
                          : 'bg-pink-50 text-pink-700 border-pink-200'
                      }
                    >
                      {seller.gender === 'MALE' ? 'Nam' : 'Nữ'}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Badge variant="secondary" className="font-mono">
                      {seller.sellerCode}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    <Badge
                      variant={seller.isActive ? 'default' : 'secondary'}
                      className={
                        seller.isActive
                          ? 'bg-green-100 text-green-800 hover:bg-green-100'
                          : 'bg-gray-100 text-gray-600'
                      }
                    >
                      {seller.isActive ? 'Hoạt động' : 'Ngừng'}
                    </Badge>
                  </TableCell>
                  <TableCell className="text-right">
                    <div className="flex justify-end gap-1">
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => handleEdit(seller)}
                        title="Sửa"
                      >
                        <Edit className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => handleDeleteClick(seller)}
                        title="Xóa"
                        className="text-destructive hover:text-destructive"
                      >
                        <Trash2 className="h-4 w-4" />
                      </Button>
                    </div>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <div className="flex items-center justify-between px-2">
          <p className="text-sm text-muted-foreground">
            Hiển thị {(page - 1) * limit + 1} - {Math.min(page * limit, total)} / {total} seller
          </p>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPage((p) => Math.max(1, p - 1))}
              disabled={page === 1}
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>
            <span className="text-sm">
              Trang {page} / {totalPages}
            </span>
            <Button
              variant="outline"
              size="sm"
              onClick={() => setPage((p) => p + 1)}
              disabled={!hasMore}
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}

      {/* Form Modal */}
      <SellerFormModal
        open={modalOpen}
        onOpenChange={setModalOpen}
        seller={editingSeller}
        onSuccess={fetchSellers}
      />

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Xác nhận xóa</AlertDialogTitle>
            <AlertDialogDescription>
              Bạn có chắc muốn xóa seller &quot;{deletingSeller?.sellerName}&quot;?
              Hành động này không thể hoàn tác.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={deleting}>Hủy</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDeleteConfirm}
              disabled={deleting}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              {deleting ? 'Đang xóa...' : 'Xóa'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="src/components/ui/currency-input.tsx">
'use client';

import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';

// Inline config to avoid build-time dependency on Phase 1-A
const CURRENCIES = {
  VND: { label: 'VND', symbol: '₫', decimals: 0 },
  USD: { label: 'USD', symbol: '$', decimals: 2 },
  EUR: { label: 'EUR', symbol: '€', decimals: 2 },
  GBP: { label: 'GBP', symbol: '£', decimals: 2 },
  AUD: { label: 'AUD', symbol: 'A$', decimals: 2 },
  JPY: { label: 'JPY', symbol: '¥', decimals: 0 },
  SGD: { label: 'SGD', symbol: 'S$', decimals: 2 },
  THB: { label: 'THB', symbol: '฿', decimals: 2 },
} as const;

type CurrencyKey = keyof typeof CURRENCIES;
const CURRENCY_KEYS = Object.keys(CURRENCIES) as CurrencyKey[];

const DEFAULT_EXCHANGE_RATES: Record<CurrencyKey, number> = {
  VND: 1,
  USD: 25000,
  EUR: 27000,
  GBP: 32000,
  AUD: 16500,
  JPY: 165,
  SGD: 18500,
  THB: 700,
};

interface CurrencyInputProps {
  value: {
    currency: string;
    foreignAmount: number | null;
    exchangeRate: number | null;
    amountVND: number;
  };
  onChange: (value: {
    currency: string;
    foreignAmount: number | null;
    exchangeRate: number | null;
    amountVND: number;
  }) => void;
  disabled?: boolean;
}

export function CurrencyInput({ value, onChange, disabled }: CurrencyInputProps) {
  const currency = (value.currency || 'VND') as CurrencyKey;
  const isVND = currency === 'VND';

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('vi-VN').format(amount);
  };

  const handleCurrencyChange = (newCurrency: string) => {
    if (newCurrency === 'VND') {
      // Switching to VND, clear foreign fields
      onChange({
        currency: 'VND',
        foreignAmount: null,
        exchangeRate: null,
        amountVND: value.amountVND || 0,
      });
    } else {
      // Switching to foreign currency, set default rate
      const defaultRate = DEFAULT_EXCHANGE_RATES[newCurrency as CurrencyKey] || 25000;
      const foreignAmount = value.foreignAmount || 0;
      onChange({
        currency: newCurrency,
        foreignAmount,
        exchangeRate: defaultRate,
        amountVND: Math.round(foreignAmount * defaultRate),
      });
    }
  };

  const handleAmountChange = (amount: string) => {
    const numAmount = parseFloat(amount) || 0;

    if (isVND) {
      onChange({
        ...value,
        amountVND: numAmount,
      });
    } else {
      const rate = value.exchangeRate || DEFAULT_EXCHANGE_RATES[currency];
      onChange({
        ...value,
        foreignAmount: numAmount,
        amountVND: Math.round(numAmount * rate),
      });
    }
  };

  const handleRateChange = (rate: string) => {
    const numRate = parseFloat(rate) || 0;
    const foreignAmount = value.foreignAmount || 0;
    onChange({
      ...value,
      exchangeRate: numRate,
      amountVND: Math.round(foreignAmount * numRate),
    });
  };

  const handleVNDDirectChange = (amount: string) => {
    const numAmount = parseFloat(amount) || 0;
    onChange({
      ...value,
      amountVND: numAmount,
    });
  };

  return (
    <div className="space-y-4">
      {/* Currency Selector */}
      <div className="space-y-2">
        <Label>Loại tiền</Label>
        <Select value={currency} onValueChange={handleCurrencyChange} disabled={disabled}>
          <SelectTrigger>
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {CURRENCY_KEYS.map((key) => (
              <SelectItem key={key} value={key}>
                {CURRENCIES[key].symbol} {CURRENCIES[key].label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {isVND ? (
        /* VND Direct Input */
        <div className="space-y-2">
          <Label htmlFor="amountVND">Số tiền (VND) *</Label>
          <Input
            id="amountVND"
            type="number"
            value={value.amountVND || ''}
            onChange={(e) => handleAmountChange(e.target.value)}
            placeholder="10000000"
            disabled={disabled}
          />
          {value.amountVND > 0 && (
            <p className="text-sm text-muted-foreground">
              {formatCurrency(value.amountVND)} ₫
            </p>
          )}
        </div>
      ) : (
        /* Foreign Currency Input */
        <div className="grid grid-cols-2 gap-4">
          <div className="space-y-2">
            <Label htmlFor="foreignAmount">Số tiền ({currency}) *</Label>
            <Input
              id="foreignAmount"
              type="number"
              step={CURRENCIES[currency].decimals > 0 ? '0.01' : '1'}
              value={value.foreignAmount || ''}
              onChange={(e) => handleAmountChange(e.target.value)}
              placeholder="1000"
              disabled={disabled}
            />
          </div>
          <div className="space-y-2">
            <Label htmlFor="exchangeRate">Tỷ giá *</Label>
            <Input
              id="exchangeRate"
              type="number"
              value={value.exchangeRate || ''}
              onChange={(e) => handleRateChange(e.target.value)}
              placeholder={String(DEFAULT_EXCHANGE_RATES[currency])}
              disabled={disabled}
            />
          </div>
        </div>
      )}

      {/* VND Result (for foreign currency) */}
      {!isVND && (
        <div className="space-y-2">
          <Label htmlFor="amountVNDResult">Quy đổi VND</Label>
          <Input
            id="amountVNDResult"
            type="number"
            value={value.amountVND || ''}
            onChange={(e) => handleVNDDirectChange(e.target.value)}
            className="bg-gray-100 font-bold"
            disabled={disabled}
          />
          {value.amountVND > 0 && (
            <p className="text-sm font-medium text-primary">
              {formatCurrency(value.amountVND)} ₫
            </p>
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/hooks/use-permission.ts">
"use client";

/**
 * usePermission Hook
 *
 * React hook for checking user permissions in components.
 * Uses NextAuth session to get user role and check against PERMISSIONS config.
 *
 * @example
 * const { can, isAdmin } = usePermission();
 * if (can("request:create")) { ... }
 * if (isAdmin) { ... }
 */

import { useSession } from "next-auth/react";
import { hasPermission, type Role, type Permission } from "@/lib/permissions";

export function usePermission() {
  const { data: session, status } = useSession();

  const role = (session?.user?.role as Role) || null;

  /**
   * Check if current user has a specific permission
   * Returns false if not authenticated
   */
  const can = (permission: Permission): boolean => {
    if (!role) return false;
    return hasPermission(role, permission);
  };

  /**
   * Check multiple permissions (all must pass)
   */
  const canAll = (permissions: Permission[]): boolean => {
    if (!role) return false;
    return permissions.every((p) => hasPermission(role, p));
  };

  /**
   * Check multiple permissions (any must pass)
   */
  const canAny = (permissions: Permission[]): boolean => {
    if (!role) return false;
    return permissions.some((p) => hasPermission(role, p));
  };

  return {
    /** Check if user has a specific permission */
    can,

    /** Check if user has ALL of the specified permissions */
    canAll,

    /** Check if user has ANY of the specified permissions */
    canAny,

    /** Current user's role (null if not authenticated) */
    role,

    /** Current user's ID (null if not authenticated) */
    userId: (session?.user?.id as string) || null,

    /** Session loading status */
    isLoading: status === "loading",

    /** Is user authenticated */
    isAuthenticated: status === "authenticated",

    /** Shorthand for ADMIN check */
    isAdmin: role === "ADMIN",

    /** Shorthand for ACCOUNTANT check */
    isAccountant: role === "ACCOUNTANT",

    /** Shorthand for SELLER check */
    isSeller: role === "SELLER",

    /** Shorthand for OPERATOR check */
    isOperator: role === "OPERATOR",
  };
}
</file>

<file path="src/lib/logger.ts">
/**
 * Simple Logger Utility
 *
 * Provides structured error logging for API routes and components.
 * In production, extend to send to external services (Sentry, LogRocket, etc.)
 *
 * @example
 * import { logError, logWarn, logInfo } from '@/lib/logger';
 *
 * try {
 *   // ... code
 * } catch (error) {
 *   logError('api/revenues', error);
 * }
 */

type LogLevel = "info" | "warn" | "error";

interface LogEntry {
  level: LogLevel;
  context: string;
  message: string;
  stack?: string;
  timestamp: string;
  data?: Record<string, unknown>;
}

/**
 * Format error for logging
 */
function formatError(error: unknown): { message: string; stack?: string } {
  if (error instanceof Error) {
    return { message: error.message, stack: error.stack };
  }
  return { message: String(error) };
}

/**
 * Create log entry
 */
function createLogEntry(
  level: LogLevel,
  context: string,
  message: string,
  data?: Record<string, unknown>
): LogEntry {
  return {
    level,
    context,
    message,
    timestamp: new Date().toISOString(),
    data,
  };
}

/**
 * Send log entry to external monitoring service
 * Configure SENTRY_DSN or LOG_ENDPOINT in environment for production logging
 *
 * Supported services:
 * - Sentry (set SENTRY_DSN)
 * - Custom endpoint (set LOG_ENDPOINT)
 */
function sendToExternalService(entry: LogEntry) {
  // Skip if no external service configured
  const logEndpoint = process.env.LOG_ENDPOINT;
  if (!logEndpoint) return;

  // Non-blocking async send
  fetch(logEndpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(entry),
  }).catch((err) => {
    // Silent fail - don't let logging errors break the app
    console.error("[Logger] Failed to send to external service:", err.message);
  });
}

/**
 * Output log to console (extend for external services)
 */
function outputLog(entry: LogEntry) {
  const prefix = `[${entry.timestamp}] [${entry.level.toUpperCase()}] [${entry.context}]`;

  switch (entry.level) {
    case "error":
      console.error(prefix, entry.message, entry.data || "");
      if (entry.stack) console.error(entry.stack);
      break;
    case "warn":
      console.warn(prefix, entry.message, entry.data || "");
      break;
    case "info":
      console.log(prefix, entry.message, entry.data || "");
      break;
  }

  // Send to external service in production
  if (process.env.NODE_ENV === "production") {
    sendToExternalService(entry);
  }
}

/**
 * Log error with context
 *
 * @param context - Source of error (e.g., 'api/revenues', 'components/RevenueForm')
 * @param error - Error object or message
 * @param data - Additional context data
 */
export function logError(
  context: string,
  error: unknown,
  data?: Record<string, unknown>
) {
  const { message, stack } = formatError(error);
  const entry = createLogEntry("error", context, message, data);
  entry.stack = stack;
  outputLog(entry);
}

/**
 * Log warning with context
 */
export function logWarn(
  context: string,
  message: string,
  data?: Record<string, unknown>
) {
  const entry = createLogEntry("warn", context, message, data);
  outputLog(entry);
}

/**
 * Log info with context
 */
export function logInfo(
  context: string,
  message: string,
  data?: Record<string, unknown>
) {
  const entry = createLogEntry("info", context, message, data);
  outputLog(entry);
}

/**
 * Create scoped logger for a specific context
 *
 * @example
 * const log = createLogger('api/revenues');
 * log.error(error);
 * log.info('Revenue created', { id: revenue.id });
 */
export function createLogger(context: string) {
  return {
    error: (error: unknown, data?: Record<string, unknown>) =>
      logError(context, error, data),
    warn: (message: string, data?: Record<string, unknown>) =>
      logWarn(context, message, data),
    info: (message: string, data?: Record<string, unknown>) =>
      logInfo(context, message, data),
  };
}
</file>

<file path="src/lib/operator-history.ts">
// Operator history helper - audit trail for all operator changes
import { prisma } from './db';
import type { Prisma } from '@prisma/client';

// Base actions + tier-specific lock actions (LOCK_KT, UNLOCK_ADMIN, etc.)
export type HistoryAction =
  | 'CREATE'
  | 'UPDATE'
  | 'DELETE'
  | 'LOCK'
  | 'UNLOCK'
  | 'APPROVE'
  | 'ARCHIVE'
  | 'UNARCHIVE'
  | 'LOCK_KT'
  | 'UNLOCK_KT'
  | 'LOCK_ADMIN'
  | 'UNLOCK_ADMIN'
  | 'LOCK_FINAL'
  | 'UNLOCK_FINAL';

interface HistoryEntry {
  operatorId: string;
  action: HistoryAction | string; // Allow string for flexibility with tier actions
  changes: Record<string, unknown>; // Flexible for both before/after and direct values
  userId: string;
}

/**
 * Create a new history entry for an operator
 */
export async function createOperatorHistory(entry: HistoryEntry) {
  return prisma.operatorHistory.create({
    data: {
      operatorId: entry.operatorId,
      action: entry.action,
      changes: entry.changes as Prisma.InputJsonValue,
      userId: entry.userId,
    },
  });
}

/**
 * Get history for a specific operator
 */
export async function getOperatorHistory(operatorId: string, limit = 20) {
  return prisma.operatorHistory.findMany({
    where: { operatorId },
    orderBy: { createdAt: 'desc' },
    take: limit,
  });
}

/**
 * Diff two objects and return only changed fields
 * Compares JSON stringified values to handle Date and Decimal comparisons
 */
export function diffObjects(
  before: Record<string, unknown>,
  after: Record<string, unknown>
): Record<string, { before: unknown; after: unknown }> {
  const changes: Record<string, { before: unknown; after: unknown }> = {};

  // Fields to ignore in diff (metadata fields)
  const ignoreFields = ['updatedAt', 'createdAt', 'history', 'request', 'supplierRef', 'user'];

  const allKeys = new Set([...Object.keys(before), ...Object.keys(after)]);

  for (const key of allKeys) {
    if (ignoreFields.includes(key)) continue;

    const beforeVal = before[key];
    const afterVal = after[key];

    // Compare stringified values to handle Date/Decimal
    if (JSON.stringify(beforeVal) !== JSON.stringify(afterVal)) {
      changes[key] = { before: beforeVal, after: afterVal };
    }
  }

  return changes;
}
</file>

<file path="src/lib/report-utils.ts">
import type { DateRangeOption } from './validations/report-validation';

// Re-export DateRangeOption for consumers
export type { DateRangeOption } from './validations/report-validation';

// ============================================
// Date Range Types and Functions
// ============================================

export interface DateRange {
  startDate: Date;
  endDate: Date;
  label: string;
}

/**
 * Get start/end dates for fixed range option
 */
export function getDateRange(range: DateRangeOption): DateRange {
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();

  let startDate: Date;
  let endDate: Date;
  let label: string;

  switch (range) {
    case 'thisMonth':
      startDate = new Date(year, month, 1);
      endDate = new Date(year, month + 1, 0, 23, 59, 59);
      label = `Thang ${month + 1}/${year}`;
      break;

    case 'lastMonth':
      startDate = new Date(year, month - 1, 1);
      endDate = new Date(year, month, 0, 23, 59, 59);
      label = `Thang ${month}/${year}`;
      break;

    case 'last3Months':
      startDate = new Date(year, month - 2, 1);
      endDate = new Date(year, month + 1, 0, 23, 59, 59);
      label = '3 thang gan day';
      break;

    case 'last6Months':
      startDate = new Date(year, month - 5, 1);
      endDate = new Date(year, month + 1, 0, 23, 59, 59);
      label = '6 thang gan day';
      break;

    case 'thisYear':
      startDate = new Date(year, 0, 1);
      endDate = new Date(year, 11, 31, 23, 59, 59);
      label = `Nam ${year}`;
      break;

    default:
      // Default to this month
      startDate = new Date(year, month, 1);
      endDate = new Date(year, month + 1, 0, 23, 59, 59);
      label = `Thang ${month + 1}/${year}`;
  }

  return { startDate, endDate, label };
}

/**
 * Get comparison date range (previous period of same duration)
 */
export function getComparisonRange(range: DateRangeOption): DateRange {
  const current = getDateRange(range);
  const now = new Date();
  const year = now.getFullYear();
  const month = now.getMonth();

  let startDate: Date;
  let endDate: Date;

  // Calculate comparison period based on range type
  switch (range) {
    case 'thisMonth':
      // Previous month
      startDate = new Date(year, month - 1, 1);
      endDate = new Date(year, month, 0, 23, 59, 59);
      break;

    case 'lastMonth':
      // Month before last
      startDate = new Date(year, month - 2, 1);
      endDate = new Date(year, month - 1, 0, 23, 59, 59);
      break;

    case 'last3Months':
      // 3 months before the current 3-month period
      startDate = new Date(year, month - 5, 1);
      endDate = new Date(year, month - 2, 0, 23, 59, 59);
      break;

    case 'last6Months':
      // 6 months before the current 6-month period
      startDate = new Date(year, month - 11, 1);
      endDate = new Date(year, month - 5, 0, 23, 59, 59);
      break;

    case 'thisYear':
      // Previous year
      startDate = new Date(year - 1, 0, 1);
      endDate = new Date(year - 1, 11, 31, 23, 59, 59);
      break;

    default:
      // Fallback: previous period based on duration
      const duration = current.endDate.getTime() - current.startDate.getTime();
      startDate = new Date(current.startDate.getTime() - duration - 1);
      endDate = new Date(current.startDate.getTime() - 1);
  }

  return { startDate, endDate, label: 'Ky truoc' };
}

/**
 * Format period key for grouping (YYYY-MM)
 */
export function formatPeriodKey(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  return `${year}-${month}`;
}

/**
 * Calculate percentage change between current and previous values
 */
export function calcChangePercent(current: number, previous: number): number {
  if (previous === 0) return current > 0 ? 100 : 0;
  return Math.round(((current - previous) / previous) * 10000) / 100;
}

// ============================================
// Dashboard Response Types
// ============================================

export interface KpiCards {
  totalBookings: number;
  totalRevenue: number;
  totalProfit: number;
  activeRequests: number;
  conversionRate: number;
}

export interface ComparisonMetric {
  current: number;
  previous: number;
  changePercent: number;
}

export interface DashboardResponse {
  kpiCards: KpiCards;
  comparison: {
    bookings: ComparisonMetric;
    revenue: ComparisonMetric;
  };
  dateRange: DateRange;
}

// ============================================
// Revenue Trend Response Types
// ============================================

export interface TrendDataPoint {
  period: string;
  revenue: number;
  cost: number;
  profit: number;
}

export interface RevenueTrendResponse {
  data: TrendDataPoint[];
  summary: {
    totalRevenue: number;
    totalCost: number;
    totalProfit: number;
    avgMonthly: number;
  };
  dateRange: DateRange;
}

// ============================================
// Cost Breakdown Response Types
// ============================================

export interface CostByType {
  type: string;
  amount: number;
  percentage: number;
}

export interface CostBreakdownResponse {
  byServiceType: CostByType[];
  paymentStatus: {
    paid: number;
    partial: number;
    unpaid: number;
  };
  dateRange: DateRange;
}

// ============================================
// Funnel Response Types
// ============================================

export interface FunnelStage {
  stage: string;
  count: number;
  percentage: number;
}

export interface FunnelResponse {
  stages: FunnelStage[];
  conversionRate: number;
  dateRange: DateRange;
}
</file>

<file path="src/lib/validations/operator-validation.ts">
import { z } from 'zod';
import {
  SERVICE_TYPE_KEYS,
  PAYMENT_STATUS_KEYS,
  type ServiceTypeKey,
  type PaymentStatusKey,
} from '@/config/operator-config';

// ============================================
// Operator Form Validation Schema
// Vietnamese error messages for user-facing forms
// ============================================

// Service type enum from config (type-safe)
const serviceTypeEnum = z.enum(SERVICE_TYPE_KEYS as [ServiceTypeKey, ...ServiceTypeKey[]], {
  message: 'Loại dịch vụ không hợp lệ',
});

// Payment status enum from config (type-safe)
const paymentStatusEnum = z.enum(PAYMENT_STATUS_KEYS as [PaymentStatusKey, ...PaymentStatusKey[]], {
  message: 'Trạng thái thanh toán không hợp lệ',
});

// Date string validator - accepts ISO, YYYY-MM-DD, or empty
const dateStringRequired = z
  .string({ message: 'Ngày là bắt buộc' })
  .refine((val) => val && !isNaN(Date.parse(val)), { message: 'Ngày không hợp lệ' });

const dateStringOptional = z
  .string()
  .refine((val) => !val || !isNaN(Date.parse(val)), { message: 'Ngày không hợp lệ' })
  .optional()
  .nullable()
  .or(z.literal(''));

// Base object schema for operator form data (without refinements)
const operatorFormBaseSchema = z.object({
  // Required fields
  requestId: z
    .string({ message: 'Vui lòng chọn Booking' })
    .min(1, 'Vui lòng chọn Booking'),

  serviceDate: dateStringRequired,

  serviceType: serviceTypeEnum,

  serviceName: z
    .string({ message: 'Tên dịch vụ là bắt buộc' })
    .min(1, 'Vui lòng nhập tên dịch vụ')
    .max(255, 'Tên dịch vụ không được quá 255 ký tự')
    .transform((val) => val.trim()),

  // Supplier - either supplierId or supplier name required
  supplierId: z.string().optional().nullable().or(z.literal('')),
  supplier: z
    .string()
    .max(255, 'Tên NCC không được quá 255 ký tự')
    .optional()
    .nullable()
    .or(z.literal('')),

  // Cost fields
  costBeforeTax: z
    .number({ message: 'Chi phí trước thuế phải là số' })
    .min(0, 'Chi phí trước thuế không được âm'),

  vat: z
    .number({ message: 'Thuế VAT phải là số' })
    .min(0, 'Thuế VAT không được âm')
    .optional()
    .nullable(),

  totalCost: z
    .number({ message: 'Tổng chi phí phải là số' })
    .min(0, 'Tổng chi phí không được âm'),

  // Payment fields
  paidAmount: z
    .number({ message: 'Số tiền thanh toán phải là số' })
    .min(0, 'Số tiền thanh toán không được âm')
    .default(0),

  paymentDeadline: dateStringOptional,

  bankAccount: z
    .string()
    .max(255, 'Thông tin tài khoản không được quá 255 ký tự')
    .optional()
    .nullable()
    .or(z.literal('')),

  notes: z
    .string()
    .max(1000, 'Ghi chú không được quá 1000 ký tự')
    .optional()
    .nullable()
    .or(z.literal('')),
});

// Full form schema with refinements (for create)
export const operatorFormSchema = operatorFormBaseSchema
  // Supplier validation: either supplierId or supplier name required
  .refine(
    (data) => data.supplierId || data.supplier,
    {
      message: 'Vui lòng chọn NCC hoặc nhập tên NCC',
      path: ['supplier'],
    }
  )
  // totalCost must >= costBeforeTax
  .refine(
    (data) => data.totalCost >= data.costBeforeTax,
    {
      message: 'Tổng chi phí phải >= chi phí trước thuế',
      path: ['totalCost'],
    }
  )
  // paidAmount must <= totalCost
  .refine(
    (data) => data.paidAmount <= data.totalCost,
    {
      message: 'Số tiền thanh toán không được vượt quá tổng chi phí',
      path: ['paidAmount'],
    }
  )
  // paymentDeadline must >= serviceDate (if both provided)
  .refine(
    (data) => {
      if (data.paymentDeadline && data.serviceDate) {
        return new Date(data.paymentDeadline) >= new Date(data.serviceDate);
      }
      return true;
    },
    {
      message: 'Hạn thanh toán phải từ ngày dịch vụ trở đi',
      path: ['paymentDeadline'],
    }
  );

// Schema for creating new operator (same as form)
export const createOperatorSchema = operatorFormSchema;

// Schema for updating operator (all fields optional - use base schema to allow partial)
export const updateOperatorSchema = operatorFormBaseSchema.partial().extend({
  id: z.string().uuid('ID dịch vụ không hợp lệ').optional(),
});

// Schema for operator filters
export const operatorFiltersSchema = z.object({
  search: z.string().optional(),
  requestId: z.string().uuid().optional().nullable(),
  supplierId: z.string().uuid().optional().nullable(),
  serviceType: serviceTypeEnum.optional(),
  paymentStatus: paymentStatusEnum.optional(),
  fromDate: dateStringOptional,
  toDate: dateStringOptional,
  isLocked: z.boolean().optional(),
  limit: z.number().int().min(1).max(100).optional().default(50),
  offset: z.number().int().min(0).optional().default(0),
});

// ============================================
// Type Exports
// ============================================

export type OperatorFormSchemaData = z.infer<typeof operatorFormSchema>;
export type CreateOperatorData = z.infer<typeof createOperatorSchema>;
export type UpdateOperatorData = z.infer<typeof updateOperatorSchema>;
export type OperatorFiltersData = z.infer<typeof operatorFiltersSchema>;

// Error type for form validation
export interface OperatorFormErrors {
  requestId?: string;
  serviceDate?: string;
  serviceType?: string;
  serviceName?: string;
  supplierId?: string;
  supplier?: string;
  costBeforeTax?: string;
  vat?: string;
  totalCost?: string;
  paidAmount?: string;
  paymentDeadline?: string;
  bankAccount?: string;
  notes?: string;
  _form?: string; // General form error
}

// ============================================
// Validation Functions
// ============================================

/**
 * Validate operator form data
 * @param data - Form data to validate
 * @returns Object with success status, validated data or errors
 */
export function validateOperatorForm(data: unknown): {
  success: boolean;
  data?: OperatorFormSchemaData;
  errors?: OperatorFormErrors;
} {
  const result = operatorFormSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  // Transform Zod errors to field-level errors
  const errors: OperatorFormErrors = {};
  for (const issue of result.error.issues) {
    const field = issue.path[0] as keyof OperatorFormErrors;
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }

  return { success: false, errors };
}

/**
 * Validate single field (for onBlur validation)
 */
export function validateOperatorField(
  field: keyof OperatorFormSchemaData,
  value: unknown,
  formData?: Partial<OperatorFormSchemaData>
): string | null {
  // For refinements that depend on other fields, we need full form data
  if (formData) {
    const result = operatorFormSchema.safeParse({ ...formData, [field]: value });
    if (!result.success) {
      const fieldError = result.error.issues.find((issue) => issue.path[0] === field);
      return fieldError?.message || null;
    }
    return null;
  }

  // For simple field validation, extract the field schema
  const fieldSchemas: Record<string, z.ZodTypeAny> = {
    requestId: z.string().min(1, 'Vui lòng chọn Booking'),
    serviceDate: dateStringRequired,
    serviceType: serviceTypeEnum,
    serviceName: z.string().min(1, 'Vui lòng nhập tên dịch vụ').max(255),
    costBeforeTax: z.number().min(0, 'Chi phí trước thuế không được âm'),
    vat: z.number().min(0).optional().nullable(),
    totalCost: z.number().min(0, 'Tổng chi phí không được âm'),
    paidAmount: z.number().min(0, 'Số tiền thanh toán không được âm'),
  };

  const schema = fieldSchemas[field];
  if (!schema) return null;

  const result = schema.safeParse(value);
  if (!result.success) {
    return result.error.issues[0]?.message || 'Giá trị không hợp lệ';
  }
  return null;
}

// ============================================
// API Schema (for server-side validation)
// ============================================

// API Create Operator Schema
export const createOperatorApiSchema = z
  .object({
    requestId: z.string({ message: 'Booking là bắt buộc' }).min(1, 'Vui lòng chọn Booking'),
    serviceDate: z
      .string({ message: 'Ngày dịch vụ là bắt buộc' })
      .refine((val) => !isNaN(Date.parse(val)), { message: 'Ngày dịch vụ không hợp lệ' }),
    serviceType: serviceTypeEnum,
    serviceName: z
      .string({ message: 'Tên dịch vụ là bắt buộc' })
      .min(1, 'Vui lòng nhập tên dịch vụ')
      .max(255),
    supplierId: z.string().uuid().optional().nullable(),
    supplier: z.string().max(255).optional().nullable(),
    costBeforeTax: z.number().min(0, 'Chi phí trước thuế không được âm'),
    vat: z.number().min(0).optional().nullable(),
    totalCost: z.number().min(0, 'Tổng chi phí không được âm'),
    paidAmount: z.number().min(0, 'Số tiền thanh toán không được âm').default(0),
    paymentDeadline: z
      .string()
      .refine((val) => !val || !isNaN(Date.parse(val)), { message: 'Hạn thanh toán không hợp lệ' })
      .optional()
      .nullable(),
    bankAccount: z.string().max(255).optional().nullable(),
    notes: z.string().max(1000).optional().nullable(),
  })
  .refine(
    (data) => data.supplierId || data.supplier,
    {
      message: 'Vui lòng chọn NCC hoặc nhập tên NCC',
      path: ['supplier'],
    }
  )
  .refine(
    (data) => data.totalCost >= data.costBeforeTax,
    {
      message: 'Tổng chi phí phải >= chi phí trước thuế',
      path: ['totalCost'],
    }
  )
  .refine(
    (data) => data.paidAmount <= data.totalCost,
    {
      message: 'Số tiền thanh toán không được vượt quá tổng chi phí',
      path: ['paidAmount'],
    }
  );

// API Update Operator Schema (all fields optional)
export const updateOperatorApiSchema = z
  .object({
    supplierId: z.string().uuid().optional().nullable(),
    supplier: z.string().max(255).optional().nullable(),
    serviceDate: z
      .string()
      .refine((val) => !isNaN(Date.parse(val)), { message: 'Ngày dịch vụ không hợp lệ' })
      .optional(),
    serviceType: serviceTypeEnum.optional(),
    serviceName: z.string().min(1).max(255).optional(),
    costBeforeTax: z.number().min(0, 'Chi phí trước thuế không được âm').optional(),
    vat: z.number().min(0).optional().nullable(),
    totalCost: z.number().min(0, 'Tổng chi phí không được âm').optional(),
    paidAmount: z.number().min(0, 'Số tiền thanh toán không được âm').optional(),
    paymentDeadline: z
      .string()
      .refine((val) => !val || !isNaN(Date.parse(val)), { message: 'Hạn thanh toán không hợp lệ' })
      .optional()
      .nullable(),
    bankAccount: z.string().max(255).optional().nullable(),
    notes: z.string().max(1000).optional().nullable(),
    userId: z.string().optional(), // For history tracking
  });

export type CreateOperatorApiData = z.infer<typeof createOperatorApiSchema>;
export type UpdateOperatorApiData = z.infer<typeof updateOperatorApiSchema>;

/**
 * Extract field errors from Zod error for API response
 */
export function extractOperatorZodErrors(error: z.ZodError): Record<string, string> {
  const errors: Record<string, string> = {};
  for (const issue of error.issues) {
    const field = issue.path.join('.');
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }
  return errors;
}

// ============================================
// Transform Helpers
// ============================================

/**
 * Transform form data - convert empty strings to null
 * Use before API submission
 */
export function transformOperatorFormData(data: OperatorFormSchemaData) {
  return {
    ...data,
    supplierId: data.supplierId || null,
    supplier: data.supplier || null,
    vat: data.vat ?? null,
    paymentDeadline: data.paymentDeadline || null,
    bankAccount: data.bankAccount || null,
    notes: data.notes || null,
  };
}

/**
 * Parse numeric input from form (handles empty string, NaN)
 */
export function parseOperatorNumericInput(
  value: string | number | undefined | null,
  defaultValue: number = 0
): number {
  if (value === undefined || value === null || value === '') {
    return defaultValue;
  }
  const parsed = typeof value === 'number' ? value : parseFloat(value);
  return isNaN(parsed) ? defaultValue : parsed;
}
</file>

<file path="src/app/(dashboard)/operators/approvals/page.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { toast } from 'sonner';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { OperatorApprovalTable } from '@/components/operators/operator-approval-table';
import { ApprovalSummaryCards } from '@/components/operators/approval-summary-cards';
import { ErrorFallback } from '@/components/ui/error-fallback';
import { safeFetch, safePost } from '@/lib/api/fetch-utils';
import { CheckCircle, RefreshCw } from 'lucide-react';
import type { ApprovalQueueItem } from '@/types';

interface Summary {
  total: number;
  totalAmount: number;
  overdue: number;
  overdueAmount: number;
  dueToday: number;
  dueThisWeek: number;
}

interface PendingPaymentsResponse {
  data: ApprovalQueueItem[];
  summary: Summary;
}

export default function ApprovalsPage() {
  const [items, setItems] = useState<ApprovalQueueItem[]>([]);
  const [summary, setSummary] = useState<Summary>({
    total: 0,
    totalAmount: 0,
    overdue: 0,
    overdueAmount: 0,
    dueToday: 0,
    dueThisWeek: 0,
  });
  const [filter, setFilter] = useState('all');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);

    const { data, error: fetchError } = await safeFetch<PendingPaymentsResponse>(
      `/api/operators/pending-payments?filter=${filter}`
    );

    if (fetchError) {
      setError(fetchError);
      toast.error(fetchError);
    } else if (data) {
      setItems(data.data);
      setSummary(data.summary);
    }
    setLoading(false);
  }, [filter]);

  useEffect(() => {
    // eslint-disable-next-line react-hooks/set-state-in-effect -- async fetch pattern is valid
    void fetchData();
  }, [fetchData]);

  const handleApprove = async (ids: string[], paymentDate: Date) => {
    const { data, error: approveError } = await safePost<{ count: number }>(
      '/api/operators/approve',
      {
        operatorIds: ids,
        paymentDate: paymentDate.toISOString(),
      }
    );

    if (approveError) {
      toast.error(approveError);
    } else if (data) {
      toast.success(`Đã duyệt ${data.count} dịch vụ`);
      fetchData();
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <CheckCircle className="h-6 w-6" />
            Duyệt Thanh Toán
          </h1>
          <p className="text-muted-foreground">Duyệt chi phí dịch vụ chờ thanh toán</p>
        </div>
        {error && (
          <Button variant="outline" onClick={fetchData}>
            <RefreshCw className="mr-2 h-4 w-4" />
            Thử lại
          </Button>
        )}
      </div>

      <ApprovalSummaryCards summary={summary} />

      <Card>
        <CardHeader>
          <CardTitle>Danh sách chờ duyệt</CardTitle>
        </CardHeader>
        <CardContent>
          {error ? (
            <ErrorFallback
              title="Lỗi tải danh sách duyệt"
              message={error}
              onRetry={fetchData}
              retryLabel="Tải lại"
            />
          ) : (
            <Tabs value={filter} onValueChange={setFilter}>
              <TabsList>
                <TabsTrigger value="all">Tất cả</TabsTrigger>
                <TabsTrigger value="overdue">Quá hạn</TabsTrigger>
                <TabsTrigger value="today">Hôm nay</TabsTrigger>
                <TabsTrigger value="week">Tuần này</TabsTrigger>
              </TabsList>

              <TabsContent value={filter} className="mt-4">
                <OperatorApprovalTable
                  items={items}
                  onApprove={handleApprove}
                  loading={loading}
                />
              </TabsContent>
            </Tabs>
          )}
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/api/requests/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { calculateNextFollowUp, calculateEndDate, generateBookingCode } from '@/lib/request-utils';
import { getStageFromStatus, isFollowUpStatus, type RequestStatus } from '@/config/request-config';
import { getSessionUser, unauthorizedResponse, forbiddenResponse } from '@/lib/auth-utils';
import { updateRequestApiSchema, extractZodErrors } from '@/lib/validations/request-validation';

interface RouteParams {
  params: Promise<{ id: string }>;
}

// GET /api/requests/[id] - Get single request
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    // Verify authentication
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const { id } = await params;

    const req = await prisma.request.findUnique({
      where: { id },
      include: {
        seller: { select: { id: true, name: true, email: true } },
        operators: {
          include: {
            supplierRef: { select: { code: true, name: true } },
          },
          orderBy: { serviceDate: 'asc' },
        },
        revenues: { orderBy: { paymentDate: 'desc' } },
        _count: { select: { operators: true, revenues: true, emails: true } },
      },
    });

    if (!req) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy yêu cầu' },
        { status: 404 }
      );
    }

    // SELLER can only view their own requests
    if (user.role === 'SELLER' && req.sellerId !== user.id) {
      return forbiddenResponse('Bạn không có quyền xem yêu cầu này');
    }

    return NextResponse.json({ success: true, data: req });
  } catch (error) {
    console.error('Error fetching request:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải yêu cầu: ${message}` },
      { status: 500 }
    );
  }
}

// PUT /api/requests/[id] - Update request
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    // Verify authentication
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const { id } = await params;
    const body = await request.json();

    // Validate with Zod schema (partial - all fields optional)
    const validation = updateRequestApiSchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Dữ liệu không hợp lệ',
          details: extractZodErrors(validation.error),
        },
        { status: 400 }
      );
    }

    const data = validation.data;

    // Check if request exists
    const existing = await prisma.request.findUnique({ where: { id } });
    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy yêu cầu' },
        { status: 404 }
      );
    }

    // SELLER can only edit their own requests
    if (user.role === 'SELLER' && existing.sellerId !== user.id) {
      return forbiddenResponse('Bạn không có quyền chỉnh sửa yêu cầu này');
    }

    // ACCOUNTANT can only view, not edit
    if (user.role === 'ACCOUNTANT') {
      return forbiddenResponse('Kế toán không có quyền chỉnh sửa yêu cầu');
    }

    // Build update data from validated input
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateData: Record<string, any> = {};
    let responseWarning: string | null = null;

    // Basic fields - only update if provided
    if (data.customerName !== undefined) updateData.customerName = data.customerName.trim();
    if (data.contact !== undefined) updateData.contact = data.contact.trim();
    if (data.whatsapp !== undefined) updateData.whatsapp = data.whatsapp?.trim() || null;
    if (data.pax !== undefined) updateData.pax = data.pax;
    if (data.country !== undefined) updateData.country = data.country.trim();
    if (data.source !== undefined) updateData.source = data.source.trim();
    if (data.tourDays !== undefined) updateData.tourDays = data.tourDays;
    if (data.expectedDate !== undefined) {
      updateData.expectedDate = data.expectedDate ? new Date(data.expectedDate) : null;
    }
    if (data.expectedRevenue !== undefined) updateData.expectedRevenue = data.expectedRevenue;
    if (data.expectedCost !== undefined) updateData.expectedCost = data.expectedCost;
    if (data.notes !== undefined) updateData.notes = data.notes?.trim() || null;
    if (data.lastContactDate !== undefined) {
      updateData.lastContactDate = data.lastContactDate ? new Date(data.lastContactDate) : null;
    }

    // Handle startDate and calculate endDate
    if (data.startDate !== undefined) {
      updateData.startDate = data.startDate ? new Date(data.startDate) : null;
      // Calculate endDate if startDate and tourDays available
      if (data.startDate) {
        const days = data.tourDays ?? existing.tourDays;
        if (days) {
          updateData.endDate = calculateEndDate(new Date(data.startDate), days);
        }
      }
    } else if (data.tourDays !== undefined && data.tourDays !== null && existing.startDate) {
      // If only tourDays changed, recalculate endDate
      updateData.endDate = calculateEndDate(existing.startDate, data.tourDays);
    }

    // Handle status change → update stage and nextFollowUp
    if (data.status !== undefined && data.status !== existing.status) {
      const newStatus = data.status as RequestStatus;
      updateData.status = newStatus;
      updateData.stage = getStageFromStatus(newStatus);
      updateData.statusChangedAt = new Date();
      // Note: statusChangedBy should be set from auth context when available
      if (data.statusChangedBy) {
        updateData.statusChangedBy = data.statusChangedBy;
      }

      // Recalculate nextFollowUp based on new status
      if (isFollowUpStatus(newStatus)) {
        const contactDate = data.lastContactDate
          ? new Date(data.lastContactDate)
          : existing.lastContactDate || new Date();
        updateData.nextFollowUp = await calculateNextFollowUp(newStatus, contactDate);
      } else {
        updateData.nextFollowUp = null;
      }

      // Handle BOOKING status transition - generate booking code
      if (newStatus === 'BOOKING' && existing.status !== 'BOOKING') {
        // Require startDate for booking
        const startDate = data.startDate ? new Date(data.startDate) : existing.startDate;
        if (!startDate) {
          return NextResponse.json(
            {
              success: false,
              error: 'Cần nhập ngày bắt đầu tour trước khi chuyển Booking',
              details: { startDate: 'Ngày bắt đầu là bắt buộc khi chuyển sang Booking' },
            },
            { status: 400 }
          );
        }

        // Generate booking code using sellerId (function handles fallback logic)
        const bookingCode = await generateBookingCode(startDate, existing.sellerId);
        updateData.bookingCode = bookingCode;
      }

      // Warning when reverting from BOOKING status
      if (existing.status === 'BOOKING' && newStatus !== 'BOOKING') {
        responseWarning = 'Đã chuyển khỏi Booking. Mã booking và operators vẫn được giữ lại.';
      }
    } else if (data.lastContactDate !== undefined && data.lastContactDate !== null && isFollowUpStatus(existing.status as RequestStatus)) {
      // If only lastContactDate changed and status is F1-F4, recalculate nextFollowUp
      updateData.nextFollowUp = await calculateNextFollowUp(
        existing.status as RequestStatus,
        new Date(data.lastContactDate)
      );
    }

    // Manual nextFollowUp override (if explicitly provided)
    if (data.nextFollowUp !== undefined && !data.status) {
      updateData.nextFollowUp = data.nextFollowUp ? new Date(data.nextFollowUp) : null;
    }

    const updatedRequest = await prisma.request.update({
      where: { id },
      data: updateData,
      include: {
        seller: { select: { id: true, name: true, email: true } },
      },
    });

    return NextResponse.json({
      success: true,
      data: updatedRequest,
      ...(responseWarning && { warning: responseWarning }),
    });
  } catch (error) {
    console.error('Error updating request:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi cập nhật yêu cầu: ${message}` },
      { status: 500 }
    );
  }
}

// DELETE /api/requests/[id] - Delete request
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    // Verify authentication
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const { id } = await params;

    // Check if request exists
    const existing = await prisma.request.findUnique({
      where: { id },
      include: { _count: { select: { operators: true, revenues: true } } },
    });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy yêu cầu' },
        { status: 404 }
      );
    }

    // SELLER can only delete their own requests
    if (user.role === 'SELLER' && existing.sellerId !== user.id) {
      return forbiddenResponse('Bạn không có quyền xóa yêu cầu này');
    }

    // Only ADMIN can delete requests (SELLER can delete own, ACCOUNTANT cannot delete)
    if (user.role === 'ACCOUNTANT') {
      return forbiddenResponse('Kế toán không có quyền xóa yêu cầu');
    }

    // Prevent deletion if has related records
    if (existing._count.operators > 0 || existing._count.revenues > 0) {
      return NextResponse.json(
        { success: false, error: 'Không thể xóa yêu cầu đã có dịch vụ hoặc doanh thu liên kết' },
        { status: 400 }
      );
    }

    await prisma.request.delete({ where: { id } });

    return NextResponse.json({ success: true, message: 'Đã xóa yêu cầu' });
  } catch (error) {
    console.error('Error deleting request:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi xóa yêu cầu: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/requests/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { generateRQID, calculateNextFollowUp, getFollowUpDateBoundaries } from '@/lib/request-utils';
import { getStageFromStatus, isFollowUpStatus, type RequestStatus } from '@/config/request-config';
import { getSessionUser, unauthorizedResponse } from '@/lib/auth-utils';
import { createRequestApiSchema, extractZodErrors } from '@/lib/validations/request-validation';

// GET /api/requests - List with filters
export async function GET(request: NextRequest) {
  try {
    // Verify authentication
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const { searchParams } = new URL(request.url);

    // Extract filters
    const search = searchParams.get('search') || '';
    const status = searchParams.get('status') || '';
    const stage = searchParams.get('stage') || '';
    const sellerId = searchParams.get('sellerId') || '';
    const source = searchParams.get('source') || '';
    const country = searchParams.get('country') || '';
    const fromDate = searchParams.get('fromDate') || '';
    const toDate = searchParams.get('toDate') || '';
    const followup = searchParams.get('followup') || ''; // overdue, today, upcoming
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Build where clause
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const where: Record<string, any> = {};

    // SELLER can only view their own requests
    if (user.role === 'SELLER') {
      where.sellerId = user.id;
    }

    if (search) {
      where.OR = [
        { code: { contains: search, mode: 'insensitive' } },
        { rqid: { contains: search, mode: 'insensitive' } },
        { customerName: { contains: search, mode: 'insensitive' } },
        { contact: { contains: search, mode: 'insensitive' } },
        { bookingCode: { contains: search, mode: 'insensitive' } },
      ];
    }

    if (status) where.status = status;
    if (stage) where.stage = stage;
    // Only allow sellerId filter for non-SELLER users (SELLER already restricted above)
    if (sellerId && user.role !== 'SELLER') where.sellerId = sellerId;
    if (source) where.source = source;
    if (country) where.country = country;

    if (fromDate || toDate) {
      where.receivedDate = {};
      if (fromDate) where.receivedDate.gte = new Date(fromDate);
      if (toDate) where.receivedDate.lte = new Date(toDate);
    }

    // Follow-up filters
    if (followup) {
      const { todayStart, todayEnd, threeDaysLater } = getFollowUpDateBoundaries();

      if (followup === 'overdue') {
        where.nextFollowUp = { lt: todayStart };
        where.stage = { not: 'OUTCOME' }; // Only active requests
      } else if (followup === 'today') {
        where.nextFollowUp = { gte: todayStart, lt: todayEnd };
      } else if (followup === 'upcoming') {
        where.nextFollowUp = { gte: todayEnd, lt: threeDaysLater };
      }
    }

    const [requests, total] = await Promise.all([
      prisma.request.findMany({
        where,
        include: {
          seller: { select: { id: true, name: true, email: true } },
          _count: { select: { operators: true, revenues: true } },
        },
        orderBy: { receivedDate: 'desc' },
        skip: offset,
        take: limit,
      }),
      prisma.request.count({ where }),
    ]);

    return NextResponse.json({
      success: true,
      data: requests,
      total,
      hasMore: offset + requests.length < total,
    });
  } catch (error) {
    console.error('Error fetching requests:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải danh sách yêu cầu: ${message}` },
      { status: 500 }
    );
  }
}

// POST /api/requests - Create request
export async function POST(request: NextRequest) {
  try {
    // Verify authentication
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const body = await request.json();

    // Validate with Zod schema
    const validation = createRequestApiSchema.safeParse(body);
    if (!validation.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Dữ liệu không hợp lệ',
          details: extractZodErrors(validation.error),
        },
        { status: 400 }
      );
    }

    const data = validation.data;

    // SELLER must create requests for themselves only
    // ADMIN can create for any seller
    const sellerId = user.role === 'SELLER' ? user.id : (data.sellerId || user.id);

    // Generate legacy code: YYMMDD-NAME-COUNTRY
    const now = new Date();
    const dateStr = now.toISOString().slice(2, 10).replace(/-/g, '');
    const namePart = data.customerName.split(' ')[0].toUpperCase().slice(0, 4);
    const countryPart = data.country.toUpperCase().slice(0, 2);
    const randomSuffix = Math.random().toString(36).substring(2, 4).toUpperCase();
    const code = `${dateStr}-${namePart}-${countryPart}-${randomSuffix}`;

    // Generate RQID
    const rqid = await generateRQID();

    // Determine status and stage
    const status = (data.status || 'DANG_LL_CHUA_TL') as RequestStatus;
    const stage = getStageFromStatus(status);

    // Calculate nextFollowUp if status is F1-F4
    let nextFollowUp: Date | null = null;
    if (isFollowUpStatus(status)) {
      const contactDate = data.lastContactDate ? new Date(data.lastContactDate) : now;
      nextFollowUp = await calculateNextFollowUp(status, contactDate);
    }

    // Create request
    const newRequest = await prisma.request.create({
      data: {
        code,
        rqid,
        customerName: data.customerName.trim(),
        contact: data.contact.trim(),
        whatsapp: data.whatsapp?.trim() || null,
        pax: data.pax || 1,
        country: data.country.trim(),
        source: data.source.trim(),
        status,
        stage,
        tourDays: data.tourDays || null,
        startDate: data.startDate ? new Date(data.startDate) : null,
        expectedDate: data.expectedDate ? new Date(data.expectedDate) : null,
        expectedRevenue: data.expectedRevenue || null,
        expectedCost: data.expectedCost || null,
        lastContactDate: data.lastContactDate ? new Date(data.lastContactDate) : null,
        nextFollowUp,
        notes: data.notes?.trim() || null,
        sellerId,
      },
      include: {
        seller: { select: { id: true, name: true, email: true } },
      },
    });

    return NextResponse.json({ success: true, data: newRequest }, { status: 201 });
  } catch (error) {
    console.error('Error creating request:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo yêu cầu: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/revenues/[id]/lock/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { auth } from '@/auth';
import { type Role } from '@/lib/permissions';
import {
  canLock,
  canLockTier,
  getLockFields,
  type LockTier,
  LOCK_TIERS,
} from '@/lib/lock-utils';
import { createRevenueHistory } from '@/lib/revenue-history';

// POST /api/revenues/[id]/lock - Lock revenue with tier support
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Verify authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chưa đăng nhập' },
        { status: 401 }
      );
    }

    const { id } = await params;
    const body = await request.json();
    const tier = body.tier as LockTier;

    // Validate tier parameter
    if (!tier || !LOCK_TIERS.includes(tier)) {
      return NextResponse.json(
        { success: false, error: 'Tier không hợp lệ. Phải là: KT, Admin, hoặc Final' },
        { status: 400 }
      );
    }

    // Permission check using role-based lock permissions
    const role = session.user.role as Role;
    if (!canLock(role, tier)) {
      return NextResponse.json(
        { success: false, error: `Không có quyền khóa tier ${tier}` },
        { status: 403 }
      );
    }

    // Get current revenue state
    const revenue = await prisma.revenue.findUnique({
      where: { id },
      select: {
        id: true,
        lockKT: true,
        lockAdmin: true,
        lockFinal: true,
      },
    });

    if (!revenue) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy thu nhập' },
        { status: 404 }
      );
    }

    // Validate tier progression (KT -> Admin -> Final)
    const lockState = {
      lockKT: revenue.lockKT,
      lockAdmin: revenue.lockAdmin,
      lockFinal: revenue.lockFinal,
    };

    if (!canLockTier(lockState, tier)) {
      return NextResponse.json(
        {
          success: false,
          error: `Không thể khóa tier ${tier}. Phải khóa theo thứ tự: KT → Admin → Final`,
          currentState: lockState,
        },
        { status: 400 }
      );
    }

    // Update with tier-specific fields
    const lockFields = getLockFields(tier, session.user.id, true);
    const updated = await prisma.revenue.update({
      where: { id },
      data: lockFields,
      include: {
        request: { select: { code: true, customerName: true, bookingCode: true } },
      },
    });

    // Create history entry
    await createRevenueHistory({
      revenueId: id,
      action: `LOCK_${tier.toUpperCase()}` as 'LOCK_KT' | 'LOCK_ADMIN' | 'LOCK_FINAL',
      changes: { [tier]: { before: false, after: true } },
      userId: session.user.id,
    });

    return NextResponse.json({ success: true, tier, data: updated });
  } catch (error) {
    console.error('Error locking revenue:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi khóa thu nhập: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/revenues/[id]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { CURRENCY_KEYS } from '@/config/revenue-config';
import { auth } from '@/auth';
import { hasPermission, type Role } from '@/lib/permissions';
import { updateRevenueApiSchema, extractRevenueZodErrors } from '@/lib/validations/revenue-validation';

// GET /api/revenues/[id] - Get single revenue
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Verify authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chưa đăng nhập' },
        { status: 401 }
      );
    }

    // Verify permission
    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:view')) {
      return NextResponse.json(
        { success: false, error: 'Không có quyền xem thu nhập' },
        { status: 403 }
      );
    }

    const { id } = await params;

    const revenue = await prisma.revenue.findUnique({
      where: { id },
      include: {
        request: { select: { id: true, code: true, customerName: true, bookingCode: true } },
        user: { select: { id: true, name: true } },
      },
    });

    if (!revenue) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy thu nhập' },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, data: revenue });
  } catch (error) {
    console.error('Error fetching revenue:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải thu nhập: ${message}` },
      { status: 500 }
    );
  }
}

// PUT /api/revenues/[id] - Update revenue
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Verify authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chưa đăng nhập' },
        { status: 401 }
      );
    }

    // Verify permission
    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:manage')) {
      return NextResponse.json(
        { success: false, error: 'Không có quyền sửa thu nhập' },
        { status: 403 }
      );
    }

    const { id } = await params;
    const body = await request.json();

    // Check if revenue exists
    const existing = await prisma.revenue.findUnique({ where: { id } });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy thu nhập' },
        { status: 404 }
      );
    }

    // Check if any lock tier is active (3-tier lock system)
    if (existing.lockKT || existing.lockAdmin || existing.lockFinal) {
      return NextResponse.json(
        { success: false, error: 'Thu nhap da khoa, khong the sua' },
        { status: 403 }
      );
    }

    // Validate with Zod schema
    const validationResult = updateRevenueApiSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Du lieu khong hop le',
          errors: extractRevenueZodErrors(validationResult.error)
        },
        { status: 400 }
      );
    }
    const validatedData = validationResult.data;

    // Calculate amountVND if currency changed
    const currency = validatedData.currency || existing.currency || 'VND';
    let amountVND = Number(existing.amountVND);
    let foreignAmount = existing.foreignAmount ? Number(existing.foreignAmount) : null;
    let exchangeRate = existing.exchangeRate ? Number(existing.exchangeRate) : null;

    if (validatedData.currency !== undefined || validatedData.foreignAmount !== undefined || validatedData.exchangeRate !== undefined || validatedData.amountVND !== undefined) {
      if (currency === 'VND') {
        amountVND = (validatedData.amountVND ?? Number(existing.amountVND)) || 0;
        foreignAmount = null;
        exchangeRate = null;
      } else {
        // Currency already validated by Zod
        foreignAmount = validatedData.foreignAmount ?? (existing.foreignAmount ? Number(existing.foreignAmount) : 0);
        exchangeRate = validatedData.exchangeRate ?? (existing.exchangeRate ? Number(existing.exchangeRate) : 0);
        amountVND = Math.round((foreignAmount ?? 0) * (exchangeRate ?? 0));
      }

      if (amountVND <= 0) {
        return NextResponse.json(
          { success: false, error: 'So tien VND phai > 0' },
          { status: 400 }
        );
      }
    }

    // Update revenue
    const revenue = await prisma.revenue.update({
      where: { id },
      data: {
        paymentDate: validatedData.paymentDate ? new Date(validatedData.paymentDate) : undefined,
        paymentType: validatedData.paymentType,
        foreignAmount,
        currency,
        exchangeRate,
        amountVND,
        paymentSource: validatedData.paymentSource,
        notes: validatedData.notes?.trim(),
      },
      include: {
        request: { select: { code: true, customerName: true, bookingCode: true } },
        user: { select: { id: true, name: true } },
      },
    });

    return NextResponse.json({ success: true, data: revenue });
  } catch (error) {
    console.error('Error updating revenue:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi cập nhật thu nhập: ${message}` },
      { status: 500 }
    );
  }
}

// DELETE /api/revenues/[id] - Delete revenue
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Verify authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chưa đăng nhập' },
        { status: 401 }
      );
    }

    // Verify permission
    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:manage')) {
      return NextResponse.json(
        { success: false, error: 'Không có quyền xóa thu nhập' },
        { status: 403 }
      );
    }

    const { id } = await params;

    // Check if exists
    const existing = await prisma.revenue.findUnique({ where: { id } });

    if (!existing) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy thu nhập' },
        { status: 404 }
      );
    }

    // Check if any lock tier is active (3-tier lock system)
    if (existing.lockKT || existing.lockAdmin || existing.lockFinal) {
      return NextResponse.json(
        { success: false, error: 'Thu nhập đã khóa, không thể xóa' },
        { status: 403 }
      );
    }

    await prisma.revenue.delete({ where: { id } });

    return NextResponse.json({ success: true, message: 'Đã xóa thu nhập' });
  } catch (error) {
    console.error('Error deleting revenue:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi xóa thu nhập: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/revenues/[id]/unlock/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { auth } from '@/auth';
import { type Role } from '@/lib/permissions';
import {
  canUnlock,
  canUnlockTier,
  getLockFields,
  type LockTier,
  LOCK_TIERS,
} from '@/lib/lock-utils';
import { createRevenueHistory } from '@/lib/revenue-history';

// POST /api/revenues/[id]/unlock - Unlock revenue with tier support
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // Verify authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chưa đăng nhập' },
        { status: 401 }
      );
    }

    const { id } = await params;
    const body = await request.json();
    const tier = body.tier as LockTier;

    // Validate tier parameter
    if (!tier || !LOCK_TIERS.includes(tier)) {
      return NextResponse.json(
        { success: false, error: 'Tier không hợp lệ. Phải là: KT, Admin, hoặc Final' },
        { status: 400 }
      );
    }

    // Permission check using role-based unlock permissions
    const role = session.user.role as Role;
    if (!canUnlock(role, tier)) {
      return NextResponse.json(
        { success: false, error: `Không có quyền mở khóa tier ${tier}` },
        { status: 403 }
      );
    }

    // Get current revenue state
    const revenue = await prisma.revenue.findUnique({
      where: { id },
      select: {
        id: true,
        lockKT: true,
        lockAdmin: true,
        lockFinal: true,
      },
    });

    if (!revenue) {
      return NextResponse.json(
        { success: false, error: 'Không tìm thấy thu nhập' },
        { status: 404 }
      );
    }

    // Validate reverse unlock order (Final -> Admin -> KT)
    const lockState = {
      lockKT: revenue.lockKT,
      lockAdmin: revenue.lockAdmin,
      lockFinal: revenue.lockFinal,
    };

    if (!canUnlockTier(lockState, tier)) {
      return NextResponse.json(
        {
          success: false,
          error: `Không thể mở khóa tier ${tier}. Phải mở khóa theo thứ tự: Final → Admin → KT`,
          currentState: lockState,
        },
        { status: 400 }
      );
    }

    // Update with tier-specific fields (unlock = false)
    const unlockFields = getLockFields(tier, session.user.id, false);
    const updated = await prisma.revenue.update({
      where: { id },
      data: unlockFields,
      include: {
        request: { select: { code: true, customerName: true, bookingCode: true } },
      },
    });

    // Create history entry
    await createRevenueHistory({
      revenueId: id,
      action: `UNLOCK_${tier.toUpperCase()}` as 'UNLOCK_KT' | 'UNLOCK_ADMIN' | 'UNLOCK_FINAL',
      changes: { [tier]: { before: true, after: false } },
      userId: session.user.id,
    });

    return NextResponse.json({ success: true, tier, data: updated });
  } catch (error) {
    console.error('Error unlocking revenue:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi mở khóa thu nhập: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/sync/sheets/route.ts">
/**
 * Google Sheets Sync API
 *
 * POST - Trigger sync for a specific sheet (ADMIN only)
 * GET - Get sync status and statistics
 *
 * Supports: Request, Operator, Revenue sheets
 */

import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/auth";
import { hasPermission, type Role } from "@/lib/permissions";
import { prisma } from "@/lib/db";
import {
  getSheetData,
  getLastSyncedRow,
  isGoogleSheetsConfigured,
  getSheetConfigStatus,
} from "@/lib/google-sheets";
import {
  mapRequestRow,
  mapOperatorRow,
  mapRevenueRow,
} from "@/lib/sheet-mappers";
import { logError, logInfo } from "@/lib/logger";

const VALID_SHEETS = ["Request", "Operator", "Revenue"] as const;
type SheetName = (typeof VALID_SHEETS)[number];

interface SyncResult {
  success: boolean;
  message: string;
  synced: number;
  errors: number;
  lastRowIndex?: number;
}

/**
 * Sync Request sheet rows to database
 */
async function syncRequestSheet(
  rows: { rowIndex: number; values: string[] }[]
): Promise<{ synced: number; errors: number }> {
  let synced = 0;
  let errors = 0;

  for (const row of rows) {
    try {
      const data = await mapRequestRow(row.values, row.rowIndex);
      if (!data) continue;

      // Upsert by unique code (Request ID from column AR)
      await prisma.request.upsert({
        where: { code: data.code },
        update: {
          bookingCode: data.bookingCode,
          customerName: data.customerName,
          contact: data.contact,
          country: data.country,
          source: data.source,
          status: data.status,
          stage: data.stage,
          pax: data.pax,
          tourDays: data.tourDays,
          startDate: data.startDate,
          endDate: data.endDate,
          expectedRevenue: data.expectedRevenue,
          expectedCost: data.expectedCost,
          notes: data.notes,
          sheetRowIndex: data.sheetRowIndex,
          updatedAt: new Date(),
        },
        create: data,
      });

      // Log success
      await prisma.syncLog.create({
        data: {
          sheetName: "Request",
          action: "SYNC",
          rowIndex: row.rowIndex,
          recordId: data.code,
          status: "SUCCESS",
        },
      });

      synced++;
    } catch (error) {
      // Log failure
      await prisma.syncLog.create({
        data: {
          sheetName: "Request",
          action: "SYNC",
          rowIndex: row.rowIndex,
          status: "FAILED",
          errorMessage: error instanceof Error ? error.message : "Unknown error",
        },
      });
      errors++;
    }
  }

  return { synced, errors };
}

/**
 * Sync Operator sheet rows to database
 */
async function syncOperatorSheet(
  rows: { rowIndex: number; values: string[] }[]
): Promise<{ synced: number; errors: number }> {
  let synced = 0;
  let errors = 0;

  for (const row of rows) {
    try {
      const data = await mapOperatorRow(row.values, row.rowIndex);
      if (!data) continue;

      // Find the request by bookingCode (Operator sheet uses booking code, not request ID)
      const request = await prisma.request.findFirst({
        where: { bookingCode: data.requestCode },
      });

      if (!request) {
        throw new Error(`Request not found for bookingCode: ${data.requestCode}`);
      }

      // Create operator (no upsert - operators can duplicate)
      await prisma.operator.create({
        data: {
          requestId: request.id,
          serviceDate: data.serviceDate,
          serviceType: data.serviceType,
          serviceName: data.serviceName,
          supplier: data.supplier,
          costBeforeTax: data.costBeforeTax,
          vat: data.vat,
          totalCost: data.totalCost,
          paymentStatus: data.paymentStatus,
          notes: data.notes,
          userId: data.userId,
          sheetRowIndex: data.sheetRowIndex,
        },
      });

      await prisma.syncLog.create({
        data: {
          sheetName: "Operator",
          action: "SYNC",
          rowIndex: row.rowIndex,
          recordId: data.requestCode,
          status: "SUCCESS",
        },
      });

      synced++;
    } catch (error) {
      await prisma.syncLog.create({
        data: {
          sheetName: "Operator",
          action: "SYNC",
          rowIndex: row.rowIndex,
          status: "FAILED",
          errorMessage: error instanceof Error ? error.message : "Unknown error",
        },
      });
      errors++;
    }
  }

  return { synced, errors };
}

/**
 * Sync Revenue sheet rows to database
 */
async function syncRevenueSheet(
  rows: { rowIndex: number; values: string[] }[]
): Promise<{ synced: number; errors: number }> {
  let synced = 0;
  let errors = 0;

  for (const row of rows) {
    try {
      const data = await mapRevenueRow(row.values, row.rowIndex);
      if (!data) continue;

      // Find the request by bookingCode (Revenue sheet uses booking code, not request ID)
      const request = await prisma.request.findFirst({
        where: { bookingCode: data.requestCode },
      });

      if (!request) {
        throw new Error(`Request not found for bookingCode: ${data.requestCode}`);
      }

      // Create revenue (no upsert - revenues can have multiple entries)
      await prisma.revenue.create({
        data: {
          requestId: request.id,
          paymentDate: data.paymentDate,
          paymentType: data.paymentType,
          foreignAmount: data.foreignAmount,
          currency: data.currency,
          exchangeRate: data.exchangeRate,
          amountVND: data.amountVND,
          paymentSource: data.paymentSource,
          notes: data.notes,
          userId: data.userId,
          sheetRowIndex: data.sheetRowIndex,
        },
      });

      await prisma.syncLog.create({
        data: {
          sheetName: "Revenue",
          action: "SYNC",
          rowIndex: row.rowIndex,
          recordId: data.requestCode,
          status: "SUCCESS",
        },
      });

      synced++;
    } catch (error) {
      await prisma.syncLog.create({
        data: {
          sheetName: "Revenue",
          action: "SYNC",
          rowIndex: row.rowIndex,
          status: "FAILED",
          errorMessage: error instanceof Error ? error.message : "Unknown error",
        },
      });
      errors++;
    }
  }

  return { synced, errors };
}

/**
 * POST - Trigger sync for a sheet
 */
export async function POST(request: NextRequest) {
  try {
    // Auth check - ADMIN only
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    if (!hasPermission(session.user.role as Role, "*")) {
      return NextResponse.json(
        { success: false, error: "Admin only" },
        { status: 403 }
      );
    }

    // Check if Google Sheets is configured
    if (!isGoogleSheetsConfigured()) {
      return NextResponse.json(
        {
          success: false,
          error:
            "Google Sheets not configured. Set GOOGLE_SERVICE_ACCOUNT_EMAIL, GOOGLE_PRIVATE_KEY, and SHEET_ID_* or GOOGLE_SHEET_ID",
        },
        { status: 400 }
      );
    }

    const body = await request.json();
    const sheetName = body.sheetName as SheetName;

    if (!VALID_SHEETS.includes(sheetName)) {
      return NextResponse.json(
        { success: false, error: `Invalid sheet. Use: ${VALID_SHEETS.join(", ")}` },
        { status: 400 }
      );
    }

    // Check if this specific sheet is configured
    const sheetConfig = getSheetConfigStatus();
    if (!sheetConfig[sheetName]) {
      return NextResponse.json(
        {
          success: false,
          error: `No spreadsheet ID for ${sheetName}. Set SHEET_ID_${sheetName.toUpperCase()} or GOOGLE_SHEET_ID`,
        },
        { status: 400 }
      );
    }

    logInfo("api/sync/sheets", `Starting sync for ${sheetName}`, {
      userId: session.user.id,
    });

    // Get last synced row
    const lastRow = await getLastSyncedRow(sheetName);

    // Fetch new rows from sheet (starting after last synced)
    const rows = await getSheetData(sheetName, lastRow + 1);

    if (rows.length === 0) {
      return NextResponse.json({
        success: true,
        message: "No new rows to sync",
        synced: 0,
        errors: 0,
      } satisfies SyncResult);
    }

    // Sync based on sheet type
    let result: { synced: number; errors: number };

    switch (sheetName) {
      case "Request":
        result = await syncRequestSheet(rows);
        break;
      case "Operator":
        result = await syncOperatorSheet(rows);
        break;
      case "Revenue":
        result = await syncRevenueSheet(rows);
        break;
    }

    const lastRowIndex = rows[rows.length - 1]?.rowIndex;

    logInfo("api/sync/sheets", `Sync completed for ${sheetName}`, {
      synced: result.synced,
      errors: result.errors,
      lastRowIndex,
    });

    return NextResponse.json({
      success: true,
      message: `Synced ${result.synced} rows, ${result.errors} errors`,
      synced: result.synced,
      errors: result.errors,
      lastRowIndex,
    } satisfies SyncResult);
  } catch (error) {
    logError("api/sync/sheets", error);
    return NextResponse.json(
      { success: false, error: "Sync failed. Check server logs." },
      { status: 500 }
    );
  }
}

/**
 * GET - Get sync status and statistics
 */
export async function GET() {
  try {
    // Auth check
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: "Unauthorized" },
        { status: 401 }
      );
    }

    // Get stats grouped by sheet and status
    const stats = await prisma.syncLog.groupBy({
      by: ["sheetName", "status"],
      _count: true,
      orderBy: { sheetName: "asc" },
    });

    // Get last sync per sheet
    const lastSyncs = await Promise.all(
      VALID_SHEETS.map(async (sheetName) => {
        const last = await prisma.syncLog.findFirst({
          where: { sheetName, status: "SUCCESS" },
          orderBy: { syncedAt: "desc" },
        });
        return { sheetName, lastSync: last?.syncedAt, lastRow: last?.rowIndex };
      })
    );

    // Check configuration (overall and per-sheet)
    const configured = isGoogleSheetsConfigured();
    const sheetConfig = getSheetConfigStatus();

    return NextResponse.json({
      success: true,
      data: {
        configured,
        sheetConfig,
        stats,
        lastSyncs,
      },
    });
  } catch (error) {
    logError("api/sync/sheets", error);
    return NextResponse.json(
      { success: false, error: "Failed to get sync status" },
      { status: 500 }
    );
  }
}
</file>

<file path="src/components/revenues/index.ts">
export { RevenueForm } from './revenue-form';
export { RevenueTable } from './revenue-table';
export { RevenueSummaryCard } from './revenue-summary-card';
export { RevenueHistoryPanel } from './revenue-history-panel';
export { RevenueLockDialog } from './revenue-lock-dialog';
export { SalesSummaryTable } from './sales-summary-table';
</file>

<file path="src/components/revenues/revenue-table.tsx">
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from '@/components/ui/sheet';
import { Edit, Trash2, Lock, Unlock, MoreHorizontal, History } from 'lucide-react';
import { formatDate, formatCurrency } from '@/lib/utils';
import { toast } from 'sonner';
import { usePermission } from '@/hooks/use-permission';
import { LockTierBadgeCompact } from '@/components/shared/lock-tier-badge';
import { RevenueLockDialog } from './revenue-lock-dialog';
import { RevenueHistoryPanel } from './revenue-history-panel';
import { LOCK_TIER_LABELS } from '@/config/lock-config';
import type { LockTier } from '@/lib/lock-utils';

// Payment type labels
const PAYMENT_TYPE_LABELS: Record<string, string> = {
  DEPOSIT: 'Dat coc',
  FULL_PAYMENT: 'Thanh toan du',
  PARTIAL: 'Mot phan',
  REFUND: 'Hoan tien',
};

const PAYMENT_SOURCE_LABELS: Record<string, string> = {
  BANK_TRANSFER: 'Chuyen khoan',
  CASH: 'Tien mat',
  CARD: 'The tin dung',
  PAYPAL: 'PayPal',
  WISE: 'Wise',
  OTHER: 'Khac',
};

interface Revenue {
  id: string;
  paymentDate: Date | string;
  paymentType: string;
  foreignAmount?: number | null;
  currency?: string | null;
  exchangeRate?: number | null;
  amountVND: number;
  paymentSource: string;
  notes?: string | null;
  // 3-tier lock fields
  lockKT: boolean;
  lockAdmin: boolean;
  lockFinal: boolean;
  // Legacy field for backward compatibility
  isLocked?: boolean;
  lockedAt?: Date | string | null;
  lockedBy?: string | null;
  request?: {
    code: string;
    customerName: string;
    bookingCode?: string | null;
  };
}

interface RevenueTableProps {
  revenues: Revenue[];
  showRequest?: boolean;
  onEdit?: (revenue: Revenue) => void;
  onRefresh?: () => void;
  canManage?: boolean;
  canUnlock?: boolean;
}

export function RevenueTable({
  revenues,
  showRequest = false,
  onEdit,
  onRefresh,
  canManage = true,
  canUnlock = false,
}: RevenueTableProps) {
  const { isAdmin, isAccountant } = usePermission();
  const [deleting, setDeleting] = useState<string | null>(null);

  const handleDelete = async (id: string) => {
    setDeleting(id);
    try {
      const res = await fetch(`/api/revenues/${id}`, { method: 'DELETE' });
      const data = await res.json();

      if (data.success) {
        toast.success('Da xoa thu nhap');
        onRefresh?.();
      } else {
        toast.error(data.error || 'Loi xoa thu nhap');
      }
    } catch {
      toast.error('Loi ket noi');
    } finally {
      setDeleting(null);
    }
  };

  if (revenues.length === 0) {
    return (
      <div className="text-center py-8 text-muted-foreground">
        Chua co thu nhap nao
      </div>
    );
  }

  // Check if user can lock (ACCOUNTANT or ADMIN)
  const canLock = isAccountant || isAdmin;

  return (
    <Table>
      <TableHeader>
        <TableRow>
          {showRequest && <TableHead>Booking</TableHead>}
          <TableHead>Ngay</TableHead>
          <TableHead>Loai</TableHead>
          <TableHead>Nguon</TableHead>
          <TableHead className="text-right">So tien</TableHead>
          <TableHead>Khoa</TableHead>
          {canManage && <TableHead className="text-right">Thao tac</TableHead>}
        </TableRow>
      </TableHeader>
      <TableBody>
        {revenues.map((revenue) => (
          <RevenueRow
            key={revenue.id}
            revenue={revenue}
            showRequest={showRequest}
            onEdit={onEdit}
            onRefresh={onRefresh}
            canManage={canManage}
            canLock={canLock}
            canUnlock={canUnlock || isAdmin}
            deleting={deleting}
            onDelete={handleDelete}
          />
        ))}
      </TableBody>
    </Table>
  );
}

interface RevenueRowProps {
  revenue: Revenue;
  showRequest: boolean;
  onEdit?: (revenue: Revenue) => void;
  onRefresh?: () => void;
  canManage: boolean;
  canLock: boolean;
  canUnlock: boolean;
  deleting: string | null;
  onDelete: (id: string) => void;
}

function RevenueRow({
  revenue,
  showRequest,
  onEdit,
  onRefresh,
  canManage,
  canLock,
  canUnlock,
  deleting,
  onDelete,
}: RevenueRowProps) {
  const [lockDialogOpen, setLockDialogOpen] = useState(false);
  const [historyOpen, setHistoryOpen] = useState(false);
  const [unlocking, setUnlocking] = useState(false);

  // Check lock state - support both new 3-tier and legacy fields
  const lockKT = revenue.lockKT ?? revenue.isLocked ?? false;
  const lockAdmin = revenue.lockAdmin ?? false;
  const lockFinal = revenue.lockFinal ?? false;

  // Check if any lock is applied
  const isLocked = lockKT || lockAdmin || lockFinal;
  const isFullyLocked = lockFinal;

  // Determine if more tiers can be locked
  const canLockMore = !lockFinal;

  // Determine next tier that can be unlocked (reverse order)
  const nextUnlockTier: LockTier | null = lockFinal
    ? 'Final'
    : lockAdmin
    ? 'Admin'
    : lockKT
    ? 'KT'
    : null;

  const handleUnlock = async () => {
    if (!nextUnlockTier) return;

    setUnlocking(true);
    try {
      const res = await fetch(`/api/revenues/${revenue.id}/unlock`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ tier: nextUnlockTier }),
      });

      if (!res.ok) {
        const data = await res.json();
        throw new Error(data.error || 'Mo khoa that bai');
      }

      toast.success(`Da mo khoa ${LOCK_TIER_LABELS[nextUnlockTier]}`);
      onRefresh?.();
    } catch (error) {
      toast.error(error instanceof Error ? error.message : 'Loi mo khoa');
    } finally {
      setUnlocking(false);
    }
  };

  return (
    <TableRow>
      {showRequest && (
        <TableCell className="font-mono text-sm">
          {revenue.request?.bookingCode || revenue.request?.code}
        </TableCell>
      )}
      <TableCell>{formatDate(revenue.paymentDate)}</TableCell>
      <TableCell>
        <Badge variant="outline">
          {PAYMENT_TYPE_LABELS[revenue.paymentType] || revenue.paymentType}
        </Badge>
      </TableCell>
      <TableCell>
        {PAYMENT_SOURCE_LABELS[revenue.paymentSource] || revenue.paymentSource}
      </TableCell>
      <TableCell className="text-right font-mono">
        {revenue.currency && revenue.currency !== 'VND' && (
          <span className="text-muted-foreground text-xs block">
            {formatCurrency(Number(revenue.foreignAmount))} {revenue.currency}
          </span>
        )}
        <span className="font-medium">
          {formatCurrency(Number(revenue.amountVND))} d
        </span>
      </TableCell>
      <TableCell>
        <LockTierBadgeCompact
          lockKT={lockKT}
          lockAdmin={lockAdmin}
          lockFinal={lockFinal}
        />
      </TableCell>
      {canManage && (
        <TableCell className="text-right">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="h-8 w-8 p-0">
                <MoreHorizontal className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {/* Edit - disabled if any lock */}
              <DropdownMenuItem
                disabled={isLocked}
                onClick={() => onEdit?.(revenue)}
              >
                <Edit className="mr-2 h-4 w-4" />
                Chinh sua
              </DropdownMenuItem>

              {/* Lock - if can lock more tiers */}
              {canLock && canLockMore && (
                <DropdownMenuItem onClick={() => setLockDialogOpen(true)}>
                  <Lock className="mr-2 h-4 w-4" />
                  Khoa
                </DropdownMenuItem>
              )}

              {/* Unlock - if locked and has permission */}
              {canUnlock && nextUnlockTier && (
                <DropdownMenuItem onClick={handleUnlock} disabled={unlocking}>
                  <Unlock className="mr-2 h-4 w-4" />
                  Mo khoa {LOCK_TIER_LABELS[nextUnlockTier]}
                </DropdownMenuItem>
              )}

              <DropdownMenuSeparator />

              {/* History */}
              <DropdownMenuItem onClick={() => setHistoryOpen(true)}>
                <History className="mr-2 h-4 w-4" />
                Lich su
              </DropdownMenuItem>

              {/* Delete - disabled if any lock */}
              {!isLocked && (
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <DropdownMenuItem
                      onSelect={(e) => e.preventDefault()}
                      className="text-destructive"
                    >
                      <Trash2 className="mr-2 h-4 w-4" />
                      Xoa
                    </DropdownMenuItem>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Xac nhan xoa</AlertDialogTitle>
                      <AlertDialogDescription>
                        Ban co chac muon xoa thu nhap nay? Thao tac khong the hoan tac.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel>Huy</AlertDialogCancel>
                      <AlertDialogAction
                        onClick={() => onDelete(revenue.id)}
                        disabled={deleting === revenue.id}
                        className="bg-red-600 hover:bg-red-700"
                      >
                        {deleting === revenue.id ? 'Dang xoa...' : 'Xoa'}
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              )}
            </DropdownMenuContent>
          </DropdownMenu>

          {/* Lock Dialog */}
          <RevenueLockDialog
            open={lockDialogOpen}
            onOpenChange={setLockDialogOpen}
            revenueId={revenue.id}
            currentState={{ lockKT, lockAdmin, lockFinal }}
            onSuccess={() => onRefresh?.()}
          />

          {/* History Sheet */}
          <Sheet open={historyOpen} onOpenChange={setHistoryOpen}>
            <SheetContent>
              <SheetHeader>
                <SheetTitle>Lich su thay doi</SheetTitle>
              </SheetHeader>
              <RevenueHistoryPanel revenueId={revenue.id} />
            </SheetContent>
          </Sheet>
        </TableCell>
      )}
    </TableRow>
  );
}
</file>

<file path="src/components/settings/index.ts">
export { SellerTable } from './seller-table';
export { SellerFormModal } from './seller-form-modal';
export { FollowUpStatusTable } from './followup-status-table';
export { FollowUpStatusFormModal } from './followup-status-form-modal';
export { GoogleSheetsSync } from './google-sheets-sync';
</file>

<file path="src/lib/validations/request-validation.ts">
import { z } from 'zod';
import {
  REQUEST_STATUS_KEYS,
  REQUEST_STAGE_KEYS,
  type RequestStatus,
  type RequestStage,
} from '@/config/request-config';

// ============================================
// Request Form Validation Schema
// Vietnamese error messages for user-facing forms
// ============================================

// Status enum from config (type-safe)
const requestStatusEnum = z.enum(REQUEST_STATUS_KEYS as [RequestStatus, ...RequestStatus[]], {
  message: 'Trạng thái không hợp lệ',
});

// Stage enum from config (type-safe)
const requestStageEnum = z.enum(REQUEST_STAGE_KEYS as [RequestStage, ...RequestStage[]], {
  message: 'Giai đoạn không hợp lệ',
});

// Phone regex: international format or Vietnamese format
const phoneRegex = /^(\+?[0-9]{8,15}|0[0-9]{9,10})$/;

// Base object schema for request form data (without refinements)
const requestFormBaseSchema = z.object({
  // Required fields
  customerName: z
    .string()
    .min(2, 'Tên khách hàng phải có ít nhất 2 ký tự')
    .max(100, 'Tên khách hàng không được quá 100 ký tự')
    .transform((val) => val.trim()),

  contact: z
    .string()
    .min(1, 'Thông tin liên hệ không được trống')
    .max(255, 'Thông tin liên hệ không được quá 255 ký tự')
    .transform((val) => val.trim()),

  country: z
    .string()
    .min(1, 'Quốc gia không được trống')
    .max(100, 'Quốc gia không được quá 100 ký tự')
    .transform((val) => val.trim()),

  source: z
    .string()
    .min(1, 'Nguồn không được trống')
    .max(100, 'Nguồn không được quá 100 ký tự')
    .transform((val) => val.trim()),

  pax: z
    .number({ message: 'Số khách phải là số' })
    .int('Số khách phải là số nguyên')
    .min(1, 'Số khách phải ít nhất 1')
    .max(100, 'Số khách không được quá 100'),

  status: requestStatusEnum,

  // Optional fields
  whatsapp: z
    .string()
    .regex(phoneRegex, 'Số WhatsApp không hợp lệ (8-15 số)')
    .optional()
    .nullable()
    .or(z.literal('')),

  stage: requestStageEnum.optional(),

  tourDays: z
    .number({ message: 'Số ngày tour phải là số' })
    .int('Số ngày tour phải là số nguyên')
    .min(1, 'Số ngày tour phải ít nhất 1')
    .max(365, 'Số ngày tour không được quá 365')
    .optional()
    .nullable(),

  startDate: z
    .string()
    .datetime({ message: 'Ngày bắt đầu không hợp lệ' })
    .optional()
    .nullable()
    .or(z.literal('')),

  endDate: z
    .string()
    .datetime({ message: 'Ngày kết thúc không hợp lệ' })
    .optional()
    .nullable()
    .or(z.literal('')),

  expectedDate: z
    .string()
    .datetime({ message: 'Ngày dự kiến không hợp lệ' })
    .optional()
    .nullable()
    .or(z.literal('')),

  expectedRevenue: z
    .number({ message: 'Doanh thu dự kiến phải là số' })
    .min(0, 'Doanh thu dự kiến không được âm')
    .optional()
    .nullable(),

  expectedCost: z
    .number({ message: 'Chi phí dự kiến phải là số' })
    .min(0, 'Chi phí dự kiến không được âm')
    .optional()
    .nullable(),

  lastContactDate: z
    .string()
    .datetime({ message: 'Ngày liên hệ cuối không hợp lệ' })
    .optional()
    .nullable()
    .or(z.literal('')),

  notes: z
    .string()
    .max(1000, 'Ghi chú không được quá 1000 ký tự')
    .optional()
    .nullable()
    .or(z.literal('')),

  // Seller assignment (for ADMIN creating on behalf)
  sellerId: z.string().uuid('ID seller không hợp lệ').optional().nullable(),
});

// Full form schema with refinements (for create)
export const requestFormSchema = requestFormBaseSchema.refine(
  (data) => {
    // If both startDate and endDate are provided, endDate must be >= startDate
    if (data.startDate && data.endDate) {
      return new Date(data.endDate) >= new Date(data.startDate);
    }
    return true;
  },
  {
    message: 'Ngày kết thúc phải sau hoặc bằng ngày bắt đầu',
    path: ['endDate'],
  }
);

// Schema for creating new request (stricter - requires status)
export const createRequestSchema = requestFormSchema;

// Schema for updating request (all fields optional - use base schema to allow partial)
export const updateRequestSchema = requestFormBaseSchema.partial().extend({
  id: z.string().uuid('ID yêu cầu không hợp lệ'),
});

// Schema for request filters (search/list page)
export const requestFiltersSchema = z.object({
  search: z.string().optional(),
  sellerId: z.string().uuid().optional().nullable(),
  status: requestStatusEnum.optional(),
  stage: requestStageEnum.optional(),
  source: z.string().optional(),
  country: z.string().optional(),
  fromDate: z.string().datetime().optional().nullable(),
  toDate: z.string().datetime().optional().nullable(),
  followup: z.enum(['overdue', 'today', 'upcoming']).optional(),
  limit: z.number().int().min(1).max(100).optional().default(50),
  offset: z.number().int().min(0).optional().default(0),
});

// ============================================
// Type Exports
// ============================================

export type RequestFormData = z.infer<typeof requestFormSchema>;
export type CreateRequestData = z.infer<typeof createRequestSchema>;
export type UpdateRequestData = z.infer<typeof updateRequestSchema>;
export type RequestFilters = z.infer<typeof requestFiltersSchema>;

// Error type for form validation
export interface RequestFormErrors {
  customerName?: string;
  contact?: string;
  whatsapp?: string;
  pax?: string;
  country?: string;
  source?: string;
  status?: string;
  stage?: string;
  tourDays?: string;
  startDate?: string;
  endDate?: string;
  expectedDate?: string;
  expectedRevenue?: string;
  expectedCost?: string;
  lastContactDate?: string;
  notes?: string;
  sellerId?: string;
  _form?: string; // General form error
}

// ============================================
// Validation Functions
// ============================================

/**
 * Validate request form data
 * @param data - Form data to validate
 * @returns Object with success status, validated data or errors
 */
export function validateRequestForm(data: unknown): {
  success: boolean;
  data?: RequestFormData;
  errors?: RequestFormErrors;
} {
  const result = requestFormSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  // Transform Zod errors to field-level errors
  const errors: RequestFormErrors = {};
  for (const issue of result.error.issues) {
    const field = issue.path[0] as keyof RequestFormErrors;
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }

  return { success: false, errors };
}

/**
 * Validate create request data
 * @param data - Data to validate for creating new request
 */
export function validateCreateRequest(data: unknown): {
  success: boolean;
  data?: CreateRequestData;
  errors?: RequestFormErrors;
} {
  const result = createRequestSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  const errors: RequestFormErrors = {};
  for (const issue of result.error.issues) {
    const field = issue.path[0] as keyof RequestFormErrors;
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }

  return { success: false, errors };
}

/**
 * Validate update request data
 * @param data - Data to validate for updating request
 */
export function validateUpdateRequest(data: unknown): {
  success: boolean;
  data?: UpdateRequestData;
  errors?: RequestFormErrors & { id?: string };
} {
  const result = updateRequestSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  const errors: RequestFormErrors & { id?: string } = {};
  for (const issue of result.error.issues) {
    const field = issue.path[0] as keyof (RequestFormErrors & { id?: string });
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }

  return { success: false, errors };
}

/**
 * Validate request filters
 * @param params - Filter parameters from URL or form
 */
export function validateRequestFilters(params: unknown): {
  success: boolean;
  data?: RequestFilters;
  errors?: Record<string, string>;
} {
  const result = requestFiltersSchema.safeParse(params);

  if (result.success) {
    return { success: true, data: result.data };
  }

  const errors: Record<string, string> = {};
  for (const issue of result.error.issues) {
    const field = issue.path[0] as string;
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }

  return { success: false, errors };
}

// ============================================
// Transform Helpers
// ============================================

/**
 * Transform form data - convert empty strings to null
 * Use before API submission
 */
export function transformRequestFormData(data: RequestFormData) {
  return {
    ...data,
    whatsapp: data.whatsapp || null,
    startDate: data.startDate || null,
    endDate: data.endDate || null,
    expectedDate: data.expectedDate || null,
    lastContactDate: data.lastContactDate || null,
    notes: data.notes || null,
    sellerId: data.sellerId || null,
    tourDays: data.tourDays ?? null,
    expectedRevenue: data.expectedRevenue ?? null,
    expectedCost: data.expectedCost ?? null,
  };
}

/**
 * Parse numeric input from form (handles empty string, NaN)
 * @param value - Input value from form
 * @param defaultValue - Default if parsing fails (null for optional fields)
 */
export function parseNumericInput(
  value: string | number | undefined | null,
  defaultValue: number | null = null
): number | null {
  if (value === undefined || value === null || value === '') {
    return defaultValue;
  }
  const parsed = typeof value === 'number' ? value : parseFloat(value);
  return isNaN(parsed) ? defaultValue : parsed;
}

/**
 * Parse integer input from form
 */
export function parseIntegerInput(
  value: string | number | undefined | null,
  defaultValue: number | null = null
): number | null {
  if (value === undefined || value === null || value === '') {
    return defaultValue;
  }
  const parsed = typeof value === 'number' ? Math.floor(value) : parseInt(value, 10);
  return isNaN(parsed) ? defaultValue : parsed;
}

// ============================================
// API Schema (for server-side validation)
// Dates as strings (ISO or YYYY-MM-DD), looser than form schema
// ============================================

// Date string validator - accepts ISO, YYYY-MM-DD, or empty
const dateStringOptional = z
  .string()
  .refine((val) => !val || !isNaN(Date.parse(val)), { message: 'Ngày không hợp lệ' })
  .optional()
  .nullable();

// API Create Request Schema
export const createRequestApiSchema = z.object({
  customerName: z
    .string({ message: 'Tên khách hàng là bắt buộc' })
    .min(2, 'Tên khách hàng phải có ít nhất 2 ký tự')
    .max(100, 'Tên khách hàng không được quá 100 ký tự'),

  contact: z
    .string({ message: 'Thông tin liên hệ là bắt buộc' })
    .min(1, 'Thông tin liên hệ không được trống')
    .max(255, 'Thông tin liên hệ không được quá 255 ký tự'),

  country: z
    .string({ message: 'Quốc gia là bắt buộc' })
    .min(1, 'Quốc gia không được trống')
    .max(100, 'Quốc gia không được quá 100 ký tự'),

  source: z
    .string({ message: 'Nguồn là bắt buộc' })
    .min(1, 'Nguồn không được trống')
    .max(100, 'Nguồn không được quá 100 ký tự'),

  status: requestStatusEnum.optional().default('DANG_LL_CHUA_TL'),

  whatsapp: z.string().max(50).optional().nullable(),
  pax: z.number().int().min(1).max(100).optional().default(1),
  tourDays: z.number().int().min(1).max(365).optional().nullable(),
  startDate: dateStringOptional,
  expectedDate: dateStringOptional,
  expectedRevenue: z.number().min(0).optional().nullable(),
  expectedCost: z.number().min(0).optional().nullable(),
  lastContactDate: dateStringOptional,
  notes: z.string().max(1000).optional().nullable(),
  sellerId: z.string().uuid().optional().nullable(),
});

// API Update Request Schema (all fields optional)
export const updateRequestApiSchema = createRequestApiSchema.partial().extend({
  // Additional fields for updates
  statusChangedBy: z.string().optional(),
  nextFollowUp: dateStringOptional,
});

export type CreateRequestApiData = z.infer<typeof createRequestApiSchema>;
export type UpdateRequestApiData = z.infer<typeof updateRequestApiSchema>;

/**
 * Extract field errors from Zod error for API response
 */
export function extractZodErrors(error: z.ZodError): Record<string, string> {
  const errors: Record<string, string> = {};
  for (const issue of error.issues) {
    const field = issue.path.join('.');
    if (field && !errors[field]) {
      errors[field] = issue.message;
    }
  }
  return errors;
}
</file>

<file path="src/__tests__/api/operator-lock.test.ts">
/**
 * @jest-environment node
 */

// Tests for Operator Lock API routes (3-tier lock system)
// Covers: GET/POST /api/operators/lock-period, POST /api/operators/[id]/lock, POST /api/operators/[id]/unlock
// Lock tiers: KT (Accountant) → Admin → Final (sequential progression)

import { NextRequest } from 'next/server';
import { prismaMock } from '@/lib/__mocks__/db';

// Mock the db module
jest.mock('@/lib/db', () => ({
  prisma: prismaMock,
}));

// Mock auth-utils to avoid next-auth ESM import issues
jest.mock('@/lib/auth-utils');

// Mock operator history
jest.mock('@/lib/operator-history', () => ({
  createOperatorHistory: jest.fn().mockResolvedValue({}),
}));

import { GET as getLockStatus, POST as lockPeriod } from '@/app/api/operators/lock-period/route';
import { POST as lockSingle } from '@/app/api/operators/[id]/lock/route';
import { POST as unlockSingle } from '@/app/api/operators/[id]/unlock/route';

// Helper to create mock NextRequest
function createMockRequest(url: string, options?: { method?: string; body?: string }): NextRequest {
  return new NextRequest(new URL(url, 'http://localhost:3000'), options as never);
}

describe('GET /api/operators/lock-period', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should return tier breakdown for a month', async () => {
    // New API returns tier breakdown: total, tiers.KT, tiers.Admin, tiers.Final, unlocked
    prismaMock.operator.count
      .mockResolvedValueOnce(10 as never) // total
      .mockResolvedValueOnce(7 as never)  // lockedKT
      .mockResolvedValueOnce(5 as never)  // lockedAdmin
      .mockResolvedValueOnce(3 as never)  // lockedFinal
      .mockResolvedValueOnce(3 as never); // unlocked (not locked at KT)

    const request = createMockRequest('http://localhost:3000/api/operators/lock-period?month=2026-01');
    const response = await getLockStatus(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.month).toBe('2026-01');
    expect(data.data.total).toBe(10);
    expect(data.data.tiers.KT).toBe(7);
    expect(data.data.tiers.Admin).toBe(5);
    expect(data.data.tiers.Final).toBe(3);
    expect(data.data.unlocked).toBe(3);
    expect(data.data.isFullyLocked).toBe(false); // Not all at Final tier
  });

  it('should return isFullyLocked=true when all at Final tier', async () => {
    prismaMock.operator.count
      .mockResolvedValueOnce(5 as never)  // total
      .mockResolvedValueOnce(5 as never)  // lockedKT
      .mockResolvedValueOnce(5 as never)  // lockedAdmin
      .mockResolvedValueOnce(5 as never)  // lockedFinal (all at final)
      .mockResolvedValueOnce(0 as never); // unlocked

    const request = createMockRequest('http://localhost:3000/api/operators/lock-period?month=2026-01');
    const response = await getLockStatus(request);
    const data = await response.json();

    expect(data.data.isFullyLocked).toBe(true);
  });

  it('should return operators eligible for specific tier', async () => {
    const mockOperators = [
      { id: 'op-1', serviceName: 'Hotel', serviceDate: new Date(), totalCost: 1000000, lockKT: false, lockAdmin: false, lockFinal: false },
    ];
    prismaMock.operator.findMany.mockResolvedValue(mockOperators as never);

    const request = createMockRequest('http://localhost:3000/api/operators/lock-period?month=2026-01&tier=KT');
    const response = await getLockStatus(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.data.tier).toBe('KT');
    expect(data.data.count).toBe(1);
    expect(data.data.operators).toHaveLength(1);
  });

  it('should return 400 for invalid month format', async () => {
    const request = createMockRequest('http://localhost:3000/api/operators/lock-period?month=invalid');
    const response = await getLockStatus(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });

  it('should return 400 when month is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/operators/lock-period');
    const response = await getLockStatus(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });
});

describe('POST /api/operators/lock-period', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should lock operators at KT tier (default)', async () => {
    prismaMock.operator.findMany.mockResolvedValue([
      { id: 'op-1' },
      { id: 'op-2' },
    ] as never);

    (prismaMock.$transaction as jest.Mock).mockImplementation(async (fn: (tx: unknown) => Promise<unknown>) => {
      if (typeof fn === 'function') {
        return fn({
          operator: {
            updateMany: jest.fn().mockResolvedValue({ count: 2 }),
          },
          operatorHistory: {
            createMany: jest.fn().mockResolvedValue({ count: 2 }),
          },
        });
      }
    });

    const request = createMockRequest('http://localhost:3000/api/operators/lock-period', {
      method: 'POST',
      body: JSON.stringify({ month: '2026-01' }), // tier defaults to 'KT'
    });

    const response = await lockPeriod(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.count).toBe(2);
    expect(data.data.tier).toBe('KT');
    expect(data.data.period).toBe('2026-01');
  });

  it('should lock operators at Admin tier', async () => {
    prismaMock.operator.findMany.mockResolvedValue([
      { id: 'op-1' },
    ] as never);

    (prismaMock.$transaction as jest.Mock).mockImplementation(async (fn: (tx: unknown) => Promise<unknown>) => {
      if (typeof fn === 'function') {
        return fn({
          operator: {
            updateMany: jest.fn().mockResolvedValue({ count: 1 }),
          },
          operatorHistory: {
            createMany: jest.fn().mockResolvedValue({ count: 1 }),
          },
        });
      }
    });

    const request = createMockRequest('http://localhost:3000/api/operators/lock-period', {
      method: 'POST',
      body: JSON.stringify({ month: '2026-01', tier: 'Admin' }),
    });

    const response = await lockPeriod(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.tier).toBe('Admin');
  });

  it('should return count=0 when no operators to lock', async () => {
    prismaMock.operator.findMany.mockResolvedValue([] as never);

    const request = createMockRequest('http://localhost:3000/api/operators/lock-period', {
      method: 'POST',
      body: JSON.stringify({ month: '2025-12' }),
    });

    const response = await lockPeriod(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.count).toBe(0);
  });

  it('should return 400 for invalid month format', async () => {
    const request = createMockRequest('http://localhost:3000/api/operators/lock-period', {
      method: 'POST',
      body: JSON.stringify({ month: '2026-1' }),
    });

    const response = await lockPeriod(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });

  it('should return 400 when month is missing', async () => {
    const request = createMockRequest('http://localhost:3000/api/operators/lock-period', {
      method: 'POST',
      body: JSON.stringify({}),
    });

    const response = await lockPeriod(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });

  it('should return 400 for invalid tier', async () => {
    const request = createMockRequest('http://localhost:3000/api/operators/lock-period', {
      method: 'POST',
      body: JSON.stringify({ month: '2026-01', tier: 'Invalid' }),
    });

    const response = await lockPeriod(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });
});

describe('POST /api/operators/[id]/lock', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Mock operator with 3-tier lock fields (all unlocked)
  const mockOperator = {
    id: 'op-1',
    serviceName: 'Hotel Room',
    lockKT: false,
    lockAdmin: false,
    lockFinal: false,
  };

  const mockParams = Promise.resolve({ id: 'op-1' });

  it('should lock at KT tier successfully', async () => {
    prismaMock.operator.findUnique.mockResolvedValue(mockOperator as never);
    prismaMock.operator.update.mockResolvedValue({
      ...mockOperator,
      lockKT: true,
      lockKTAt: new Date(),
      lockKTBy: 'user-1',
      isLocked: true,
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/lock', {
      method: 'POST',
      body: JSON.stringify({ tier: 'KT' }),
    });

    const response = await lockSingle(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.tier).toBe('KT');
  });

  it('should return 404 when operator not found', async () => {
    prismaMock.operator.findUnique.mockResolvedValue(null);

    const request = createMockRequest('http://localhost:3000/api/operators/op-999/lock', {
      method: 'POST',
      body: JSON.stringify({ tier: 'KT' }),
    });

    const response = await lockSingle(request, { params: Promise.resolve({ id: 'op-999' }) });
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.success).toBe(false);
  });

  it('should return 400 when tier already locked', async () => {
    prismaMock.operator.findUnique.mockResolvedValue({
      ...mockOperator,
      lockKT: true, // Already locked at KT
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/lock', {
      method: 'POST',
      body: JSON.stringify({ tier: 'KT' }),
    });

    const response = await lockSingle(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });

  it('should return 400 when trying to skip tier progression', async () => {
    // Trying to lock Admin without KT locked first
    prismaMock.operator.findUnique.mockResolvedValue({
      ...mockOperator,
      lockKT: false, // KT not locked
      lockAdmin: false,
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/lock', {
      method: 'POST',
      body: JSON.stringify({ tier: 'Admin' }),
    });

    const response = await lockSingle(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });
});

describe('POST /api/operators/[id]/unlock', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // Mock operator locked at KT tier
  const mockOperatorKTLocked = {
    id: 'op-1',
    serviceName: 'Hotel Room',
    lockKT: true,
    lockAdmin: false,
    lockFinal: false,
  };

  const mockParams = Promise.resolve({ id: 'op-1' });

  it('should unlock KT tier successfully', async () => {
    prismaMock.operator.findUnique.mockResolvedValue(mockOperatorKTLocked as never);
    prismaMock.operator.update.mockResolvedValue({
      ...mockOperatorKTLocked,
      lockKT: false,
      lockKTAt: null,
      lockKTBy: null,
      isLocked: false,
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/unlock', {
      method: 'POST',
      body: JSON.stringify({ tier: 'KT' }),
    });

    const response = await unlockSingle(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.tier).toBe('KT');
  });

  it('should return 404 when operator not found', async () => {
    prismaMock.operator.findUnique.mockResolvedValue(null);

    const request = createMockRequest('http://localhost:3000/api/operators/op-999/unlock', {
      method: 'POST',
      body: JSON.stringify({ tier: 'KT' }),
    });

    const response = await unlockSingle(request, { params: Promise.resolve({ id: 'op-999' }) });
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.success).toBe(false);
  });

  it('should return 400 when tier not locked', async () => {
    prismaMock.operator.findUnique.mockResolvedValue({
      id: 'op-1',
      serviceName: 'Hotel Room',
      lockKT: false, // Not locked
      lockAdmin: false,
      lockFinal: false,
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/unlock', {
      method: 'POST',
      body: JSON.stringify({ tier: 'KT' }),
    });

    const response = await unlockSingle(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });

  it('should return 400 when trying to unlock out of order', async () => {
    // Trying to unlock KT when Admin is still locked (wrong order)
    prismaMock.operator.findUnique.mockResolvedValue({
      id: 'op-1',
      serviceName: 'Hotel Room',
      lockKT: true,
      lockAdmin: true, // Admin locked - must unlock this first
      lockFinal: false,
    } as never);

    const request = createMockRequest('http://localhost:3000/api/operators/op-1/unlock', {
      method: 'POST',
      body: JSON.stringify({ tier: 'KT' }),
    });

    const response = await unlockSingle(request, { params: mockParams });
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.success).toBe(false);
  });
});

describe('Lock protection in existing APIs', () => {
  // These tests verify that existing APIs properly reject operations on locked operators
  // The actual implementation is already in [id]/route.ts (PUT/DELETE check isLocked)

  it('PUT should reject editing locked operator', async () => {
    // This is already tested via the existing API - confirming the pattern
    // The [id]/route.ts already checks: if (existing.isLocked) return 403
    expect(true).toBe(true);
  });

  it('DELETE should reject deleting locked operator', async () => {
    // This is already tested via the existing API - confirming the pattern
    // The [id]/route.ts already checks: if (existing.isLocked) return 403
    expect(true).toBe(true);
  });

  it('APPROVE should reject approving locked operator', async () => {
    // This is already tested in operator-approvals.test.ts
    // The [id]/approve/route.ts already checks: if (operator.isLocked) return 403
    expect(true).toBe(true);
  });
});
</file>

<file path="src/app/(dashboard)/operators/page.tsx">
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import Link from 'next/link';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Plus, ClipboardList, Lock, RefreshCw, Archive, ArchiveRestore, BarChart3 } from 'lucide-react';
import { OperatorListFilters } from '@/components/operators/operator-list-filters';
import { OperatorLockDialog } from '@/components/operators/operator-lock-dialog';
import { SERVICE_TYPES, PAYMENT_STATUSES, type ServiceTypeKey, type PaymentStatusKey } from '@/config/operator-config';
import { safeFetch, safePost } from '@/lib/api/fetch-utils';
import { ErrorFallback } from '@/components/ui/error-fallback';
import { toast } from 'sonner';
import type { OperatorFilters } from '@/types';

interface OperatorListItem {
  id: string;
  requestId: string;
  supplierId: string | null;
  serviceDate: string | Date;
  serviceType: string;
  serviceName: string;
  supplier: string | null;
  totalCost: number;
  paidAmount: number;
  paymentStatus: string;
  isLocked: boolean;
  isArchived: boolean;
  request?: { code: string; customerName: string };
  supplierRef?: { code: string; name: string };
}

interface OperatorListResponse {
  data: OperatorListItem[];
  total: number;
}

export default function OperatorsPage() {
  const [operators, setOperators] = useState<OperatorListItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [total, setTotal] = useState(0);
  const [filters, setFilters] = useState<OperatorFilters>({
    search: '',
    serviceType: '',
    paymentStatus: '',
    fromDate: '',
    toDate: '',
    isLocked: undefined,
    includeArchived: false,
  });
  const [lockDialogOpen, setLockDialogOpen] = useState(false);
  const [archiving, setArchiving] = useState(false);

  // AbortController ref for race condition prevention
  const abortRef = useRef<AbortController | null>(null);

  const fetchOperators = useCallback(async (signal?: AbortSignal) => {
    setLoading(true);
    setError(null);
    const params = new URLSearchParams();

    if (filters.search) params.set('search', filters.search);
    if (filters.serviceType) params.set('serviceType', filters.serviceType);
    if (filters.paymentStatus) params.set('paymentStatus', filters.paymentStatus);
    if (filters.fromDate) params.set('fromDate', filters.fromDate);
    if (filters.toDate) params.set('toDate', filters.toDate);
    if (filters.isLocked !== undefined) params.set('isLocked', String(filters.isLocked));
    if (filters.includeArchived) params.set('includeArchived', 'true');

    const { data, error: fetchError } = await safeFetch<OperatorListResponse>(
      `/api/operators?${params}`,
      { signal }
    );

    // Ignore if aborted
    if (signal?.aborted) return;

    if (fetchError) {
      setError(fetchError);
      setOperators([]);
      setTotal(0);
    } else if (data) {
      setOperators(data.data || []);
      setTotal(data.total || 0);
    }
    setLoading(false);
  }, [filters]);

  // Fetch on filter change with abort handling
  useEffect(() => {
    // Cancel previous request
    abortRef.current?.abort();
    abortRef.current = new AbortController();

    fetchOperators(abortRef.current.signal);

    return () => {
      abortRef.current?.abort();
    };
  }, [fetchOperators]);

  // Archive completed operators (paidAmount >= totalCost)
  const handleAutoArchive = async () => {
    setArchiving(true);
    const { data, error } = await safePost<{ archivedCount: number; message: string }>(
      '/api/operators/archive',
      { autoArchive: true }
    );
    if (error) {
      toast.error(error);
    } else if (data) {
      toast.success(data.message);
      fetchOperators();
    }
    setArchiving(false);
  };

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('vi-VN').format(value);
  };

  const formatDate = (date: string | Date) => {
    return new Date(date).toLocaleDateString('vi-VN');
  };

  const getServiceTypeLabel = (type: string) => {
    return SERVICE_TYPES[type as ServiceTypeKey]?.label || type;
  };

  const getPaymentStatusInfo = (status: string) => {
    return PAYMENT_STATUSES[status as PaymentStatusKey] || { label: status, color: 'gray' };
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold flex items-center gap-2">
            <ClipboardList className="h-6 w-6" />
            Quản lý Điều hành
          </h1>
          <p className="text-muted-foreground">Chi phí dịch vụ theo Booking</p>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" asChild>
            <Link href="/operators/reports">
              <BarChart3 className="mr-2 h-4 w-4" /> Báo cáo
            </Link>
          </Button>
          <Button
            variant="outline"
            onClick={handleAutoArchive}
            disabled={archiving}
            title="Tự động lưu trữ dịch vụ đã hoàn thành thanh toán của tháng trước"
          >
            <Archive className="mr-2 h-4 w-4" />
            {archiving ? 'Đang xử lý...' : 'Lưu trữ đã hoàn thành'}
          </Button>
          <Button variant="outline" onClick={() => setLockDialogOpen(true)}>
            <Lock className="mr-2 h-4 w-4" /> Khóa kỳ
          </Button>
          <Button asChild>
            <Link href="/operators/create">
              <Plus className="mr-2 h-4 w-4" /> Thêm dịch vụ
            </Link>
          </Button>
        </div>
      </div>

      {/* Filters */}
      <Card>
        <CardContent className="pt-6">
          <OperatorListFilters filters={filters} onFilterChange={setFilters} />
        </CardContent>
      </Card>

      {/* Table */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between">
          <CardTitle>Danh sách dịch vụ ({total})</CardTitle>
          {error && (
            <Button variant="outline" size="sm" onClick={() => fetchOperators()}>
              <RefreshCw className="mr-2 h-4 w-4" />
              Thử lại
            </Button>
          )}
        </CardHeader>
        <CardContent>
          {error ? (
            <ErrorFallback
              title="Lỗi tải danh sách"
              message={error}
              onRetry={() => fetchOperators()}
              retryLabel="Tải lại"
            />
          ) : loading ? (
            <div className="text-center py-10 text-muted-foreground">Đang tải...</div>
          ) : operators.length === 0 ? (
            <div className="text-center py-10 text-muted-foreground">
              Chưa có dịch vụ nào
            </div>
          ) : (
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Booking</TableHead>
                  <TableHead>Ngày DV</TableHead>
                  <TableHead>Loại DV</TableHead>
                  <TableHead>Tên dịch vụ</TableHead>
                  <TableHead>NCC</TableHead>
                  <TableHead className="text-right">Tổng chi phí</TableHead>
                  <TableHead>Thanh toán</TableHead>
                  <TableHead></TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {operators.map((op) => {
                  const paymentInfo = getPaymentStatusInfo(op.paymentStatus);
                  return (
                    <TableRow key={op.id}>
                      <TableCell>
                        <div>
                          <Link
                            href={`/requests/${op.requestId}`}
                            className="font-mono text-primary hover:underline"
                          >
                            {op.request?.code || op.requestId.slice(0, 8)}
                          </Link>
                          {op.request?.customerName && (
                            <p className="text-xs text-muted-foreground">
                              {op.request.customerName}
                            </p>
                          )}
                        </div>
                      </TableCell>
                      <TableCell className="whitespace-nowrap">
                        {formatDate(op.serviceDate)}
                      </TableCell>
                      <TableCell>
                        <Badge variant="outline">
                          {getServiceTypeLabel(op.serviceType)}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <Link
                          href={`/operators/${op.id}`}
                          className="font-medium hover:underline"
                        >
                          {op.serviceName}
                        </Link>
                      </TableCell>
                      <TableCell>
                        {op.supplierRef ? (
                          <Link
                            href={`/suppliers/${op.supplierId}`}
                            className="text-primary hover:underline"
                          >
                            {op.supplierRef.name}
                          </Link>
                        ) : (
                          <span className="text-muted-foreground">
                            {op.supplier || '-'}
                          </span>
                        )}
                      </TableCell>
                      <TableCell className="text-right font-medium">
                        {formatCurrency(op.totalCost)} ₫
                      </TableCell>
                      <TableCell>
                        <Badge
                          variant="outline"
                          className={`
                            ${paymentInfo.color === 'green' && 'border-green-500 text-green-600 bg-green-50'}
                            ${paymentInfo.color === 'yellow' && 'border-yellow-500 text-yellow-600 bg-yellow-50'}
                            ${paymentInfo.color === 'orange' && 'border-orange-500 text-orange-600 bg-orange-50'}
                          `}
                        >
                          {paymentInfo.label}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-1">
                          {op.isArchived && (
                            <Badge variant="secondary" className="bg-gray-100 text-gray-600">
                              <ArchiveRestore className="h-3 w-3 mr-1" />
                              Đã lưu trữ
                            </Badge>
                          )}
                          {op.isLocked && (
                            <span title="Đã khóa sổ">
                              <Lock className="h-4 w-4 text-muted-foreground" />
                            </span>
                          )}
                        </div>
                      </TableCell>
                    </TableRow>
                  );
                })}
              </TableBody>
            </Table>
          )}
        </CardContent>
      </Card>

      {/* Lock Period Dialog */}
      <OperatorLockDialog
        open={lockDialogOpen}
        onOpenChange={setLockDialogOpen}
        onSuccess={fetchOperators}
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/revenues/page.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { RevenueTable, RevenueForm, RevenueSummaryCard, SalesSummaryTable } from '@/components/revenues';
import { usePermission } from '@/hooks/use-permission';
import { DollarSign, Plus, Search, Filter, FileBarChart, BarChart3 } from 'lucide-react';
import Link from 'next/link';
import {
  PAYMENT_TYPES,
  PAYMENT_SOURCES,
  type PaymentTypeKey,
  type PaymentSourceKey,
} from '@/config/revenue-config';
import type { SaleItem, SalesSummary } from '@/types';

// Revenue type from API
interface Revenue {
  id: string;
  requestId: string;
  paymentDate: Date | string;
  paymentType: string;
  foreignAmount?: number | null;
  currency?: string | null;
  exchangeRate?: number | null;
  amountVND: number;
  paymentSource: string;
  notes?: string | null;
  // 3-tier lock fields
  lockKT: boolean;
  lockAdmin: boolean;
  lockFinal: boolean;
  // Legacy field for backward compatibility
  isLocked?: boolean;
  lockedAt?: Date | string | null;
  lockedBy?: string | null;
  request?: {
    code: string;
    customerName: string;
    bookingCode?: string | null;
  };
}

interface Filters {
  search: string;
  fromDate: string;
  toDate: string;
  paymentType: string;
  paymentSource: string;
  lockStatus: string;
}

const initialFilters: Filters = {
  search: '',
  fromDate: '',
  toDate: '',
  paymentType: '',
  paymentSource: '',
  lockStatus: '',
};

// Lock status filter options
const LOCK_STATUS_OPTIONS = [
  { value: 'all', label: 'Tat ca' },
  { value: 'unlocked', label: 'Chua khoa' },
  { value: 'lockKT', label: 'Da khoa KT' },
  { value: 'lockAdmin', label: 'Da khoa Admin' },
  { value: 'lockFinal', label: 'Da khoa Cuoi' },
];

export default function RevenuesPage() {
  const { can, isAdmin } = usePermission();

  // Tab state
  const [activeTab, setActiveTab] = useState<'list' | 'sales'>('list');

  // Data state
  const [revenues, setRevenues] = useState<Revenue[]>([]);
  const [loading, setLoading] = useState(true);
  const [total, setTotal] = useState(0);

  // Sales aggregation state
  const [sales, setSales] = useState<SaleItem[]>([]);
  const [salesSummary, setSalesSummary] = useState<SalesSummary>({
    totalRevenue: 0,
    totalCost: 0,
    totalProfit: 0,
    bookingCount: 0,
  });
  const [salesLoading, setSalesLoading] = useState(false);
  const [salesMonth, setSalesMonth] = useState(''); // YYYY-MM

  // Filter state
  const [filters, setFilters] = useState<Filters>(initialFilters);
  const [searchInput, setSearchInput] = useState('');

  // Dialog state
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingRevenue, setEditingRevenue] = useState<Revenue | null>(null);

  // Fetch revenues with filters
  const fetchRevenues = useCallback(async () => {
    setLoading(true);
    try {
      const params = new URLSearchParams();
      if (filters.search) params.set('search', filters.search);
      if (filters.fromDate) params.set('fromDate', filters.fromDate);
      if (filters.toDate) params.set('toDate', filters.toDate);
      if (filters.paymentType) params.set('paymentType', filters.paymentType);
      if (filters.paymentSource) params.set('paymentSource', filters.paymentSource);
      if (filters.lockStatus) params.set('lockStatus', filters.lockStatus);
      params.set('limit', '100');

      const res = await fetch(`/api/revenues?${params}`);
      const data = await res.json();

      if (data.success) {
        setRevenues(data.data || []);
        setTotal(data.total || 0);
      }
    } catch (err) {
      console.error('Error fetching revenues:', err);
    } finally {
      setLoading(false);
    }
  }, [filters]);

  // Debounced search
  useEffect(() => {
    const timer = setTimeout(() => {
      setFilters((prev) => ({ ...prev, search: searchInput }));
    }, 300);
    return () => clearTimeout(timer);
  }, [searchInput]);

  // Fetch on filter change
  useEffect(() => {
    fetchRevenues();
  }, [fetchRevenues]);

  // Fetch sales aggregation
  const fetchSales = useCallback(async () => {
    setSalesLoading(true);
    try {
      const params = new URLSearchParams();
      if (salesMonth) params.set('month', salesMonth);

      const res = await fetch(`/api/revenues/sales?${params}`);
      const data = await res.json();

      if (data.success) {
        setSales(data.data?.sales || []);
        setSalesSummary(data.data?.summary || {
          totalRevenue: 0,
          totalCost: 0,
          totalProfit: 0,
          bookingCount: 0,
        });
      }
    } catch (err) {
      console.error('Error fetching sales:', err);
    } finally {
      setSalesLoading(false);
    }
  }, [salesMonth]);

  // Fetch sales when tab changes or month filter changes
  useEffect(() => {
    if (activeTab === 'sales') {
      fetchSales();
    }
  }, [activeTab, fetchSales]);

  // Handlers
  const handleAdd = useCallback(() => {
    setEditingRevenue(null);
    setDialogOpen(true);
  }, []);

  const handleEdit = useCallback((revenue: Revenue) => {
    setEditingRevenue(revenue);
    setDialogOpen(true);
  }, []);

  const handleDialogClose = useCallback(() => {
    setDialogOpen(false);
    setEditingRevenue(null);
  }, []);

  const handleSuccess = useCallback(() => {
    handleDialogClose();
    fetchRevenues();
  }, [handleDialogClose, fetchRevenues]);

  const handleFilterChange = (key: keyof Filters, value: string) => {
    setFilters((prev) => ({ ...prev, [key]: value }));
  };

  const handleClearFilters = () => {
    setFilters(initialFilters);
    setSearchInput('');
  };

  const hasActiveFilters =
    filters.fromDate ||
    filters.toDate ||
    filters.paymentType ||
    filters.paymentSource ||
    filters.lockStatus;

  return (
    <div className="container mx-auto py-6 px-4 space-y-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <div className="flex items-center gap-3">
          <DollarSign className="h-6 w-6" />
          <div>
            <h1 className="text-2xl font-bold">Quan ly Doanh thu</h1>
            <p className="text-muted-foreground">
              {activeTab === 'list' ? `${total} giao dich` : `${salesSummary.bookingCount} booking`}
            </p>
          </div>
        </div>
        <div className="flex gap-2">
          <Button variant="outline" asChild>
            <Link href="/operators/reports">
              <FileBarChart className="w-4 h-4 mr-2" />
              Bao cao loi nhuan
            </Link>
          </Button>
          {can('revenue:manage') && activeTab === 'list' && (
            <Button onClick={handleAdd}>
              <Plus className="w-4 h-4 mr-2" />
              Them thu nhap
            </Button>
          )}
        </div>
      </div>

      {/* Tabs */}
      <Tabs value={activeTab} onValueChange={(v) => setActiveTab(v as 'list' | 'sales')}>
        <TabsList className="grid w-full max-w-md grid-cols-2">
          <TabsTrigger value="list" className="flex items-center gap-2">
            <DollarSign className="h-4 w-4" />
            Danh sach thu nhap
          </TabsTrigger>
          <TabsTrigger value="sales" className="flex items-center gap-2">
            <BarChart3 className="h-4 w-4" />
            Tong hop doanh thu
          </TabsTrigger>
        </TabsList>

        {/* Revenue List Tab */}
        <TabsContent value="list" className="space-y-6">
          {/* Filters Card */}
          <Card>
            <CardHeader className="pb-3">
              <div className="flex items-center justify-between">
                <CardTitle className="text-base flex items-center gap-2">
                  <Filter className="h-4 w-4" />
                  Bo loc
                </CardTitle>
                {hasActiveFilters && (
                  <Button variant="ghost" size="sm" onClick={handleClearFilters}>
                    Xoa bo loc
                  </Button>
                )}
              </div>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-7 gap-4">
                {/* Search */}
                <div className="space-y-2 lg:col-span-2">
                  <Label>Tim kiem</Label>
                  <div className="relative">
                    <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                    <Input
                      value={searchInput}
                      onChange={(e) => setSearchInput(e.target.value)}
                      placeholder="Ma booking, khach hang..."
                      className="pl-9"
                    />
                  </div>
                </div>

                {/* Date From */}
                <div className="space-y-2">
                  <Label>Tu ngay</Label>
                  <Input
                    type="date"
                    value={filters.fromDate}
                    onChange={(e) => handleFilterChange('fromDate', e.target.value)}
                  />
                </div>

                {/* Date To */}
                <div className="space-y-2">
                  <Label>Den ngay</Label>
                  <Input
                    type="date"
                    value={filters.toDate}
                    onChange={(e) => handleFilterChange('toDate', e.target.value)}
                  />
                </div>

                {/* Payment Type */}
                <div className="space-y-2">
                  <Label>Loai thanh toan</Label>
                  <Select
                    value={filters.paymentType}
                    onValueChange={(v) => handleFilterChange('paymentType', v === 'all' ? '' : v)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Tat ca" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">Tat ca</SelectItem>
                      {(Object.keys(PAYMENT_TYPES) as PaymentTypeKey[]).map((key) => (
                        <SelectItem key={key} value={key}>
                          {PAYMENT_TYPES[key].label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                {/* Payment Source */}
                <div className="space-y-2">
                  <Label>Nguon thanh toan</Label>
                  <Select
                    value={filters.paymentSource}
                    onValueChange={(v) => handleFilterChange('paymentSource', v === 'all' ? '' : v)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Tat ca" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">Tat ca</SelectItem>
                      {(Object.keys(PAYMENT_SOURCES) as PaymentSourceKey[]).map((key) => (
                        <SelectItem key={key} value={key}>
                          {PAYMENT_SOURCES[key].label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                {/* Lock Status */}
                <div className="space-y-2">
                  <Label>Trang thai khoa</Label>
                  <Select
                    value={filters.lockStatus}
                    onValueChange={(v) => handleFilterChange('lockStatus', v === 'all' ? '' : v)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Tat ca" />
                    </SelectTrigger>
                    <SelectContent>
                      {LOCK_STATUS_OPTIONS.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Summary Card */}
          {revenues.length > 0 && <RevenueSummaryCard revenues={revenues} />}

          {/* Revenue Table */}
          <Card>
            <CardContent className="pt-6">
              {loading ? (
                <div className="text-center py-8 text-muted-foreground">
                  Dang tai du lieu...
                </div>
              ) : (
                <RevenueTable
                  revenues={revenues}
                  showRequest={true}
                  onEdit={(rev) => handleEdit(rev as Revenue)}
                  onRefresh={fetchRevenues}
                  canManage={can('revenue:manage')}
                  canUnlock={isAdmin}
                />
              )}
            </CardContent>
          </Card>
        </TabsContent>

        {/* Sales Summary Tab */}
        <TabsContent value="sales" className="space-y-6">
          {/* Month Filter */}
          <Card>
            <CardHeader className="pb-3">
              <CardTitle className="text-base flex items-center gap-2">
                <Filter className="h-4 w-4" />
                Loc theo thang
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="flex items-center gap-4">
                <div className="space-y-2">
                  <Label>Thang (YYYY-MM)</Label>
                  <Input
                    type="month"
                    value={salesMonth}
                    onChange={(e) => setSalesMonth(e.target.value)}
                    className="w-48"
                  />
                </div>
                {salesMonth && (
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setSalesMonth('')}
                    className="mt-6"
                  >
                    Xoa bo loc
                  </Button>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Sales Summary Table */}
          <Card>
            <CardHeader>
              <CardTitle className="text-base flex items-center gap-2">
                <BarChart3 className="h-4 w-4" />
                Tong hop doanh thu theo Booking
              </CardTitle>
            </CardHeader>
            <CardContent>
              {salesLoading ? (
                <div className="text-center py-8 text-muted-foreground">
                  Dang tai du lieu...
                </div>
              ) : (
                <SalesSummaryTable sales={sales} summary={salesSummary} />
              )}
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Add/Edit Dialog */}
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>
              {editingRevenue ? 'Chinh sua thu nhap' : 'Them thu nhap moi'}
            </DialogTitle>
          </DialogHeader>
          <RevenueForm
            revenue={editingRevenue || undefined}
            onSuccess={handleSuccess}
            onCancel={handleDialogClose}
          />
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/settings/page.tsx">
'use client';

import { useState } from 'react';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  SellerTable,
  FollowUpStatusTable,
  FollowUpStatusFormModal,
  GoogleSheetsSync,
} from '@/components/settings';
import { Settings, Users, ListChecks, FileSpreadsheet } from 'lucide-react';
import type { FollowUpStatus } from '@/types';

export default function SettingsPage() {
  // FollowUp state
  const [followUpModalOpen, setFollowUpModalOpen] = useState(false);
  const [editingFollowUp, setEditingFollowUp] = useState<FollowUpStatus | null>(null);
  const [followUpRefreshKey, setFollowUpRefreshKey] = useState(0);

  // Delete handlers
  const handleDeleteFollowUpStatus = async (id: string): Promise<void> => {
    const res = await fetch(`/api/config/follow-up-statuses/${id}`, {
      method: 'DELETE',
    });

    const data = await res.json();

    if (!data.success) {
      throw new Error(data.error || 'Lỗi xóa trạng thái');
    }
  };

  return (
    <div className="container mx-auto py-6 px-4">
      <div className="flex items-center gap-3 mb-6">
        <Settings className="h-6 w-6" />
        <h1 className="text-2xl font-bold">Cài đặt</h1>
      </div>

      <Tabs defaultValue="sellers" className="w-full">
        <TabsList className="mb-6">
          <TabsTrigger value="sellers" className="gap-2">
            <Users className="h-4 w-4" />
            Quản lý Seller
          </TabsTrigger>
          <TabsTrigger value="followup" className="gap-2">
            <ListChecks className="h-4 w-4" />
            Quản lý Trạng thái
          </TabsTrigger>
          <TabsTrigger value="sync" className="gap-2">
            <FileSpreadsheet className="h-4 w-4" />
            Google Sheets Sync
          </TabsTrigger>
        </TabsList>

        <TabsContent value="sellers">
          <div className="bg-white rounded-lg border p-6">
            <SellerTable />
          </div>
        </TabsContent>

        <TabsContent value="followup">
          <div className="bg-white rounded-lg border p-6">
            <FollowUpStatusTable
              key={followUpRefreshKey}
              onAdd={() => {
                setEditingFollowUp(null);
                setFollowUpModalOpen(true);
              }}
              onEdit={(status) => {
                setEditingFollowUp(status);
                setFollowUpModalOpen(true);
              }}
              onDelete={handleDeleteFollowUpStatus}
            />
            <FollowUpStatusFormModal
              open={followUpModalOpen}
              onOpenChange={setFollowUpModalOpen}
              status={editingFollowUp}
              onSuccess={() => {
                setFollowUpModalOpen(false);
                setFollowUpRefreshKey((k) => k + 1);
              }}
            />
          </div>
        </TabsContent>

        <TabsContent value="sync">
          <div className="bg-white rounded-lg border p-6">
            <GoogleSheetsSync />
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/app/api/revenues/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { CURRENCY_KEYS } from '@/config/revenue-config';
import { auth } from '@/auth';
import { hasPermission, type Role } from '@/lib/permissions';
import { generateRevenueId } from '@/lib/id-utils';
import { createRevenueHistory, REVENUE_HISTORY_ACTIONS } from '@/lib/revenue-history';
import { createRevenueApiSchema, extractRevenueZodErrors } from '@/lib/validations/revenue-validation';

// GET /api/revenues - List with filters
export async function GET(request: NextRequest) {
  try {
    // Verify authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chưa đăng nhập' },
        { status: 401 }
      );
    }

    // Verify permission
    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:view')) {
      return NextResponse.json(
        { success: false, error: 'Không có quyền xem thu nhập' },
        { status: 403 }
      );
    }
    const { searchParams } = new URL(request.url);

    // Extract filters
    const requestId = searchParams.get('requestId') || '';
    const paymentType = searchParams.get('paymentType') || '';
    const paymentSource = searchParams.get('paymentSource') || '';
    const currency = searchParams.get('currency') || '';
    const fromDate = searchParams.get('fromDate') || '';
    const toDate = searchParams.get('toDate') || '';
    const isLocked = searchParams.get('isLocked');
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Build where clause
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const where: Record<string, any> = {};

    if (requestId) where.requestId = requestId;
    if (paymentType) where.paymentType = paymentType;
    if (paymentSource) where.paymentSource = paymentSource;
    if (currency) where.currency = currency;
    if (isLocked !== null && isLocked !== '') {
      where.isLocked = isLocked === 'true';
    }

    if (fromDate || toDate) {
      where.paymentDate = {};
      if (fromDate) where.paymentDate.gte = new Date(fromDate);
      if (toDate) where.paymentDate.lte = new Date(toDate);
    }

    const [revenues, total] = await Promise.all([
      prisma.revenue.findMany({
        where,
        include: {
          request: { select: { code: true, customerName: true, bookingCode: true } },
          user: { select: { id: true, name: true } },
        },
        orderBy: { paymentDate: 'desc' },
        skip: offset,
        take: limit,
      }),
      prisma.revenue.count({ where }),
    ]);

    return NextResponse.json({
      success: true,
      data: revenues,
      total,
      hasMore: offset + revenues.length < total,
    });
  } catch (error) {
    console.error('Error fetching revenues:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải danh sách thu nhập: ${message}` },
      { status: 500 }
    );
  }
}

// POST /api/revenues - Create revenue
export async function POST(request: NextRequest) {
  try {
    // Verify authentication
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json(
        { success: false, error: 'Chưa đăng nhập' },
        { status: 401 }
      );
    }

    // Verify permission
    const role = session.user.role as Role;
    if (!hasPermission(role, 'revenue:manage')) {
      return NextResponse.json(
        { success: false, error: 'Không có quyền tạo thu nhập' },
        { status: 403 }
      );
    }

    const body = await request.json();

    // Validate with Zod schema
    const validationResult = createRevenueApiSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        {
          success: false,
          error: 'Du lieu khong hop le',
          errors: extractRevenueZodErrors(validationResult.error)
        },
        { status: 400 }
      );
    }
    const validatedData = validationResult.data;

    // Validate request exists and get bookingCode for revenueId generation
    const req = await prisma.request.findUnique({
      where: { id: validatedData.requestId },
      select: { id: true, bookingCode: true },
    });

    if (!req) {
      return NextResponse.json(
        { success: false, error: 'Yeu cau khong ton tai' },
        { status: 404 }
      );
    }

    // Generate revenueId using bookingCode or requestId fallback
    const revenueId = await generateRevenueId(req.bookingCode || validatedData.requestId);

    // Calculate amountVND from foreign currency if needed
    const currency = validatedData.currency;
    let amountVND: number;
    let foreignAmount: number | null = null;
    let exchangeRate: number | null = null;

    if (currency === 'VND') {
      amountVND = validatedData.amountVND || 0;
    } else {
      // Currency already validated by Zod
      foreignAmount = validatedData.foreignAmount || 0;
      exchangeRate = validatedData.exchangeRate || 0;
      amountVND = Math.round(foreignAmount * exchangeRate);
    }

    // Create revenue - use authenticated user ID from session
    const revenue = await prisma.revenue.create({
      data: {
        revenueId,
        requestId: validatedData.requestId,
        paymentDate: new Date(validatedData.paymentDate),
        paymentType: validatedData.paymentType,
        foreignAmount,
        currency,
        exchangeRate,
        amountVND,
        paymentSource: validatedData.paymentSource,
        notes: validatedData.notes?.trim() || null,
        userId: session.user.id,
      },
      include: {
        request: { select: { code: true, customerName: true, bookingCode: true } },
        user: { select: { id: true, name: true } },
      },
    });

    // Create history entry for CREATE action
    await createRevenueHistory({
      revenueId: revenue.id,
      action: REVENUE_HISTORY_ACTIONS.CREATE,
      changes: {
        revenueId: { after: revenueId },
        amountVND: { after: amountVND },
        paymentType: { after: validatedData.paymentType },
        paymentSource: { after: validatedData.paymentSource },
      },
      userId: session.user.id,
    });

    return NextResponse.json({ success: true, data: revenue }, { status: 201 });
  } catch (error) {
    console.error('Error creating revenue:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo thu nhập: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/components/operators/operator-form.tsx">
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { SERVICE_TYPES, SERVICE_TYPE_KEYS, DEFAULT_VAT_RATE } from '@/config/operator-config';
import type { Supplier } from '@/types';
import {
  validateOperatorForm,
  type OperatorFormErrors,
} from '@/lib/validations/operator-validation';
import { safeParseFloat, safeNonNegativeFloat } from '@/lib/utils/parse-utils';

interface Request {
  id: string;
  code: string;
  customerName: string;
  status: string;
}

// Minimal operator data needed for the form
interface OperatorData {
  id: string;
  requestId: string;
  supplierId?: string | null;
  supplier?: string | null;
  serviceDate: Date | string;
  serviceType: string;
  serviceName: string;
  costBeforeTax: number;
  vat?: number | null;
  totalCost: number;
  paidAmount?: number;
  paymentDeadline?: Date | string | null;
  bankAccount?: string | null;
  notes?: string | null;
}

interface OperatorFormProps {
  operator?: OperatorData;
  requestId?: string; // Pre-selected request
  onSuccess?: () => void;
}

export function OperatorForm({ operator, requestId, onSuccess }: OperatorFormProps) {
  const router = useRouter();
  const isEditing = !!operator;

  // Form state
  const [formData, setFormData] = useState({
    requestId: operator?.requestId || requestId || '',
    supplierId: operator?.supplierId || '',
    supplier: operator?.supplier || '',
    serviceDate: operator?.serviceDate
      ? new Date(operator.serviceDate).toISOString().split('T')[0]
      : new Date().toISOString().split('T')[0],
    serviceType: operator?.serviceType || '',
    serviceName: operator?.serviceName || '',
    costBeforeTax: operator?.costBeforeTax?.toString() || '',
    vat: operator?.vat?.toString() || '',
    totalCost: operator?.totalCost?.toString() || '',
    paymentDeadline: operator?.paymentDeadline
      ? new Date(operator.paymentDeadline).toISOString().split('T')[0]
      : '',
    paidAmount: operator?.paidAmount?.toString() || '0',
    bankAccount: operator?.bankAccount || '',
    notes: operator?.notes || '',
  });

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [fieldErrors, setFieldErrors] = useState<OperatorFormErrors>({});

  // Data for dropdowns
  const [requests, setRequests] = useState<Request[]>([]);
  const [suppliers, setSuppliers] = useState<Supplier[]>([]);
  const [loadingData, setLoadingData] = useState(true);

  // Fetch F5 requests and suppliers
  useEffect(() => {
    const fetchData = async () => {
      setLoadingData(true);
      try {
        const [reqRes, supRes] = await Promise.all([
          fetch('/api/requests?status=F5&limit=100'),
          fetch('/api/suppliers?isActive=true'),
        ]);

        const [reqData, supData] = await Promise.all([
          reqRes.json(),
          supRes.json(),
        ]);

        if (reqData.success) setRequests(reqData.data || []);
        if (supData.success) setSuppliers(supData.data || []);
      } catch (err) {
        console.error('Error fetching data:', err);
      } finally {
        setLoadingData(false);
      }
    };
    fetchData();
  }, []);

  // Auto-calculate totalCost when costBeforeTax or vat changes
  const calculateTotal = useCallback(() => {
    const cost = safeParseFloat(formData.costBeforeTax, 0);
    const vatAmount = safeParseFloat(formData.vat, 0);
    const total = cost + vatAmount;
    setFormData((prev) => ({ ...prev, totalCost: total.toString() }));
  }, [formData.costBeforeTax, formData.vat]);

  useEffect(() => {
    calculateTotal();
  }, [calculateTotal]);

  // Auto-fill VAT when costBeforeTax changes (default 10%)
  const handleCostChange = (value: string) => {
    const cost = safeParseFloat(value, 0);
    const vatAmount = Math.round(cost * DEFAULT_VAT_RATE / 100);
    setFormData((prev) => ({
      ...prev,
      costBeforeTax: value,
      vat: vatAmount.toString(),
    }));
  };

  // Auto-fill supplier name and bank account when supplier selected
  const handleSupplierChange = (supplierId: string) => {
    if (supplierId === 'none') {
      setFormData((prev) => ({ ...prev, supplierId: '', supplier: '', bankAccount: '' }));
      return;
    }

    const selectedSupplier = suppliers.find((s) => s.id === supplierId);
    if (selectedSupplier) {
      setFormData((prev) => ({
        ...prev,
        supplierId,
        supplier: selectedSupplier.name,
        bankAccount: selectedSupplier.bankAccount || prev.bankAccount,
      }));
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    setFieldErrors({});

    try {
      // Build data for validation with safe parsing for costs
      const dataToValidate = {
        requestId: formData.requestId,
        serviceDate: formData.serviceDate,
        serviceType: formData.serviceType,
        serviceName: formData.serviceName,
        supplierId: formData.supplierId || null,
        supplier: formData.supplier || null,
        costBeforeTax: safeNonNegativeFloat(formData.costBeforeTax, 0),
        vat: formData.vat ? safeNonNegativeFloat(formData.vat, 0) : null,
        totalCost: safeNonNegativeFloat(formData.totalCost, 0),
        paidAmount: safeNonNegativeFloat(formData.paidAmount, 0),
        paymentDeadline: formData.paymentDeadline || null,
        bankAccount: formData.bankAccount || null,
        notes: formData.notes || null,
      };

      // Client-side validation with Zod
      const validation = validateOperatorForm(dataToValidate);
      if (!validation.success) {
        setFieldErrors(validation.errors || {});
        setError('Vui lòng kiểm tra lại thông tin');
        setLoading(false);
        return;
      }

      const url = isEditing ? `/api/operators/${operator.id}` : '/api/operators';
      const method = isEditing ? 'PUT' : 'POST';

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(dataToValidate),
      });

      const data = await res.json();

      if (!data.success) {
        // Handle field-level errors from API
        if (data.errors) {
          setFieldErrors(data.errors);
        }
        setError(data.error || 'Có lỗi xảy ra');
        return;
      }

      if (onSuccess) {
        onSuccess();
      } else {
        router.push(`/operators/${data.data.id}`);
      }
    } catch {
      setError('Có lỗi xảy ra khi lưu dữ liệu');
    } finally {
      setLoading(false);
    }
  };

  // Clear field error when user starts typing
  const updateField = (field: string, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
    if (fieldErrors[field as keyof OperatorFormErrors]) {
      setFieldErrors((prev) => ({ ...prev, [field]: undefined }));
    }
  };

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('vi-VN').format(value);
  };

  if (loadingData) {
    return <div className="text-center py-10">Đang tải dữ liệu...</div>;
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="bg-red-50 text-red-600 p-4 rounded-lg">
          {error}
        </div>
      )}

      {/* Booking Selection */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin Booking</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="requestId">Booking *</Label>
            <Select
              value={formData.requestId}
              onValueChange={(v) => updateField('requestId', v)}
              disabled={isEditing || !!requestId}
            >
              <SelectTrigger className={fieldErrors.requestId ? 'border-red-500' : ''}>
                <SelectValue placeholder="Chọn Booking (F5)" />
              </SelectTrigger>
              <SelectContent>
                {requests.length === 0 ? (
                  <SelectItem value="none" disabled>Không có Booking F5</SelectItem>
                ) : (
                  requests.map((req) => (
                    <SelectItem key={req.id} value={req.id}>
                      {req.code} - {req.customerName}
                    </SelectItem>
                  ))
                )}
              </SelectContent>
            </Select>
            {fieldErrors.requestId && (
              <p className="text-sm text-red-500">{fieldErrors.requestId}</p>
            )}
            <p className="text-sm text-muted-foreground">
              Chỉ hiển thị Booking đã xác nhận (F5)
            </p>
          </div>
        </CardContent>
      </Card>

      {/* Service Info */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin dịch vụ</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="serviceDate">Ngày dịch vụ *</Label>
              <Input
                id="serviceDate"
                type="date"
                value={formData.serviceDate}
                onChange={(e) => updateField('serviceDate', e.target.value)}
                className={fieldErrors.serviceDate ? 'border-red-500' : ''}
                required
              />
              {fieldErrors.serviceDate && (
                <p className="text-sm text-red-500">{fieldErrors.serviceDate}</p>
              )}
            </div>
            <div className="space-y-2">
              <Label htmlFor="serviceType">Loại dịch vụ *</Label>
              <Select
                value={formData.serviceType}
                onValueChange={(v) => updateField('serviceType', v)}
              >
                <SelectTrigger className={fieldErrors.serviceType ? 'border-red-500' : ''}>
                  <SelectValue placeholder="Chọn loại dịch vụ" />
                </SelectTrigger>
                <SelectContent>
                  {SERVICE_TYPE_KEYS.map((key) => (
                    <SelectItem key={key} value={key}>
                      {SERVICE_TYPES[key].label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              {fieldErrors.serviceType && (
                <p className="text-sm text-red-500">{fieldErrors.serviceType}</p>
              )}
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="serviceName">Tên dịch vụ *</Label>
            <Input
              id="serviceName"
              value={formData.serviceName}
              onChange={(e) => updateField('serviceName', e.target.value)}
              placeholder="VD: Khách sạn Mường Thanh - 2 đêm"
              className={fieldErrors.serviceName ? 'border-red-500' : ''}
              required
            />
            {fieldErrors.serviceName && (
              <p className="text-sm text-red-500">{fieldErrors.serviceName}</p>
            )}
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="supplierId">Nhà cung cấp</Label>
              <Select
                value={formData.supplierId || 'none'}
                onValueChange={handleSupplierChange}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Chọn NCC (tùy chọn)" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="none">-- Nhập tay --</SelectItem>
                  {suppliers.map((sup) => (
                    <SelectItem key={sup.id} value={sup.id}>
                      {sup.code} - {sup.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
            <div className="space-y-2">
              <Label htmlFor="supplier">Tên NCC {!formData.supplierId && '*'}</Label>
              <Input
                id="supplier"
                value={formData.supplier}
                onChange={(e) => updateField('supplier', e.target.value)}
                placeholder="Nhập tên NCC nếu không chọn"
                disabled={!!formData.supplierId}
                className={fieldErrors.supplier ? 'border-red-500' : ''}
              />
              {fieldErrors.supplier && (
                <p className="text-sm text-red-500">{fieldErrors.supplier}</p>
              )}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Cost Info */}
      <Card>
        <CardHeader>
          <CardTitle>Chi phí</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-3 gap-4">
            <div className="space-y-2">
              <Label htmlFor="costBeforeTax">Chi phí trước thuế *</Label>
              <Input
                id="costBeforeTax"
                type="number"
                value={formData.costBeforeTax}
                onChange={(e) => handleCostChange(e.target.value)}
                placeholder="1000000"
                className={fieldErrors.costBeforeTax ? 'border-red-500' : ''}
                required
              />
              {fieldErrors.costBeforeTax && (
                <p className="text-sm text-red-500">{fieldErrors.costBeforeTax}</p>
              )}
              {formData.costBeforeTax && !fieldErrors.costBeforeTax && (
                <p className="text-sm text-muted-foreground">
                  {formatCurrency(safeParseFloat(formData.costBeforeTax, 0))} ₫
                </p>
              )}
            </div>
            <div className="space-y-2">
              <Label htmlFor="vat">VAT ({DEFAULT_VAT_RATE}%)</Label>
              <Input
                id="vat"
                type="number"
                value={formData.vat}
                onChange={(e) => updateField('vat', e.target.value)}
                placeholder="100000"
              />
              {formData.vat && (
                <p className="text-sm text-muted-foreground">
                  {formatCurrency(safeParseFloat(formData.vat, 0))} ₫
                </p>
              )}
            </div>
            <div className="space-y-2">
              <Label htmlFor="totalCost">Tổng chi phí</Label>
              <Input
                id="totalCost"
                type="number"
                value={formData.totalCost}
                onChange={(e) => updateField('totalCost', e.target.value)}
                className={`bg-gray-100 font-bold ${fieldErrors.totalCost ? 'border-red-500' : ''}`}
              />
              {fieldErrors.totalCost && (
                <p className="text-sm text-red-500">{fieldErrors.totalCost}</p>
              )}
              {formData.totalCost && !fieldErrors.totalCost && (
                <p className="text-sm font-medium text-primary">
                  {formatCurrency(safeParseFloat(formData.totalCost, 0))} ₫
                </p>
              )}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Payment Info */}
      <Card>
        <CardHeader>
          <CardTitle>Thanh toán</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-3 gap-4">
            <div className="space-y-2">
              <Label htmlFor="paymentDeadline">Hạn thanh toán</Label>
              <Input
                id="paymentDeadline"
                type="date"
                value={formData.paymentDeadline}
                onChange={(e) => updateField('paymentDeadline', e.target.value)}
                className={fieldErrors.paymentDeadline ? 'border-red-500' : ''}
              />
              {fieldErrors.paymentDeadline && (
                <p className="text-sm text-red-500">{fieldErrors.paymentDeadline}</p>
              )}
            </div>
            <div className="space-y-2">
              <Label htmlFor="paidAmount">Đã thanh toán</Label>
              <Input
                id="paidAmount"
                type="number"
                min="0"
                max={formData.totalCost}
                value={formData.paidAmount}
                onChange={(e) => updateField('paidAmount', e.target.value)}
                placeholder="0"
                className={fieldErrors.paidAmount ? 'border-red-500' : ''}
              />
              {fieldErrors.paidAmount && (
                <p className="text-sm text-red-500">{fieldErrors.paidAmount}</p>
              )}
              {formData.paidAmount && safeParseFloat(formData.paidAmount, 0) > 0 && !fieldErrors.paidAmount && (
                <p className="text-sm text-green-600">
                  {formatCurrency(safeParseFloat(formData.paidAmount, 0))} ₫
                </p>
              )}
            </div>
            <div className="space-y-2">
              <Label>Còn nợ</Label>
              <div className="h-10 px-3 py-2 rounded-md border bg-gray-100 flex items-center">
                <span className={`font-medium ${
                  safeParseFloat(formData.totalCost, 0) - safeParseFloat(formData.paidAmount, 0) > 0
                    ? 'text-red-600'
                    : 'text-green-600'
                }`}>
                  {formatCurrency(
                    Math.max(0, safeParseFloat(formData.totalCost, 0) - safeParseFloat(formData.paidAmount, 0))
                  )} ₫
                </span>
              </div>
            </div>
          </div>
          <div className="space-y-2">
            <Label htmlFor="bankAccount">Tài khoản ngân hàng</Label>
            <Input
              id="bankAccount"
              value={formData.bankAccount}
              onChange={(e) => updateField('bankAccount', e.target.value)}
              placeholder="0123456789 - Vietcombank"
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="notes">Ghi chú</Label>
            <Textarea
              id="notes"
              value={formData.notes}
              onChange={(e) => updateField('notes', e.target.value)}
              placeholder="Ghi chú về dịch vụ..."
              rows={3}
            />
          </div>
        </CardContent>
      </Card>

      {/* Actions */}
      <div className="flex gap-4">
        <Button type="submit" disabled={loading}>
          {loading ? 'Đang lưu...' : isEditing ? 'Cập nhật' : 'Tạo dịch vụ'}
        </Button>
        <Button type="button" variant="outline" onClick={() => router.back()}>
          Hủy
        </Button>
      </div>
    </form>
  );
}
</file>

<file path="src/components/requests/request-list-panel.tsx">
'use client';

import { useRef, useCallback, useEffect } from 'react';
import { Input } from '@/components/ui/input';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Button } from '@/components/ui/button';
import { Search, Loader2, AlertTriangle, RefreshCw } from 'lucide-react';
import { RequestListItem } from './request-list-item';
import type { Request } from '@/types';

interface RequestListPanelProps {
  requests: Request[];
  selectedId: string | null;
  onSelect: (id: string) => void;
  isLoading: boolean;
  searchValue: string;
  onSearchChange: (value: string) => void;
  // Error handling props
  error?: string | null;
  onRetry?: () => void;
  // Pagination props
  total?: number;
  hasMore?: boolean;
  isLoadingMore?: boolean;
  loadMoreError?: string | null;
  onLoadMore?: () => void;
}

/**
 * Left panel containing search input and scrollable request list.
 * Fixed width of 350px (280px on medium screens).
 */
export function RequestListPanel({
  requests,
  selectedId,
  onSelect,
  isLoading,
  searchValue,
  onSearchChange,
  error,
  onRetry,
  total = 0,
  hasMore = false,
  isLoadingMore = false,
  loadMoreError,
  onLoadMore,
}: RequestListPanelProps) {
  const observerRef = useRef<IntersectionObserver | null>(null);

  // Intersection Observer callback for infinite scroll
  const lastItemRef = useCallback(
    (node: HTMLDivElement | null) => {
      if (isLoading || isLoadingMore) return;
      if (observerRef.current) observerRef.current.disconnect();

      observerRef.current = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting && hasMore && onLoadMore) {
          onLoadMore();
        }
      });

      if (node) observerRef.current.observe(node);
    },
    [isLoading, isLoadingMore, hasMore, onLoadMore]
  );

  // Cleanup observer on unmount
  useEffect(() => {
    return () => {
      if (observerRef.current) observerRef.current.disconnect();
    };
  }, []);
  return (
    <div className="w-[350px] lg:w-[350px] md:w-[280px] border-r flex flex-col h-full bg-background">
      {/* Search input */}
      <div className="p-3 border-b">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Tìm kiếm..."
            value={searchValue}
            onChange={(e) => onSearchChange(e.target.value)}
            className="pl-9"
          />
        </div>
      </div>

      {/* Request list */}
      <ScrollArea className="flex-1">
        {isLoading ? (
          <div className="p-4 flex items-center justify-center text-muted-foreground">
            <Loader2 className="h-5 w-5 animate-spin mr-2" />
            Đang tải...
          </div>
        ) : error ? (
          <div className="p-4 flex flex-col items-center justify-center text-center">
            <AlertTriangle className="h-8 w-8 text-destructive mb-2" />
            <p className="text-sm text-destructive mb-3">{error}</p>
            {onRetry && (
              <Button variant="outline" size="sm" onClick={onRetry}>
                <RefreshCw className="h-4 w-4 mr-2" />
                Thử lại
              </Button>
            )}
          </div>
        ) : requests.length === 0 ? (
          <div className="p-4 text-center text-muted-foreground">
            Không có yêu cầu nào
          </div>
        ) : (
          <>
            {requests.map((req, index) => {
              const isLastItem = index === requests.length - 1;
              return (
                <div key={req.id} ref={isLastItem ? lastItemRef : undefined}>
                  <RequestListItem
                    request={req}
                    isSelected={req.id === selectedId}
                    onClick={() => onSelect(req.id)}
                  />
                </div>
              );
            })}
            {isLoadingMore && (
              <div className="p-3 flex items-center justify-center text-muted-foreground">
                <Loader2 className="h-4 w-4 animate-spin mr-2" />
                Đang tải thêm...
              </div>
            )}
            {loadMoreError && (
              <div className="p-3 flex flex-col items-center text-center">
                <p className="text-xs text-destructive mb-2">{loadMoreError}</p>
                <Button variant="ghost" size="sm" onClick={onLoadMore}>
                  Thử lại
                </Button>
              </div>
            )}
          </>
        )}
      </ScrollArea>

      {/* Count footer */}
      <div className="p-2 border-t text-xs text-muted-foreground text-center">
        {total > 0 ? `Hiển thị ${requests.length} / ${total} yêu cầu` : `${requests.length} yêu cầu`}
      </div>
    </div>
  );
}
</file>

<file path="src/components/revenues/revenue-form.tsx">
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { CurrencyInput } from '@/components/ui/currency-input';
import { usePermission } from '@/hooks/use-permission';
import { safeFetch, safePost, safePut } from '@/lib/api/fetch-utils';

// Payment types (inline to avoid build-time dependency)
const PAYMENT_TYPES = {
  DEPOSIT: { label: 'Đặt cọc' },
  FULL_PAYMENT: { label: 'Thanh toán đủ' },
  PARTIAL: { label: 'Thanh toán một phần' },
  REFUND: { label: 'Hoàn tiền' },
} as const;

const PAYMENT_SOURCES = {
  BANK_TRANSFER: { label: 'Chuyển khoản' },
  CASH: { label: 'Tiền mặt' },
  CARD: { label: 'Thẻ tín dụng' },
  PAYPAL: { label: 'PayPal' },
  WISE: { label: 'Wise' },
  OTHER: { label: 'Khác' },
} as const;

type PaymentTypeKey = keyof typeof PAYMENT_TYPES;
type PaymentSourceKey = keyof typeof PAYMENT_SOURCES;

interface Request {
  id: string;
  code: string;
  customerName: string;
  bookingCode?: string | null;
}

interface RevenueData {
  id: string;
  requestId: string;
  paymentDate: Date | string;
  paymentType: string;
  foreignAmount?: number | null;
  currency?: string | null;
  exchangeRate?: number | null;
  amountVND: number;
  paymentSource: string;
  notes?: string | null;
  // 3-tier lock fields
  lockKT?: boolean;
  lockAdmin?: boolean;
  lockFinal?: boolean;
  // Legacy field for backward compatibility
  isLocked?: boolean;
}

interface RevenueFormProps {
  revenue?: RevenueData;
  requestId?: string; // Pre-selected request
  onSuccess?: () => void;
  onCancel?: () => void;
}

export function RevenueForm({ revenue, requestId, onSuccess, onCancel }: RevenueFormProps) {
  const { userId } = usePermission();
  const isEditing = !!revenue;

  // Form state
  const [formData, setFormData] = useState({
    requestId: revenue?.requestId || requestId || '',
    paymentDate: revenue?.paymentDate
      ? new Date(revenue.paymentDate).toISOString().split('T')[0]
      : new Date().toISOString().split('T')[0],
    paymentType: revenue?.paymentType || '',
    paymentSource: revenue?.paymentSource || '',
    notes: revenue?.notes || '',
  });

  const [currencyData, setCurrencyData] = useState({
    currency: revenue?.currency || 'VND',
    foreignAmount: revenue?.foreignAmount ? Number(revenue.foreignAmount) : null,
    exchangeRate: revenue?.exchangeRate ? Number(revenue.exchangeRate) : null,
    amountVND: revenue?.amountVND ? Number(revenue.amountVND) : 0,
  });

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [requests, setRequests] = useState<Request[]>([]);
  const [loadingRequests, setLoadingRequests] = useState(true);

  // Fetch requests with booking codes
  useEffect(() => {
    const fetchRequests = async () => {
      setLoadingRequests(true);
      const { data, error } = await safeFetch<Request[]>('/api/requests?stage=OUTCOME&limit=100');
      if (error) {
        console.error('Error fetching requests:', error);
      } else {
        setRequests(data || []);
      }
      setLoadingRequests(false);
    };
    fetchRequests();
  }, []);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    // Validation
    if (!formData.requestId) {
      setError('Vui long chon Booking');
      setLoading(false);
      return;
    }
    if (!formData.paymentType) {
      setError('Vui long chon loai thanh toan');
      setLoading(false);
      return;
    }
    if (!formData.paymentSource) {
      setError('Vui long chon nguon thanh toan');
      setLoading(false);
      return;
    }
    if (currencyData.amountVND <= 0) {
      setError('So tien VND phai > 0');
      setLoading(false);
      return;
    }

    const body = {
      requestId: formData.requestId,
      paymentDate: formData.paymentDate,
      paymentType: formData.paymentType,
      paymentSource: formData.paymentSource,
      currency: currencyData.currency,
      foreignAmount: currencyData.foreignAmount,
      exchangeRate: currencyData.exchangeRate,
      amountVND: currencyData.amountVND,
      notes: formData.notes?.trim() || null,
      userId: userId || 'unknown',
    };

    const { error: apiError } = isEditing
      ? await safePut(`/api/revenues/${revenue.id}`, body)
      : await safePost('/api/revenues', body);

    if (apiError) {
      setError(apiError);
      setLoading(false);
      return;
    }

    setLoading(false);
    if (onSuccess) {
      onSuccess();
    }
  };

  const updateField = (field: string, value: string) => {
    setFormData((prev) => ({ ...prev, [field]: value }));
  };

  if (loadingRequests) {
    return <div className="text-center py-10">Đang tải dữ liệu...</div>;
  }

  // Check if any lock tier is active (3-tier or legacy)
  const isLocked = revenue?.lockKT || revenue?.lockAdmin || revenue?.lockFinal || revenue?.isLocked;

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <div className="bg-red-50 text-red-600 p-4 rounded-lg">
          {error}
        </div>
      )}

      {isLocked && (
        <div className="bg-amber-50 text-amber-600 p-4 rounded-lg">
          Thu nhập đã khóa - không thể chỉnh sửa
        </div>
      )}

      {/* Booking Selection */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin Booking</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="requestId">Booking *</Label>
            <Select
              value={formData.requestId}
              onValueChange={(v) => updateField('requestId', v)}
              disabled={isEditing || !!requestId || isLocked}
            >
              <SelectTrigger>
                <SelectValue placeholder="Chọn Booking" />
              </SelectTrigger>
              <SelectContent>
                {requests.length === 0 ? (
                  <SelectItem value="none" disabled>Không có Booking</SelectItem>
                ) : (
                  requests.map((req) => (
                    <SelectItem key={req.id} value={req.id}>
                      {req.bookingCode || req.code} - {req.customerName}
                    </SelectItem>
                  ))
                )}
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {/* Payment Info */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin thanh toán</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="paymentDate">Ngày thanh toán *</Label>
              <Input
                id="paymentDate"
                type="date"
                value={formData.paymentDate}
                onChange={(e) => updateField('paymentDate', e.target.value)}
                disabled={isLocked}
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="paymentType">Loại thanh toán *</Label>
              <Select
                value={formData.paymentType}
                onValueChange={(v) => updateField('paymentType', v)}
                disabled={isLocked}
              >
                <SelectTrigger>
                  <SelectValue placeholder="Chọn loại" />
                </SelectTrigger>
                <SelectContent>
                  {(Object.keys(PAYMENT_TYPES) as PaymentTypeKey[]).map((key) => (
                    <SelectItem key={key} value={key}>
                      {PAYMENT_TYPES[key].label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          <div className="space-y-2">
            <Label htmlFor="paymentSource">Nguồn thanh toán *</Label>
            <Select
              value={formData.paymentSource}
              onValueChange={(v) => updateField('paymentSource', v)}
              disabled={isLocked}
            >
              <SelectTrigger>
                <SelectValue placeholder="Chọn nguồn" />
              </SelectTrigger>
              <SelectContent>
                {(Object.keys(PAYMENT_SOURCES) as PaymentSourceKey[]).map((key) => (
                  <SelectItem key={key} value={key}>
                    {PAYMENT_SOURCES[key].label}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {/* Amount Info */}
      <Card>
        <CardHeader>
          <CardTitle>Số tiền</CardTitle>
        </CardHeader>
        <CardContent>
          <CurrencyInput
            value={currencyData}
            onChange={setCurrencyData}
            disabled={isLocked}
          />
        </CardContent>
      </Card>

      {/* Notes */}
      <Card>
        <CardHeader>
          <CardTitle>Ghi chú</CardTitle>
        </CardHeader>
        <CardContent>
          <Textarea
            value={formData.notes}
            onChange={(e) => updateField('notes', e.target.value)}
            placeholder="Ghi chú về thanh toán..."
            rows={3}
            disabled={isLocked}
          />
        </CardContent>
      </Card>

      {/* Actions */}
      {!isLocked && (
        <div className="flex gap-4">
          <Button type="submit" disabled={loading}>
            {loading ? 'Đang lưu...' : isEditing ? 'Cập nhật' : 'Tạo thu nhập'}
          </Button>
          {onCancel && (
            <Button type="button" variant="outline" onClick={onCancel}>
              Hủy
            </Button>
          )}
        </div>
      )}
    </form>
  );
}
</file>

<file path="src/app/(dashboard)/operators/[id]/page.tsx">
'use client';

import { useState, useEffect, use, useRef } from 'react';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  ArrowLeft,
  ClipboardList,
  Edit,
  Trash2,
  Calendar,
  Building2,
  CreditCard,
  FileText,
  Unlock,
  Archive,
  ArchiveRestore,
} from 'lucide-react';
import { OperatorForm } from '@/components/operators/operator-form';
import { OperatorHistoryPanel } from '@/components/operators/operator-history-panel';
import { LockIndicator } from '@/components/operators/lock-indicator';
import { ErrorFallback } from '@/components/ui/error-fallback';
import { safeFetch, safeDelete, safePost } from '@/lib/api/fetch-utils';
import { toast } from 'sonner';
import { SERVICE_TYPES, PAYMENT_STATUSES, type ServiceTypeKey, type PaymentStatusKey } from '@/config/operator-config';
import type { OperatorHistoryEntry } from '@/types';

interface OperatorDetail {
  id: string;
  requestId: string;
  supplierId: string | null;
  serviceDate: string | Date;
  serviceType: string;
  serviceName: string;
  supplier: string | null;
  costBeforeTax: number;
  vat: number | null;
  totalCost: number;
  paymentStatus: string;
  paidAmount: number;
  debt: number;  // Computed: totalCost - paidAmount
  paymentDeadline: Date | string | null;
  paymentDate: Date | null;
  bankAccount: string | null;
  notes: string | null;
  isLocked: boolean;
  lockedAt: Date | null;
  lockedBy: string | null;
  isArchived: boolean;
  archivedAt: Date | null;
  userId: string;
  sheetRowIndex: number | null;
  createdAt: Date;
  updatedAt: Date;
  request?: { code: string; customerName: string; status: string };
  supplierRef?: { code: string; name: string; paymentModel: string; bankAccount: string };
  history?: OperatorHistoryEntry[];
}

interface PageParams {
  id: string;
}

export default function OperatorDetailPage({ params }: { params: Promise<PageParams> }) {
  const { id } = use(params);
  const router = useRouter();

  const [operator, setOperator] = useState<OperatorDetail | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [deleting, setDeleting] = useState(false);
  const [unlocking, setUnlocking] = useState(false);
  const [unarchiving, setUnarchiving] = useState(false);

  // AbortController ref for race condition prevention
  const abortRef = useRef<AbortController | null>(null);

  // Safe params validation
  const isValidId = id && typeof id === 'string' && id.length > 0;

  useEffect(() => {
    if (isValidId) {
      // Cancel previous request
      abortRef.current?.abort();
      abortRef.current = new AbortController();
      fetchOperator(abortRef.current.signal);
    } else {
      setError('ID không hợp lệ');
      setLoading(false);
    }

    return () => {
      abortRef.current?.abort();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id, isValidId]);

  const fetchOperator = async (signal?: AbortSignal) => {
    setLoading(true);
    setError(null);

    const { data, error: fetchError } = await safeFetch<OperatorDetail>(
      `/api/operators/${id}`,
      { signal }
    );

    // Ignore if aborted
    if (signal?.aborted) return;

    if (fetchError) {
      setError(fetchError);
      setOperator(null);
    } else if (data) {
      setOperator(data);
    }
    setLoading(false);
  };

  const handleDelete = async () => {
    setDeleting(true);
    const { error: deleteError } = await safeDelete<void>(`/api/operators/${id}`);

    if (deleteError) {
      toast.error(deleteError);
      setDeleteDialogOpen(false);
    } else {
      router.push('/operators');
    }
    setDeleting(false);
  };

  const handleUnlock = async () => {
    setUnlocking(true);
    const { data, error: unlockError } = await safePost<{ success: boolean }>(
      `/api/operators/${id}/unlock`,
      { userId: 'current-user' }
    );

    if (unlockError) {
      toast.error(unlockError);
    } else if (data) {
      toast.success('Đã mở khóa dịch vụ');
      fetchOperator();
    }
    setUnlocking(false);
  };

  const handleUnarchive = async () => {
    setUnarchiving(true);
    const { data, error: unarchiveError } = await safePost<{ success: boolean; message: string }>(
      '/api/operators/unarchive',
      { ids: [id] }
    );

    if (unarchiveError) {
      toast.error(unarchiveError);
    } else if (data) {
      toast.success('Đã khôi phục dịch vụ');
      fetchOperator();
    }
    setUnarchiving(false);
  };

  const formatCurrency = (value: number) => {
    return new Intl.NumberFormat('vi-VN').format(value);
  };

  const formatDate = (date: string | Date | null) => {
    if (!date) return '-';
    return new Date(date).toLocaleDateString('vi-VN');
  };

  const getServiceTypeLabel = (type: string) => {
    return SERVICE_TYPES[type as ServiceTypeKey]?.label || type;
  };

  const getPaymentStatusInfo = (status: string) => {
    return PAYMENT_STATUSES[status as PaymentStatusKey] || { label: status, color: 'gray' };
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center min-h-[400px]">
        <div className="text-muted-foreground">Đang tải...</div>
      </div>
    );
  }

  if (error || !operator) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon" asChild>
            <Link href="/operators">
              <ArrowLeft className="h-5 w-5" />
            </Link>
          </Button>
          <h1 className="text-2xl font-bold">Chi tiết dịch vụ</h1>
        </div>
        <ErrorFallback
          title="Lỗi tải dịch vụ"
          message={error || 'Không tìm thấy dịch vụ'}
          onRetry={isValidId ? fetchOperator : undefined}
          onBack={() => router.push('/operators')}
          backLabel="Về danh sách"
          retryLabel="Thử lại"
        />
      </div>
    );
  }

  const paymentInfo = getPaymentStatusInfo(operator.paymentStatus);

  // Edit mode
  if (isEditing) {
    return (
      <div className="space-y-6">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon" onClick={() => setIsEditing(false)}>
            <ArrowLeft className="h-5 w-5" />
          </Button>
          <div>
            <h1 className="text-2xl font-bold flex items-center gap-2">
              <ClipboardList className="h-6 w-6" />
              Chỉnh sửa dịch vụ
            </h1>
            <p className="text-muted-foreground">{operator.serviceName}</p>
          </div>
        </div>

        <OperatorForm
          operator={operator}
          onSuccess={() => {
            setIsEditing(false);
            fetchOperator();
          }}
        />
      </div>
    );
  }

  // View mode
  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-4">
          <Button variant="ghost" size="icon" asChild>
            <Link href="/operators">
              <ArrowLeft className="h-5 w-5" />
            </Link>
          </Button>
          <div>
            <h1 className="text-2xl font-bold flex items-center gap-2">
              <ClipboardList className="h-6 w-6" />
              {operator.serviceName}
              {operator.isArchived && (
                <Badge variant="secondary" className="bg-gray-100 text-gray-600">
                  <Archive className="h-3 w-3 mr-1" />
                  Đã lưu trữ
                </Badge>
              )}
            </h1>
            <LockIndicator
              isLocked={operator.isLocked}
              lockedAt={operator.lockedAt}
              lockedBy={operator.lockedBy}
            />
            <p className="text-muted-foreground">
              Booking: {operator.request?.code || operator.requestId.slice(0, 8)}
              {operator.request?.customerName && ` - ${operator.request.customerName}`}
            </p>
          </div>
        </div>
        <div className="flex gap-2">
          {operator.isArchived ? (
            <Button variant="outline" onClick={handleUnarchive} disabled={unarchiving}>
              <ArchiveRestore className="mr-2 h-4 w-4" />
              {unarchiving ? 'Đang khôi phục...' : 'Khôi phục'}
            </Button>
          ) : operator.isLocked ? (
            <Button variant="outline" onClick={handleUnlock} disabled={unlocking}>
              <Unlock className="mr-2 h-4 w-4" />
              {unlocking ? 'Đang mở...' : 'Mở khóa'}
            </Button>
          ) : (
            <>
              <Button variant="outline" onClick={() => setIsEditing(true)}>
                <Edit className="mr-2 h-4 w-4" />
                Sửa
              </Button>
              <Button variant="destructive" onClick={() => setDeleteDialogOpen(true)}>
                <Trash2 className="mr-2 h-4 w-4" />
                Xóa
              </Button>
            </>
          )}
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Info */}
        <div className="lg:col-span-2 space-y-6">
          {/* Service Info */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <FileText className="h-5 w-5" />
                Thông tin dịch vụ
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <p className="text-sm text-muted-foreground">Loại dịch vụ</p>
                  <Badge variant="outline" className="mt-1">
                    {getServiceTypeLabel(operator.serviceType)}
                  </Badge>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Ngày dịch vụ</p>
                  <p className="font-medium flex items-center gap-2 mt-1">
                    <Calendar className="h-4 w-4" />
                    {formatDate(operator.serviceDate)}
                  </p>
                </div>
              </div>

              <div>
                <p className="text-sm text-muted-foreground">Tên dịch vụ</p>
                <p className="font-medium mt-1">{operator.serviceName}</p>
              </div>

              {operator.notes && (
                <div>
                  <p className="text-sm text-muted-foreground">Ghi chú</p>
                  <p className="mt-1 text-muted-foreground">{operator.notes}</p>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Supplier Info */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Building2 className="h-5 w-5" />
                Nhà cung cấp
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <p className="text-sm text-muted-foreground">Tên NCC</p>
                  {operator.supplierRef ? (
                    <Link
                      href={`/suppliers/${operator.supplierId}`}
                      className="font-medium text-primary hover:underline mt-1 block"
                    >
                      {operator.supplierRef.code} - {operator.supplierRef.name}
                    </Link>
                  ) : (
                    <p className="font-medium mt-1">{operator.supplier || '-'}</p>
                  )}
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">TK Ngân hàng</p>
                  <p className="font-medium mt-1">
                    {operator.bankAccount || operator.supplierRef?.bankAccount || '-'}
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Cost Info */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <CreditCard className="h-5 w-5" />
                Chi phí & Thanh toán
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-3 gap-4">
                <div>
                  <p className="text-sm text-muted-foreground">Chi phí trước thuế</p>
                  <p className="font-medium mt-1">{formatCurrency(operator.costBeforeTax)} ₫</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">VAT</p>
                  <p className="font-medium mt-1">
                    {operator.vat ? `${formatCurrency(operator.vat)} ₫` : '-'}
                  </p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Tổng chi phí</p>
                  <p className="font-bold text-lg text-primary mt-1">
                    {formatCurrency(operator.totalCost)} ₫
                  </p>
                </div>
              </div>

              <hr />

              <div className="grid grid-cols-4 gap-4">
                <div>
                  <p className="text-sm text-muted-foreground">Trạng thái TT</p>
                  <Badge
                    variant="outline"
                    className={`mt-1
                      ${paymentInfo.color === 'green' && 'border-green-500 text-green-600 bg-green-50'}
                      ${paymentInfo.color === 'yellow' && 'border-yellow-500 text-yellow-600 bg-yellow-50'}
                      ${paymentInfo.color === 'orange' && 'border-orange-500 text-orange-600 bg-orange-50'}
                    `}
                  >
                    {paymentInfo.label}
                  </Badge>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Đã thanh toán</p>
                  <p className="font-medium mt-1 text-green-600">
                    {formatCurrency(operator.paidAmount || 0)} ₫
                  </p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Còn nợ</p>
                  <p className={`font-bold mt-1 ${operator.debt > 0 ? 'text-red-600' : 'text-green-600'}`}>
                    {formatCurrency(operator.debt || 0)} ₫
                  </p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Hạn thanh toán</p>
                  <p className="font-medium mt-1">{formatDate(operator.paymentDeadline)}</p>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Sidebar - History */}
        <div>
          <OperatorHistoryPanel history={operator.history || []} />
        </div>
      </div>

      {/* Delete Dialog */}
      <Dialog open={deleteDialogOpen} onOpenChange={setDeleteDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Xác nhận xóa</DialogTitle>
            <DialogDescription>
              Bạn có chắc muốn xóa dịch vụ &quot;{operator.serviceName}&quot;?
              <br />
              Hành động này không thể hoàn tác.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setDeleteDialogOpen(false)}>
              Hủy
            </Button>
            <Button variant="destructive" onClick={handleDelete} disabled={deleting}>
              {deleting ? 'Đang xóa...' : 'Xóa'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="src/app/api/operators/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/db';
import { createOperatorHistory } from '@/lib/operator-history';
import { getSessionUser, unauthorizedResponse } from '@/lib/auth-utils';
import { generateServiceId } from '@/lib/id-utils';
import {
  createOperatorApiSchema,
  extractOperatorZodErrors,
} from '@/lib/validations/operator-validation';

// GET /api/operators - List with filters
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);

    // Extract filters
    const search = searchParams.get('search') || '';
    const requestId = searchParams.get('requestId') || '';
    const supplierId = searchParams.get('supplierId') || '';
    const serviceType = searchParams.get('serviceType') || '';
    const paymentStatus = searchParams.get('paymentStatus') || '';
    const fromDate = searchParams.get('fromDate') || '';
    const toDate = searchParams.get('toDate') || '';
    const isLocked = searchParams.get('isLocked');
    const includeArchived = searchParams.get('includeArchived') === 'true';
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');

    // Build where clause
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const where: Record<string, any> = {};

    // Default: exclude archived unless includeArchived=true
    if (!includeArchived) {
      where.isArchived = false;
    }

    if (search) {
      where.OR = [
        { serviceName: { contains: search, mode: 'insensitive' } },
        { supplier: { contains: search, mode: 'insensitive' } },
        { request: { code: { contains: search, mode: 'insensitive' } } },
        { request: { customerName: { contains: search, mode: 'insensitive' } } },
      ];
    }

    if (requestId) where.requestId = requestId;
    if (supplierId) where.supplierId = supplierId;
    if (serviceType) where.serviceType = serviceType;
    if (paymentStatus) where.paymentStatus = paymentStatus;
    if (isLocked !== null && isLocked !== '') {
      where.isLocked = isLocked === 'true';
    }

    if (fromDate || toDate) {
      where.serviceDate = {};
      if (fromDate) where.serviceDate.gte = new Date(fromDate);
      if (toDate) where.serviceDate.lte = new Date(toDate);
    }

    const [operators, total] = await Promise.all([
      prisma.operator.findMany({
        where,
        include: {
          request: { select: { code: true, customerName: true } },
          supplierRef: { select: { code: true, name: true } },
        },
        orderBy: { serviceDate: 'desc' },
        skip: offset,
        take: limit,
      }),
      prisma.operator.count({ where }),
    ]);

    // Add computed debt for each operator
    const operatorsWithDebt = operators.map((op) => ({
      ...op,
      debt: Number(op.totalCost) - Number(op.paidAmount),
    }));

    return NextResponse.json({
      success: true,
      data: operatorsWithDebt,
      total,
      hasMore: offset + operators.length < total,
    });
  } catch (error) {
    console.error('Error fetching operators:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tải danh sách: ${message}` },
      { status: 500 }
    );
  }
}

// POST /api/operators - Create operator
export async function POST(request: NextRequest) {
  try {
    // Verify authentication
    const user = await getSessionUser();
    if (!user) {
      return unauthorizedResponse();
    }

    const body = await request.json();

    // Validate with Zod schema
    const validation = createOperatorApiSchema.safeParse(body);
    if (!validation.success) {
      const errors = extractOperatorZodErrors(validation.error);
      return NextResponse.json(
        { success: false, error: 'Dữ liệu không hợp lệ', errors },
        { status: 400 }
      );
    }

    const validatedData = validation.data;

    // Validate request exists and is F5
    const req = await prisma.request.findUnique({
      where: { id: validatedData.requestId },
      select: { id: true, status: true, bookingCode: true, code: true },
    });

    if (!req) {
      return NextResponse.json(
        { success: false, error: 'Booking không tồn tại' },
        { status: 404 }
      );
    }

    if (req.status !== 'F5') {
      return NextResponse.json(
        { success: false, error: 'Chỉ có thể thêm dịch vụ cho Booking đã xác nhận (F5)' },
        { status: 400 }
      );
    }

    // Check duplicate service (same booking + serviceType + serviceDate)
    const serviceDate = new Date(validatedData.serviceDate);
    const startOfDay = new Date(serviceDate);
    startOfDay.setHours(0, 0, 0, 0);
    const endOfDay = new Date(serviceDate);
    endOfDay.setHours(23, 59, 59, 999);

    const existingService = await prisma.operator.findFirst({
      where: {
        requestId: validatedData.requestId,
        serviceType: validatedData.serviceType,
        serviceDate: { gte: startOfDay, lte: endOfDay },
      },
      select: { id: true, serviceName: true },
    });

    if (existingService) {
      return NextResponse.json(
        {
          success: false,
          error: `Đã có dịch vụ ${validatedData.serviceType} vào ngày này: "${existingService.serviceName}"`,
          errors: { serviceType: 'Dịch vụ trùng lặp' },
        },
        { status: 400 }
      );
    }

    // Generate serviceId from bookingCode (or fallback to request code)
    let serviceId: string | null = null;
    const bookingCode = req.bookingCode || req.code;
    if (bookingCode) {
      serviceId = await generateServiceId(bookingCode);
    }

    // Validate supplier if linked
    let supplierName = validatedData.supplier?.trim() || null;
    if (validatedData.supplierId) {
      const supplier = await prisma.supplier.findUnique({
        where: { id: validatedData.supplierId },
      });
      if (!supplier) {
        return NextResponse.json(
          { success: false, error: 'NCC không tồn tại' },
          { status: 404 }
        );
      }
      // Auto-fill supplier name if not provided
      if (!supplierName) {
        supplierName = supplier.name;
      }
    }

    // Extract validated costs (already validated by Zod)
    const costBeforeTax = validatedData.costBeforeTax;
    const vat = validatedData.vat ?? null;
    const totalCost = validatedData.totalCost;
    const paidAmount = validatedData.paidAmount;

    // Determine payment status based on paidAmount
    let paymentStatus = 'PENDING';
    if (paidAmount > 0 && paidAmount < totalCost) {
      paymentStatus = 'PARTIAL';
    } else if (paidAmount >= totalCost) {
      paymentStatus = 'PAID';
    }

    // Create operator with serviceId and lock fields initialized
    const operator = await prisma.operator.create({
      data: {
        requestId: validatedData.requestId,
        supplierId: validatedData.supplierId || null,
        serviceId, // Auto-generated from bookingCode
        serviceDate,
        serviceType: validatedData.serviceType,
        serviceName: validatedData.serviceName.trim(),
        supplier: supplierName,
        costBeforeTax,
        vat,
        totalCost,
        paidAmount,
        paymentStatus,
        paymentDeadline: validatedData.paymentDeadline ? new Date(validatedData.paymentDeadline) : null,
        bankAccount: validatedData.bankAccount?.trim() || null,
        notes: validatedData.notes?.trim() || null,
        userId: user.id,
        // Lock tiers default to false (from schema)
      },
      include: {
        request: { select: { code: true, customerName: true } },
        supplierRef: { select: { code: true, name: true } },
      },
    });

    // Create history entry
    await createOperatorHistory({
      operatorId: operator.id,
      action: 'CREATE',
      changes: { created: { before: null, after: { id: operator.id, serviceName: operator.serviceName } } },
      userId: user.id,
    });

    return NextResponse.json({ success: true, data: operator }, { status: 201 });
  } catch (error) {
    console.error('Error creating operator:', error);
    const message = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { success: false, error: `Lỗi tạo dịch vụ: ${message}` },
      { status: 500 }
    );
  }
}
</file>

<file path="src/lib/sheet-mappers.ts">
/**
 * Sheet Row Mappers
 *
 * Maps Google Sheet rows to database entities.
 * Column order must match actual Google Sheet structure.
 *
 * Customize column indices based on your sheet layout.
 */

import { prisma } from "@/lib/db";
import { Prisma } from "@prisma/client";

// Use Prisma.Decimal for type and constructor
const Decimal = Prisma.Decimal;

/**
 * Map Vietnamese status labels to enum keys
 * Must match REQUEST_STATUSES in src/config/request-config.ts
 */
const VIETNAMESE_TO_STATUS_KEY: Record<string, string> = {
  "Đang LL - khách chưa trả lời": "DANG_LL_CHUA_TL",
  "Đang LL - chưa trả lời": "DANG_LL_CHUA_TL",
  "Đang LL - khách đã trả lời": "DANG_LL_DA_TL",
  "Đang LL - đã trả lời": "DANG_LL_DA_TL",
  "Đã báo giá": "DA_BAO_GIA",
  "Đang xây Tour": "DANG_XAY_TOUR",
  "F1": "F1",
  "F2": "F2",
  "F3": "F3",
  "F4": "F4",
  "F4: Lần cuối": "F4",
  "Lần cuối": "F4",
  "Booking": "BOOKING",
  "Khách hoãn": "KHACH_HOAN",
  "Đang suy nghĩ": "KHACH_SUY_NGHI",
  "Không đủ TC": "KHONG_DU_TC",
  "Đã kết thúc": "DA_KET_THUC",
  "Cancel": "CANCEL",
};

/**
 * Convert Vietnamese status label to enum key
 */
function mapVietnameseToStatusKey(vietnameseLabel: string | undefined): string {
  if (!vietnameseLabel?.trim()) return "DANG_LL_CHUA_TL";
  return VIETNAMESE_TO_STATUS_KEY[vietnameseLabel.trim()] || "DANG_LL_CHUA_TL";
}

/**
 * Parse number from sheet cell, handling Vietnamese number format
 */
function parseNumber(value: string | undefined): number | null {
  if (!value?.trim()) return null;
  // Remove dots (thousand sep) and replace comma (decimal sep)
  const cleaned = value.replace(/\./g, "").replace(",", ".");
  const num = parseFloat(cleaned);
  return isNaN(num) ? null : num;
}

/**
 * Parse date from sheet cell
 * Supports: DD/MM/YYYY, YYYY-MM-DD, MM/DD/YYYY, Excel serial dates
 */
function parseDate(value: string | undefined): Date | null {
  if (!value?.trim()) return null;

  // Try DD/MM/YYYY (Vietnamese format)
  const dmyMatch = value.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if (dmyMatch) {
    const [, day, month, year] = dmyMatch;
    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
  }

  // Try YYYY-MM-DD (ISO format)
  const isoMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (isoMatch) {
    return new Date(value);
  }

  // Try ISO datetime format (YYYY-MM-DDTHH:mm:ss.sssZ)
  const isoDateTimeMatch = value.match(/^(\d{4})-(\d{2})-(\d{2})T/);
  if (isoDateTimeMatch) {
    return new Date(value);
  }

  // Try Excel serial date (number between 1 and 100000 typically)
  const serialNum = parseFloat(value);
  if (!isNaN(serialNum) && serialNum > 1 && serialNum < 100000) {
    // Excel serial date: days since 1899-12-30 (Excel epoch)
    // Need to subtract 1 because Excel incorrectly counts 1900 as leap year
    const excelEpoch = new Date(1899, 11, 30);
    const date = new Date(excelEpoch.getTime() + serialNum * 24 * 60 * 60 * 1000);
    return date;
  }

  // Fallback to Date.parse
  const parsed = new Date(value);
  return isNaN(parsed.getTime()) ? null : parsed;
}

/**
 * Map status text to stage
 */
function mapStatusToStage(status: string): string {
  const normalized = status?.toLowerCase().trim() || "";

  // LEAD stage statuses
  if (
    normalized.includes("mới") ||
    normalized.includes("chưa trả lời") ||
    normalized.includes("đang ll")
  ) {
    return "LEAD";
  }

  // QUOTE stage
  if (normalized.includes("báo giá") || normalized.includes("xây tour")) {
    return "QUOTE";
  }

  // FOLLOWUP stage
  if (
    normalized.includes("f1") ||
    normalized.includes("f2") ||
    normalized.includes("f3") ||
    normalized.includes("f4") ||
    normalized.includes("suy nghĩ")
  ) {
    return "FOLLOWUP";
  }

  // OUTCOME stage
  if (
    normalized.includes("booking") ||
    normalized.includes("kết thúc") ||
    normalized.includes("cancel") ||
    normalized.includes("hoãn")
  ) {
    return "OUTCOME";
  }

  return "LEAD";
}

/**
 * Request data ready for upsert
 */
export interface RequestRowData {
  code: string;  // Request ID from column AR - unique sync key
  bookingCode: string | null;  // Booking code from column T - for Operator/Revenue linking
  customerName: string;
  contact: string;
  country: string;
  source: string;
  status: string;
  stage: string;
  pax: number;
  tourDays: number | null;
  startDate: Date | null;
  endDate: Date | null;
  expectedRevenue: Prisma.Decimal | null;
  expectedCost: Prisma.Decimal | null;
  notes: string | null;
  sellerId: string;
  sheetRowIndex: number;
}

/**
 * Map Request sheet row to database fields
 *
 * Syncs ALL rows where Request ID (AR) is not empty.
 * Uses Request ID as unique sync key, booking code for Operator/Revenue linking.
 *
 * Actual columns from Google Sheet:
 * A(0): Seller (REQUIRED)
 * B(1): Name (customerName, REQUIRED)
 * C(2): Contact
 * E(4): Pax
 * F(5): Quốc gia (country)
 * G(6): Nguồn (source)
 * H(7): Trạng thái (status - Vietnamese labels)
 * J(9): Số ngày đi Tour (tourDays)
 * K(10): Ngày dự kiến đi (startDate)
 * L(11): DT dự kiến (expectedRevenue)
 * M(12): Chi phí dự kiến (expectedCost)
 * N(13): Ghi chú (notes)
 * T(19): Mã khách (bookingCode) - for Operator/Revenue linking
 * Z(25): Ngày dự kiến kết thúc (endDate)
 * AR(43): Request ID - UNIQUE SYNC KEY
 */
export async function mapRequestRow(
  row: string[],
  rowIndex: number
): Promise<RequestRowData | null> {
  // Extract by actual column indices
  const sellerName = row[0];     // A: Seller
  const customerName = row[1];   // B: Name
  const contact = row[2];        // C: Contact
  const pax = row[4];            // E: Pax
  const country = row[5];        // F: Quốc gia
  const source = row[6];         // G: Nguồn
  const status = row[7];         // H: Trạng thái
  const tourDays = row[9];       // J: Số ngày đi Tour
  const startDate = row[10];     // K: Ngày dự kiến đi
  const expectedRevenue = row[11]; // L: DT dự kiến
  const expectedCost = row[12];  // M: Chi phí dự kiến
  const notes = row[13];         // N: Ghi chú
  const bookingCode = row[19];   // T: Mã khách (for Operator/Revenue linking)
  const endDate = row[25];       // Z: Ngày dự kiến kết thúc
  const requestId = row[43];     // AR: Request ID - UNIQUE SYNC KEY

  // Skip if no Request ID (required for all rows)
  if (!requestId?.trim()) {
    return null;
  }

  // Skip header rows
  if (requestId === "Request ID" || sellerName === "Seller") {
    return null;
  }

  // Skip if no seller (required)
  if (!sellerName?.trim()) {
    return null;
  }

  // Skip if no customer name (required)
  if (!customerName?.trim() || customerName === "Name") {
    return null;
  }

  // Find seller by name or use default
  let seller = await prisma.user.findFirst({
    where: {
      role: "SELLER",
      name: { contains: sellerName?.trim() || "", mode: "insensitive" },
    },
  });

  // Fallback to first SELLER user if not found
  if (!seller) {
    seller = await prisma.user.findFirst({ where: { role: "SELLER" } });
  }

  if (!seller) {
    throw new Error("No SELLER user found for import");
  }

  const revNum = parseNumber(expectedRevenue);
  const costNum = parseNumber(expectedCost);

  return {
    code: requestId.trim(),  // Use Request ID as unique sync key
    bookingCode: bookingCode?.trim() || null,  // For Operator/Revenue linking
    customerName: customerName.trim(),
    contact: contact?.trim() || "",
    country: country?.trim() || "Unknown",
    source: source?.trim() || "Other",
    status: mapVietnameseToStatusKey(status),  // Map Vietnamese to enum key
    stage: mapStatusToStage(status),
    pax: parseInt(pax) || 1,
    tourDays: parseNumber(tourDays) ? Math.round(parseNumber(tourDays)!) : null,
    startDate: parseDate(startDate),
    endDate: parseDate(endDate),
    expectedRevenue: revNum !== null ? new Decimal(revNum) : null,
    expectedCost: costNum !== null ? new Decimal(costNum) : null,
    notes: notes?.trim() || null,
    sellerId: seller.id,
    sheetRowIndex: rowIndex,
  };
}

/**
 * Operator data ready for upsert
 */
export interface OperatorRowData {
  requestCode: string;
  serviceDate: Date;
  serviceType: string;
  serviceName: string;
  supplier: string | null;
  costBeforeTax: Prisma.Decimal;
  vat: Prisma.Decimal | null;
  totalCost: Prisma.Decimal;
  paymentStatus: string;
  notes: string | null;
  userId: string;
  sheetRowIndex: number;
}

/**
 * Map Operator sheet row to database fields
 *
 * Actual columns from Google Sheet:
 * A(0): Mã khách (requestCode)
 * J(9): Ngày sử dụng dịch vụ (serviceDate)
 * K(10): Loại dịch vụ (serviceType/serviceName)
 * O(14): Chi phí dự kiến trước thuế (costBeforeTax)
 * P(15): Thuế VAT (vat)
 * Q(16): Chi phí dự kiến (totalCost)
 * S(18): Tài khoản thanh toán (supplier - payment account)
 * T(19): Ghi chú (notes)
 * W(22): Dư nợ (remaining balance → paymentStatus)
 */
export async function mapOperatorRow(
  row: string[],
  rowIndex: number
): Promise<OperatorRowData | null> {
  // Extract by actual column indices
  const requestCode = row[0]; // A: Mã khách
  const serviceDate = row[9]; // J: Ngày sử dụng dịch vụ
  const serviceType = row[10]; // K: Loại dịch vụ
  const costBeforeTax = row[14]; // O: Chi phí dự kiến trước thuế
  const vat = row[15]; // P: Thuế VAT
  const totalCost = row[16]; // Q: Chi phí dự kiến
  const supplier = row[18]; // S: Tài khoản thanh toán
  const notes = row[19]; // T: Ghi chú
  const remainingBalance = row[22]; // W: Dư nợ

  // Skip empty rows or header rows
  if (!requestCode?.trim() || requestCode === "Mã khách") {
    return null;
  }

  // Skip if no service type (required field)
  if (!serviceType?.trim()) {
    return null;
  }

  const parsedDate = parseDate(serviceDate);
  if (!parsedDate) {
    return null;
  }

  // Find default operator user
  const operatorUser = await prisma.user.findFirst({
    where: { role: "OPERATOR" },
  });
  if (!operatorUser) {
    throw new Error("No OPERATOR user found for import");
  }

  const cost = parseNumber(costBeforeTax) || 0;
  const vatNum = parseNumber(vat);
  const total = parseNumber(totalCost) || cost;

  // Determine payment status from remaining balance
  const balance = parseNumber(remainingBalance);
  const paymentStatus =
    balance === null || balance === 0 ? "PAID" : "PENDING";

  return {
    requestCode: requestCode.trim(),
    serviceDate: parsedDate,
    serviceType: serviceType.trim(),
    serviceName: serviceType.trim(), // Use serviceType as serviceName
    supplier: supplier?.trim() || null,
    costBeforeTax: new Decimal(cost),
    vat: vatNum !== null ? new Decimal(vatNum) : null,
    totalCost: new Decimal(total),
    paymentStatus,
    notes: notes?.trim() || null,
    userId: operatorUser.id,
    sheetRowIndex: rowIndex,
  };
}

/**
 * Revenue data ready for upsert
 */
export interface RevenueRowData {
  requestCode: string;
  paymentDate: Date;
  paymentType: string;
  foreignAmount: Prisma.Decimal | null;
  currency: string;
  exchangeRate: Prisma.Decimal | null;
  amountVND: Prisma.Decimal;
  paymentSource: string;
  notes: string | null;
  userId: string;
  sheetRowIndex: number;
}

/**
 * Map Revenue sheet row to database fields
 *
 * Actual columns from Google Sheet (note: row 1 is blank, row 2 is headers):
 * A(0): Code (requestCode)
 * L(11): Khoản thu (paymentType)
 * M(12): Ngày thu tiền (paymentDate)
 * N(13): Nguồn thu (paymentSource)
 * Q(16): Thu ngoại tệ (foreignAmount)
 * R(17): Tỷ giá (exchangeRate)
 * S(18): Loại Ngoại tệ (currency)
 * T(19): Tổng tiền Thu (amountVND)
 */
export async function mapRevenueRow(
  row: string[],
  rowIndex: number
): Promise<RevenueRowData | null> {
  // Extract by actual column indices
  const requestCode = row[0]; // A: Code
  const paymentType = row[11]; // L: Khoản thu
  const paymentDate = row[12]; // M: Ngày thu tiền
  const paymentSource = row[13]; // N: Nguồn thu
  const foreignAmount = row[16]; // Q: Thu ngoại tệ
  const exchangeRate = row[17]; // R: Tỷ giá
  const currency = row[18]; // S: Loại Ngoại tệ
  const amountVND = row[19]; // T: Tổng tiền Thu

  // Skip empty rows or header rows
  if (!requestCode?.trim() || requestCode === "Code") {
    return null;
  }

  const parsedDate = parseDate(paymentDate);
  if (!parsedDate) {
    return null;
  }

  // Find default accountant user
  const accountant = await prisma.user.findFirst({
    where: { role: "ACCOUNTANT" },
  });
  if (!accountant) {
    throw new Error("No ACCOUNTANT user found for import");
  }

  const foreignNum = parseNumber(foreignAmount);
  const rateNum = parseNumber(exchangeRate);
  const vndNum = parseNumber(amountVND) || 0;

  return {
    requestCode: requestCode.trim(),
    paymentDate: parsedDate,
    paymentType: paymentType?.trim() || "Deposit",
    foreignAmount: foreignNum !== null ? new Decimal(foreignNum) : null,
    currency: currency?.trim() || "VND",
    exchangeRate: rateNum !== null ? new Decimal(rateNum) : null,
    amountVND: new Decimal(vndNum),
    paymentSource: paymentSource?.trim() || "Bank transfer",
    notes: null, // No notes column in this sheet
    userId: accountant.id,
    sheetRowIndex: rowIndex,
  };
}
</file>

<file path="src/app/(dashboard)/requests/[id]/edit/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { toast } from 'sonner';
import { Button } from '@/components/ui/button';
import { ArrowLeft, AlertTriangle, RefreshCw } from 'lucide-react';
import { RequestForm, RequestStatusBadge } from '@/components/requests';
import { safeFetch, safePut } from '@/lib/api/fetch-utils';
import type { Request, RequestFormData, RequestStatus } from '@/types';

/**
 * Edit page for request - full form editing mode.
 * Navigates back to /requests?id=[id] on cancel/save.
 */
export default function RequestEditPage() {
  const router = useRouter();
  const params = useParams();

  // ALL hooks MUST be declared before any conditional returns
  const [request, setRequest] = useState<Request | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Safe params validation - handle undefined or array
  const rawId = params.id;
  const id = typeof rawId === 'string' ? rawId : Array.isArray(rawId) ? rawId[0] : '';

  // Redirect effect for invalid ID (replaces early return)
  useEffect(() => {
    if (!id) {
      router.replace('/requests');
    }
  }, [id, router]);

  const fetchRequest = async () => {
    setLoading(true);
    setError(null);

    const { data, error: fetchError, status } = await safeFetch<Request>(`/api/requests/${id}`);

    if (fetchError) {
      if (status === 404) {
        router.replace('/requests');
      } else {
        setError(fetchError);
      }
    } else if (data) {
      setRequest(data);
    }

    setLoading(false);
  };

  useEffect(() => {
    if (id) {
      void fetchRequest();
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id]);

  // Early return for invalid ID (after all hooks)
  if (!id) {
    return null;
  }

  const handleUpdate = async (data: RequestFormData) => {
    const { error: updateError } = await safePut<Request>(`/api/requests/${id}`, data);

    if (updateError) {
      toast.error(`Có lỗi xảy ra: ${updateError}`);
      throw new Error(updateError);
    }

    toast.success('Đã cập nhật yêu cầu');
    // Navigate back to requests list with this request selected
    router.push(`/requests?id=${id}`);
  };

  const handleCancel = () => {
    router.push(`/requests?id=${id}`);
  };

  if (loading) {
    return <div className="p-8 text-center text-muted-foreground">Đang tải...</div>;
  }

  if (error) {
    return (
      <div className="p-8 flex flex-col items-center justify-center">
        <AlertTriangle className="h-12 w-12 text-destructive mb-3" />
        <p className="text-lg font-medium text-destructive mb-2">Lỗi tải dữ liệu</p>
        <p className="text-sm text-muted-foreground mb-4">{error}</p>
        <div className="flex gap-3">
          <Button variant="outline" onClick={handleCancel}>
            <ArrowLeft className="h-4 w-4 mr-2" />
            Quay lại
          </Button>
          <Button variant="outline" onClick={fetchRequest}>
            <RefreshCw className="h-4 w-4 mr-2" />
            Thử lại
          </Button>
        </div>
      </div>
    );
  }

  if (!request) {
    return <div className="p-8 text-center text-muted-foreground">Không tìm thấy yêu cầu</div>;
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center gap-4">
        <Button variant="ghost" size="icon" onClick={handleCancel}>
          <ArrowLeft className="w-4 h-4" />
        </Button>
        <div>
          <div className="flex items-center gap-3">
            <h1 className="text-2xl font-bold">Chỉnh sửa: {request.rqid || request.code}</h1>
            <RequestStatusBadge status={request.status as RequestStatus} showStage />
          </div>
          <p className="text-muted-foreground">{request.customerName}</p>
        </div>
      </div>

      {/* Edit Form */}
      <RequestForm
        initialData={request}
        onSubmit={handleUpdate}
        onCancel={handleCancel}
        isEditing
      />
    </div>
  );
}
</file>

<file path="src/app/(dashboard)/requests/page.tsx">
'use client';

import { useState, useEffect, useCallback, Suspense, useRef } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Plus } from 'lucide-react';
import {
  RequestListPanel,
  RequestDetailPanel,
  RequestFilters,
} from '@/components/requests';
import { safeFetch } from '@/lib/api/fetch-utils';
import type { Request, RequestFilters as FiltersType, Operator, User } from '@/types';

// Extended request type with relations
interface RequestWithDetails extends Request {
  operators?: Operator[];
  seller?: User;
  _count?: { operators?: number; revenues?: number };
}

/**
 * Main requests page content with 2-panel layout.
 * Left panel: search + list, Right panel: selected request details.
 */
function RequestsPageContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const selectedId = searchParams.get('id');

  // List state
  const [requests, setRequests] = useState<Request[]>([]);
  const [listLoading, setListLoading] = useState(true);
  const [searchInput, setSearchInput] = useState(''); // Local search input for debouncing
  const [filters, setFilters] = useState<FiltersType>({
    search: '',
    stage: '',
    status: '',
    seller: '',
    fromDate: '',
    toDate: '',
  });

  // Pagination state
  const [total, setTotal] = useState(0);
  const [hasMore, setHasMore] = useState(false);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const LIMIT = 50;

  // Detail state
  const [selectedRequest, setSelectedRequest] = useState<RequestWithDetails | null>(null);
  const [detailLoading, setDetailLoading] = useState(false);
  const [detailError, setDetailError] = useState<string | null>(null);

  // List error state
  const [listError, setListError] = useState<string | null>(null);
  const [loadMoreError, setLoadMoreError] = useState<string | null>(null);

  // Permission state
  const [canViewAll, setCanViewAll] = useState(false);
  const [sellers, setSellers] = useState<User[]>([]);

  // AbortController refs for race condition prevention
  const listAbortRef = useRef<AbortController | null>(null);
  const detailAbortRef = useRef<AbortController | null>(null);

  // Build query params for requests API
  const buildQueryParams = useCallback((offset = 0) => {
    const params = new URLSearchParams();
    if (filters.search) params.set('search', filters.search);
    if (filters.stage) params.set('stage', filters.stage);
    if (filters.status) params.set('status', filters.status);
    if (filters.seller) params.set('sellerId', filters.seller);
    if (filters.fromDate) params.set('fromDate', filters.fromDate);
    if (filters.toDate) params.set('toDate', filters.toDate);
    params.set('limit', String(LIMIT));
    params.set('offset', String(offset));
    return params;
  }, [filters]);

  // API response type for list
  interface ListResponse {
    data: Request[];
    total: number;
    hasMore: boolean;
  }

  // Fetch requests list with filters (initial load / filter change)
  const fetchRequests = useCallback(async (signal?: AbortSignal) => {
    setListLoading(true);
    setListError(null);

    const params = buildQueryParams(0);
    const { data, error } = await safeFetch<ListResponse>(`/api/requests?${params}`, { signal });

    // Ignore if aborted
    if (signal?.aborted) return;

    if (error) {
      setListError(error);
      setRequests([]);
    } else if (data) {
      setRequests(data.data || []);
      setTotal(data.total || 0);
      setHasMore(data.hasMore || false);
    }

    setListLoading(false);
  }, [buildQueryParams]);

  // Load more requests (infinite scroll)
  const loadMore = useCallback(async () => {
    if (isLoadingMore || !hasMore) return;

    setIsLoadingMore(true);
    setLoadMoreError(null);

    const newOffset = requests.length;
    const params = buildQueryParams(newOffset);
    const { data, error } = await safeFetch<ListResponse>(`/api/requests?${params}`);

    if (error) {
      setLoadMoreError(error);
    } else if (data) {
      setRequests((prev) => [...prev, ...(data.data || [])]);
      setHasMore(data.hasMore || false);
    }

    setIsLoadingMore(false);
  }, [buildQueryParams, hasMore, isLoadingMore, requests.length]);

  // Fetch selected request details
  const fetchRequestDetail = useCallback(async (id: string, signal?: AbortSignal) => {
    setDetailLoading(true);
    setDetailError(null);

    const { data, error, status } = await safeFetch<RequestWithDetails>(`/api/requests/${id}`, { signal });

    // Ignore if aborted
    if (signal?.aborted) return;

    if (error) {
      // For 404, redirect to list; for others, show error
      if (status === 404) {
        setSelectedRequest(null);
        router.replace('/requests');
      } else {
        setDetailError(error);
        setSelectedRequest(null);
      }
    } else if (data) {
      setSelectedRequest(data);
    }

    setDetailLoading(false);
  }, [router]);

  // Init: check permissions and fetch sellers
  useEffect(() => {
    async function init() {
      const { data: configData } = await safeFetch<{ canViewAll: boolean }>('/api/config/user/me');
      if (configData?.canViewAll) {
        setCanViewAll(true);
        const { data: sellersData } = await safeFetch<User[]>('/api/users?role=SELLER');
        if (sellersData) setSellers(sellersData);
      }
    }
    void init();
  }, []);

  // Debounced search: update filters.search after 300ms delay
  useEffect(() => {
    const timer = setTimeout(() => {
      setFilters(prev => ({ ...prev, search: searchInput }));
    }, 300);
    return () => clearTimeout(timer);
  }, [searchInput]);

  // Fetch list on filter change
  useEffect(() => {
    // Cancel previous request
    listAbortRef.current?.abort();
    listAbortRef.current = new AbortController();

    void fetchRequests(listAbortRef.current.signal);

    return () => {
      listAbortRef.current?.abort();
    };
  }, [fetchRequests]);

  // Fetch detail when selection changes
  useEffect(() => {
    // Cancel previous request
    detailAbortRef.current?.abort();

    if (selectedId) {
      detailAbortRef.current = new AbortController();
      // eslint-disable-next-line react-hooks/set-state-in-effect -- async fetch pattern is valid
      void fetchRequestDetail(selectedId, detailAbortRef.current.signal);
    } else {
      setSelectedRequest(null);
    }

    return () => {
      detailAbortRef.current?.abort();
    };
  }, [selectedId, fetchRequestDetail]);

  // Handle request selection - update URL
  const handleSelect = (id: string) => {
    router.push(`/requests?id=${id}`, { scroll: false });
  };

  // Handle search change from list panel - update local state for debouncing
  const handleSearchChange = (value: string) => {
    setSearchInput(value);
  };

  // Handle edit button click - navigate to edit page
  const handleEditClick = () => {
    if (selectedId) {
      router.push(`/requests/${selectedId}/edit`);
    }
  };

  // Handle refresh - reload current request details
  const handleRefresh = () => {
    if (selectedId) {
      fetchRequestDetail(selectedId);
    }
  };

  return (
    <div className="h-[calc(100vh-4rem)] flex flex-col">
      {/* Header */}
      <div className="flex justify-between items-center p-4 border-b">
        <div>
          <h1 className="text-2xl font-bold">Yêu cầu</h1>
          <p className="text-muted-foreground">Quản lý yêu cầu khách hàng</p>
        </div>
        <Button onClick={() => router.push('/requests/create')}>
          <Plus className="w-4 h-4 mr-2" />
          Thêm yêu cầu
        </Button>
      </div>

      {/* Filters */}
      <div className="border-b">
        <RequestFilters
          filters={filters}
          onChange={setFilters}
          sellers={sellers}
          showSellerFilter={canViewAll}
        />
      </div>

      {/* 2-Panel Layout */}
      <div className="flex-1 flex overflow-hidden">
        <RequestListPanel
          requests={requests}
          selectedId={selectedId}
          onSelect={handleSelect}
          isLoading={listLoading}
          searchValue={searchInput}
          onSearchChange={handleSearchChange}
          error={listError}
          onRetry={fetchRequests}
          total={total}
          hasMore={hasMore}
          isLoadingMore={isLoadingMore}
          loadMoreError={loadMoreError}
          onLoadMore={loadMore}
        />
        <RequestDetailPanel
          request={selectedRequest}
          isLoading={detailLoading}
          error={detailError}
          onEditClick={handleEditClick}
          onRefresh={handleRefresh}
        />
      </div>
    </div>
  );
}

/**
 * Requests page with Suspense boundary for useSearchParams
 */
export default function RequestsPage() {
  return (
    <Suspense fallback={<div className="p-4">Đang tải...</div>}>
      <RequestsPageContent />
    </Suspense>
  );
}
</file>

<file path="src/components/requests/request-detail-panel.tsx">
'use client';

import { useEffect, useState, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { RequestStatusBadge } from './request-status-badge';
import { RequestServicesTable } from './request-services-table';
import { RevenueTable, RevenueForm, RevenueSummaryCard } from '@/components/revenues';
import { usePermission } from '@/hooks/use-permission';
import { Edit, Plus, AlertTriangle, RefreshCw } from 'lucide-react';
import { formatDate, formatCurrency } from '@/lib/utils';
import type { Request, RequestStatus, Operator, User } from '@/types';

// Revenue type from API (includes all fields needed by both RevenueTable and RevenueForm)
interface RevenueFromApi {
  id: string;
  requestId: string;
  paymentDate: Date | string;
  paymentType: string;
  foreignAmount?: number | null;
  currency?: string | null;
  exchangeRate?: number | null;
  amountVND: number;
  paymentSource: string;
  notes?: string | null;
  // 3-tier lock fields
  lockKT: boolean;
  lockAdmin: boolean;
  lockFinal: boolean;
  // Legacy field for backward compatibility
  isLocked?: boolean;
  lockedAt?: Date | string | null;
  lockedBy?: string | null;
  request?: {
    code: string;
    customerName: string;
    bookingCode?: string | null;
  };
}

// Extended request type with optional relations
interface RequestWithDetails extends Request {
  operators?: Operator[];
  seller?: User;
  _count?: { operators?: number; revenues?: number };
}

interface RequestDetailPanelProps {
  request: RequestWithDetails | null;
  isLoading: boolean;
  error?: string | null;
  onEditClick?: () => void;
  onRefresh: () => void;
}

/**
 * Skeleton loader for detail panel loading state
 */
function DetailSkeleton() {
  return (
    <div className="flex-1 p-6 space-y-6">
      <div className="flex justify-between items-start">
        <div className="space-y-2">
          <div className="h-8 bg-muted rounded w-48 animate-pulse" />
          <div className="h-4 bg-muted rounded w-32 animate-pulse" />
        </div>
        <div className="h-10 bg-muted rounded w-28 animate-pulse" />
      </div>

      <div className="h-32 bg-muted rounded animate-pulse" />
      <div className="h-40 bg-muted rounded animate-pulse" />
      <div className="h-40 bg-muted rounded animate-pulse" />
    </div>
  );
}

/**
 * Right panel showing full request details.
 * Shows empty state when no request selected.
 */
export function RequestDetailPanel({
  request,
  isLoading,
  error,
  onEditClick,
  onRefresh,
}: RequestDetailPanelProps) {
  // Permission hooks
  const { can, isAdmin } = usePermission();

  // Revenue state
  const [revenues, setRevenues] = useState<RevenueFromApi[]>([]);
  const [editingRevenue, setEditingRevenue] = useState<RevenueFromApi | null>(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [loadingRevenues, setLoadingRevenues] = useState(false);
  const [revenueError, setRevenueError] = useState<string | null>(null);

  // Fetch revenues for this request
  const fetchRevenues = useCallback(async () => {
    if (!request?.id || !request?.bookingCode) {
      setRevenues([]);
      return;
    }
    setLoadingRevenues(true);
    setRevenueError(null);
    try {
      const res = await fetch(`/api/revenues?requestId=${request.id}`);
      const data = await res.json();
      if (data.success) {
        setRevenues(data.data || []);
      } else {
        setRevenueError(data.error || 'Không thể tải doanh thu');
      }
    } catch (err) {
      console.error('Error fetching revenues:', err);
      setRevenueError('Không thể kết nối đến máy chủ');
    } finally {
      setLoadingRevenues(false);
    }
  }, [request?.id, request?.bookingCode]);

  // Fetch revenues when request changes
  useEffect(() => {
    fetchRevenues();
  }, [fetchRevenues]);

  // Revenue handlers
  const handleAddRevenue = useCallback(() => {
    setEditingRevenue(null);
    setDialogOpen(true);
  }, []);

  const handleEditRevenue = useCallback((revenue: RevenueFromApi) => {
    setEditingRevenue(revenue);
    setDialogOpen(true);
  }, []);

  const handleDialogClose = useCallback(() => {
    setDialogOpen(false);
    setEditingRevenue(null);
  }, []);

  const handleRevenueSuccess = useCallback(() => {
    handleDialogClose();
    fetchRevenues();
  }, [handleDialogClose, fetchRevenues]);

  // Loading state
  if (isLoading) {
    return <DetailSkeleton />;
  }

  // Error state
  if (error) {
    return (
      <div className="flex-1 flex items-center justify-center">
        <div className="text-center">
          <AlertTriangle className="h-12 w-12 text-destructive mx-auto mb-3" />
          <p className="text-lg font-medium text-destructive mb-2">
            Không thể tải chi tiết
          </p>
          <p className="text-sm text-muted-foreground mb-4">{error}</p>
          <Button variant="outline" onClick={onRefresh}>
            <RefreshCw className="h-4 w-4 mr-2" />
            Thử lại
          </Button>
        </div>
      </div>
    );
  }

  // Empty state - no request selected
  if (!request) {
    return (
      <div className="flex-1 flex items-center justify-center text-muted-foreground">
        <div className="text-center">
          <p className="text-lg">Chọn yêu cầu từ danh sách</p>
          <p className="text-sm mt-1">để xem chi tiết</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex-1 overflow-auto p-6 space-y-6">
      {/* Header with ID, status, and edit button */}
      <div className="flex justify-between items-start">
        <div>
          <div className="flex items-center gap-3">
            <h2 className="text-2xl font-bold font-mono">
              {request.bookingCode || request.rqid || request.code}
            </h2>
            <RequestStatusBadge status={request.status as RequestStatus} showStage />
          </div>
          <p className="text-muted-foreground">{request.customerName}</p>
        </div>
        {onEditClick && (
          <Button variant="outline" onClick={onEditClick}>
            <Edit className="w-4 h-4 mr-2" />
            Chỉnh sửa
          </Button>
        )}
      </div>

      {/* Booking Code Banner - show prominently when has booking */}
      {request.bookingCode && (
        <Card className="bg-green-50 border-green-200 dark:bg-green-950 dark:border-green-800">
          <CardContent className="py-4">
            <p className="text-sm text-green-600 dark:text-green-400">Mã Booking</p>
            <p className="text-2xl font-mono font-bold text-green-700 dark:text-green-300">
              {request.bookingCode}
            </p>
          </CardContent>
        </Card>
      )}

      {/* Customer Info Card */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin khách hàng</CardTitle>
        </CardHeader>
        <CardContent className="grid grid-cols-2 gap-4">
          <InfoRow label="Tên" value={request.customerName} />
          <InfoRow label="Liên hệ" value={request.contact} />
          <InfoRow label="WhatsApp" value={request.whatsapp || '-'} />
          <InfoRow label="Pax" value={String(request.pax)} />
          <InfoRow label="Quốc gia" value={request.country} />
          <InfoRow label="Nguồn" value={request.source} />
        </CardContent>
      </Card>

      {/* Tour Info Card */}
      <Card>
        <CardHeader>
          <CardTitle>Thông tin Tour</CardTitle>
        </CardHeader>
        <CardContent className="grid grid-cols-2 gap-4">
          <InfoRow label="Số ngày" value={request.tourDays?.toString() || '-'} />
          <InfoRow
            label="Ngày bắt đầu"
            value={request.startDate ? formatDate(request.startDate) : '-'}
          />
          <InfoRow
            label="Ngày kết thúc"
            value={request.endDate ? formatDate(request.endDate) : '-'}
          />
          <InfoRow
            label="Doanh thu DK"
            value={request.expectedRevenue ? formatCurrency(request.expectedRevenue) + ' ₫' : '-'}
          />
          <InfoRow
            label="Chi phí DK"
            value={request.expectedCost ? formatCurrency(request.expectedCost) + ' ₫' : '-'}
          />
          <InfoRow label="Seller" value={request.seller?.name || '-'} />
        </CardContent>
      </Card>

      {/* Services Table - inline editable for bookings */}
      {request.bookingCode && (
        <Card>
          <CardHeader>
            <CardTitle>Dịch vụ ({request.operators?.length || 0})</CardTitle>
          </CardHeader>
          <CardContent>
            <RequestServicesTable
              requestId={request.id}
              operators={request.operators || []}
              onUpdate={onRefresh}
            />
          </CardContent>
        </Card>
      )}

      {/* Revenue Section - only for bookings with permission */}
      {request.bookingCode && can('revenue:view') && (
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0">
            <CardTitle>Doanh thu ({revenues.length})</CardTitle>
            {can('revenue:manage') && (
              <Button variant="outline" size="sm" onClick={handleAddRevenue}>
                <Plus className="w-4 h-4 mr-2" />
                Thêm thu nhập
              </Button>
            )}
          </CardHeader>
          <CardContent className="space-y-4">
            {loadingRevenues ? (
              <div className="text-center py-4 text-muted-foreground">
                Đang tải dữ liệu...
              </div>
            ) : revenueError ? (
              <div className="text-center py-4">
                <p className="text-sm text-destructive mb-2">{revenueError}</p>
                <Button variant="ghost" size="sm" onClick={fetchRevenues}>
                  <RefreshCw className="h-4 w-4 mr-2" />
                  Thử lại
                </Button>
              </div>
            ) : (
              <>
                {revenues.length > 0 && (
                  <RevenueSummaryCard revenues={revenues} />
                )}
                <RevenueTable
                  revenues={revenues}
                  onEdit={(rev) => handleEditRevenue(rev as RevenueFromApi)}
                  onRefresh={fetchRevenues}
                  canManage={can('revenue:manage')}
                  canUnlock={isAdmin}
                />
              </>
            )}
          </CardContent>
        </Card>
      )}

      {/* Revenue Dialog for add/edit */}
      <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>
        <DialogContent className="max-w-2xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>
              {editingRevenue ? 'Chỉnh sửa thu nhập' : 'Thêm thu nhập mới'}
            </DialogTitle>
          </DialogHeader>
          <RevenueForm
            revenue={editingRevenue || undefined}
            requestId={request?.id}
            onSuccess={handleRevenueSuccess}
            onCancel={handleDialogClose}
          />
        </DialogContent>
      </Dialog>

      {/* Notes Section */}
      {request.notes && (
        <Card>
          <CardHeader>
            <CardTitle>Ghi chú</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="whitespace-pre-wrap text-sm">{request.notes}</p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}

/**
 * Simple label/value row for info display
 */
function InfoRow({ label, value }: { label: string; value: string }) {
  return (
    <div>
      <p className="text-sm text-muted-foreground">{label}</p>
      <p className="font-medium">{value}</p>
    </div>
  );
}
</file>

<file path="src/lib/google-sheets.ts">
/**
 * Google Sheets API Client
 *
 * Provides read-only access to Google Sheets for one-way sync.
 * Uses Service Account authentication.
 *
 * Required ENV vars:
 * - GOOGLE_SERVICE_ACCOUNT_EMAIL
 * - GOOGLE_PRIVATE_KEY
 * - SHEET_ID_REQUEST / SHEET_ID_OPERATOR / SHEET_ID_REVENUE (per-sheet)
 * - GOOGLE_SHEET_ID (fallback if all same)
 *
 * @example
 * import { getSheetData, getLastSyncedRow } from '@/lib/google-sheets';
 * const rows = await getSheetData('Request', 2);
 */

import { google } from "googleapis";
import { prisma } from "@/lib/db";

// Lazy initialization to avoid build-time errors when env vars not set
let sheetsClient: ReturnType<typeof google.sheets> | null = null;

/**
 * Parse private key handling various formats:
 * - Escaped newlines (\\n -> \n)
 * - Missing PEM headers (adds them if needed)
 */
function parsePrivateKey(key: string): string {
  // Handle escaped newlines from env vars
  let parsed = key.replace(/\\n/g, "\n");

  // Add PEM headers if missing (raw base64 key)
  if (!parsed.includes("-----BEGIN")) {
    parsed = `-----BEGIN PRIVATE KEY-----\n${parsed.trim()}\n-----END PRIVATE KEY-----`;
  }

  return parsed;
}

/**
 * Sheet configuration per type
 */
interface SheetConfig {
  spreadsheetId: string | undefined;
  tabName: string; // Actual tab name in Google Sheet (may differ from internal key)
  headerRow: number; // Row containing headers (data starts at headerRow + 1)
}

/**
 * Get configuration for a specific sheet type.
 * Includes spreadsheet ID, actual tab name, and header row.
 */
export function getSheetConfig(sheetName: string): SheetConfig {
  const configs: Record<string, SheetConfig> = {
    Request: {
      spreadsheetId: process.env.SHEET_ID_REQUEST,
      tabName: "Request",
      headerRow: 1, // Headers in row 1, data from row 2
    },
    Operator: {
      spreadsheetId: process.env.SHEET_ID_OPERATOR,
      tabName: "Operator_Mix", // Actual tab name differs from internal key
      headerRow: 1, // Headers in row 1, data from row 2
    },
    Revenue: {
      spreadsheetId: process.env.SHEET_ID_REVENUE,
      tabName: "Revenue",
      headerRow: 2, // Row 1 is blank, headers in row 2, data from row 3
    },
  };

  const config = configs[sheetName] || { spreadsheetId: undefined, tabName: sheetName, headerRow: 1 };
  config.spreadsheetId = config.spreadsheetId || process.env.GOOGLE_SHEET_ID;

  return config;
}

/**
 * Get spreadsheet ID for a specific sheet type.
 * Checks per-sheet env var first, falls back to GOOGLE_SHEET_ID.
 */
export function getSheetIdForType(sheetName: string): string {
  const config = getSheetConfig(sheetName);
  if (!config.spreadsheetId) {
    throw new Error(
      `No spreadsheet ID for ${sheetName}. Set SHEET_ID_${sheetName.toUpperCase()} or GOOGLE_SHEET_ID`
    );
  }
  return config.spreadsheetId;
}

/**
 * Get the data start row for a sheet (row after headers).
 */
export function getDataStartRow(sheetName: string): number {
  const config = getSheetConfig(sheetName);
  return config.headerRow + 1;
}

function getSheetsClient() {
  if (sheetsClient) return sheetsClient;

  const email = process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL;
  const privateKey = process.env.GOOGLE_PRIVATE_KEY;

  if (!email || !privateKey) {
    throw new Error(
      "Missing GOOGLE_SERVICE_ACCOUNT_EMAIL or GOOGLE_PRIVATE_KEY"
    );
  }

  const auth = new google.auth.GoogleAuth({
    credentials: {
      client_email: email,
      private_key: parsePrivateKey(privateKey),
    },
    scopes: ["https://www.googleapis.com/auth/spreadsheets.readonly"],
  });

  sheetsClient = google.sheets({ version: "v4", auth });
  return sheetsClient;
}

/**
 * Row data from Google Sheet
 */
export interface SheetRow {
  rowIndex: number;
  values: string[];
}

/**
 * Fetch data from a Google Sheet tab
 *
 * @param sheetName - Internal key (e.g., 'Request', 'Operator', 'Revenue')
 * @param startRow - Row to start from (default: 2, skips header)
 * @param spreadsheetId - Optional spreadsheet ID (defaults to getSheetIdForType)
 * @returns Array of SheetRow with rowIndex and values
 */
export async function getSheetData(
  sheetName: string,
  startRow: number = 2,
  spreadsheetId?: string
): Promise<SheetRow[]> {
  const config = getSheetConfig(sheetName);
  const sheetId = spreadsheetId || config.spreadsheetId;
  if (!sheetId) {
    throw new Error(`No spreadsheet ID for ${sheetName}`);
  }
  const sheets = getSheetsClient();

  // Use tabName from config (may differ from internal sheetName key)
  const response = await sheets.spreadsheets.values.get({
    spreadsheetId: sheetId,
    range: `${config.tabName}!A${startRow}:AZ`,
  });

  const rows = response.data.values || [];

  return rows.map((values, idx) => ({
    rowIndex: startRow + idx,
    values: values as string[],
  }));
}

/**
 * Get the last successfully synced row for a sheet
 *
 * @param sheetName - Tab name to check
 * @returns Last synced rowIndex, or (headerRow) if no prior sync
 */
export async function getLastSyncedRow(sheetName: string): Promise<number> {
  const lastSync = await prisma.syncLog.findFirst({
    where: { sheetName, status: "SUCCESS" },
    orderBy: { rowIndex: "desc" },
  });

  if (lastSync && lastSync.rowIndex !== null) {
    return lastSync.rowIndex;
  }

  // Return headerRow so next fetch starts from data row (headerRow + 1)
  const config = getSheetConfig(sheetName);
  return config.headerRow;
}

/**
 * Get sheet headers (first row)
 *
 * @param sheetName - Internal key (e.g., 'Request', 'Operator', 'Revenue')
 * @param spreadsheetId - Optional spreadsheet ID (defaults to getSheetIdForType)
 * @returns Array of header column names
 */
export async function getSheetHeaders(
  sheetName: string,
  spreadsheetId?: string
): Promise<string[]> {
  const config = getSheetConfig(sheetName);
  const sheetId = spreadsheetId || config.spreadsheetId;
  if (!sheetId) {
    throw new Error(`No spreadsheet ID for ${sheetName}`);
  }
  const sheets = getSheetsClient();

  // Use tabName from config and headerRow for correct header position
  const response = await sheets.spreadsheets.values.get({
    spreadsheetId: sheetId,
    range: `${config.tabName}!A${config.headerRow}:AZ${config.headerRow}`,
  });

  return (response.data.values?.[0] as string[]) || [];
}

/**
 * Check if Google Sheets API is configured (at least one sheet has ID)
 */
export function isGoogleSheetsConfigured(): boolean {
  const hasCredentials = !!(
    process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL &&
    process.env.GOOGLE_PRIVATE_KEY
  );

  const hasAnySheetId = !!(
    process.env.SHEET_ID_REQUEST ||
    process.env.SHEET_ID_OPERATOR ||
    process.env.SHEET_ID_REVENUE ||
    process.env.GOOGLE_SHEET_ID
  );

  return hasCredentials && hasAnySheetId;
}

/**
 * Get per-sheet configuration status
 * @returns Object with sheet names as keys and configured status as values
 */
export function getSheetConfigStatus(): Record<string, boolean> {
  return {
    Request: !!(process.env.SHEET_ID_REQUEST || process.env.GOOGLE_SHEET_ID),
    Operator: !!(process.env.SHEET_ID_OPERATOR || process.env.GOOGLE_SHEET_ID),
    Revenue: !!(process.env.SHEET_ID_REVENUE || process.env.GOOGLE_SHEET_ID),
  };
}
</file>

<file path="src/types/index.ts">
// ============================================
// Type Definitions for MyVivaTour Platform
// ============================================

// User types
export type Role = 'ADMIN' | 'SELLER' | 'ACCOUNTANT';

export interface User {
  id: string;
  email: string;
  name: string | null;
  role: Role;
  avatar: string | null;
}

// Seller types
export type Gender = 'MALE' | 'FEMALE';

export interface Seller {
  id: string;
  telegramId: string;
  sellerName: string;
  sheetName: string;
  metaName: string | null;
  email: string | null;
  gender: Gender;
  sellerCode: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// FollowUpStatus types
export interface FollowUpStatus {
  id: string;
  status: string;
  aliases: string[];
  daysToFollowup: number;
  sortOrder: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// Request types - Re-export from config
export {
  REQUEST_STAGES,
  REQUEST_STATUSES,
  REQUEST_STAGE_KEYS,
  REQUEST_STATUS_KEYS,
  FOLLOWUP_STATUSES,
  getStatusesByStage,
  getStageFromStatus,
  isFollowUpStatus,
  getStatusLabel,
  getStageLabel,
  getStatusColor,
  getStatusesGroupedByStage,
  type RequestStage,
  type RequestStatus,
} from '@/config/request-config';

export interface Request {
  id: string;
  code: string;
  rqid: string | null;
  bookingCode: string | null;
  customerName: string;
  contact: string;
  whatsapp: string | null;
  pax: number;
  country: string;
  source: string;
  status: string;
  stage: string;
  tourDays: number | null;
  startDate: Date | null;
  endDate: Date | null;
  expectedDate: Date | null;
  expectedRevenue: number | null;
  expectedCost: number | null;
  requestDate: Date;
  receivedDate: Date;
  lastContactDate: Date | null;
  nextFollowUp: Date | null;
  statusChangedAt: Date | null;
  statusChangedBy: string | null;
  notes: string | null;
  sellerId: string;
  seller?: User;
  sheetRowIndex: number | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface RequestFormData {
  customerName: string;
  contact: string;
  whatsapp?: string;
  pax: number;
  country: string;
  source: string;
  status: string;
  tourDays?: number;
  startDate?: string;
  expectedDate?: string;
  expectedRevenue?: number;
  expectedCost?: number;
  lastContactDate?: string;
  notes?: string;
}

// Config types
export interface ConfigFollowUp {
  id: string;
  stage: string;
  daysToWait: number;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface ConfigUser {
  id: string;
  userId: string;
  user?: User;
  sellerCode: string;
  canViewAll: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// Operator types
export type PaymentStatus = 'PENDING' | 'PAID' | 'PARTIAL';

export interface Operator {
  id: string;
  requestId: string;
  request?: Request;
  supplierId: string | null;
  supplierRef?: Supplier;
  serviceId: string | null; // Business ID: {bookingCode}-{timestamp}
  serviceDate: Date;
  serviceType: string;
  serviceName: string;
  supplier: string | null; // Legacy field - supplier name text
  costBeforeTax: number;
  vat: number | null;
  totalCost: number;
  paymentDeadline: Date | null;
  paymentStatus: PaymentStatus;
  paymentDate: Date | null;
  paidAmount: number;  // V - Số tiền đã thanh toán
  // debt = totalCost - paidAmount (computed on read)
  bankAccount: string | null;
  // 3-tier lock system
  lockKT: boolean;
  lockKTAt: Date | null;
  lockKTBy: string | null;
  lockAdmin: boolean;
  lockAdminAt: Date | null;
  lockAdminBy: string | null;
  lockFinal: boolean;
  lockFinalAt: Date | null;
  lockFinalBy: string | null;
  // Legacy lock fields (deprecated, kept for backward compatibility)
  isLocked: boolean;
  lockedAt: Date | null;
  lockedBy: string | null;
  // Archive status
  isArchived: boolean;
  archivedAt: Date | null;
  notes: string | null;
  userId: string;
  sheetRowIndex: number | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface OperatorFormData {
  requestId: string;
  supplierId?: string;
  serviceDate: string;
  serviceType: string;
  serviceName: string;
  supplier?: string;
  costBeforeTax: number;
  vat?: number;
  totalCost: number;
  paymentDeadline?: string;
  paidAmount?: number;  // V - Số tiền đã thanh toán
  bankAccount?: string;
  notes?: string;
}

// Operator with computed debt
export interface OperatorWithDebt extends Operator {
  debt: number;  // W = totalCost - paidAmount
}

// Revenue types
export interface Revenue {
  id: string;
  revenueId: string | null; // Business ID: {bookingCode}-{timestamp}-{row}
  requestId: string;
  request?: Request;
  paymentDate: Date;
  paymentType: string;
  foreignAmount: number | null;
  currency: string | null;
  exchangeRate: number | null;
  amountVND: number;
  paymentSource: string;
  // 3-tier lock system
  lockKT: boolean;
  lockKTAt: Date | null;
  lockKTBy: string | null;
  lockAdmin: boolean;
  lockAdminAt: Date | null;
  lockAdminBy: string | null;
  lockFinal: boolean;
  lockFinalAt: Date | null;
  lockFinalBy: string | null;
  // Legacy lock fields (deprecated, kept for backward compatibility)
  isLocked: boolean;
  lockedAt: Date | null;
  lockedBy: string | null;
  notes: string | null;
  userId: string;
  sheetRowIndex: number | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface RevenueFormData {
  requestId: string;
  paymentDate: string;
  paymentType: string;
  foreignAmount?: number;
  currency?: string;
  exchangeRate?: number;
  amountVND: number;
  paymentSource: string;
  notes?: string;
}

// Email types
export interface Email {
  id: string;
  gmailId: string;
  requestId: string | null;
  from: string;
  to: string;
  subject: string;
  body: string;
  date: Date;
  isRead: boolean;
  isReplied: boolean;
  aiSummary: string | null;
  aiSuggestedReply: string | null;
}

// Knowledge Base types
export interface KnowledgeItem {
  id: string;
  category: string;
  title: string;
  content: string;
  keywords: string[];
  isActive: boolean;
}

// Dashboard types
export interface DashboardStats {
  totalRevenue: number;
  totalCost: number;
  newRequests: number;
  activeBookings: number;
  revenueChange: number;
  costChange: number;
  requestChange: number;
  bookingChange: number;
}

export interface FollowUpItem {
  id: string;
  rqid: string | null;
  customerName: string;
  country: string;
  overdueDays: number;
  status: string;
  stage: string;
  contact: string;
  nextFollowUp: Date | null;
}

export interface RecentEmail {
  id: string;
  from: string;
  subject: string;
  date: Date;
  isRead: boolean;
  requestCode: string | null;
}

// Filter types
export interface RequestFilters {
  search?: string;
  seller?: string;
  status?: string;
  stage?: string;
  source?: string;
  country?: string;
  fromDate?: string;
  toDate?: string;
  followup?: 'overdue' | 'today' | 'upcoming';
}

export interface BookingFilters {
  search?: string;
  seller?: string;
  startMonth?: string;
  endMonth?: string;
}

// API Response types
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
  message?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

// Dropdown options
export interface DropdownOptions {
  countries: string[];
  sources: string[];
  statuses: string[];
  serviceTypes: string[];
  paymentTypes: string[];
  paymentSources: string[];
  currencies: string[];
  sellers: string[];
}

// ============================================
// SUPPLIER TYPES (NCC - Nhà Cung Cấp)
// ============================================

export type PaymentModel = 'PREPAID' | 'PAY_PER_USE' | 'CREDIT';
export type TransactionType = 'DEPOSIT' | 'REFUND' | 'ADJUSTMENT' | 'FEE';

// Re-export from config for backward compatibility
export {
  SUPPLIER_TYPES,
  SUPPLIER_TYPE_KEYS,
  SUPPLIER_LOCATIONS,
  SUPPLIER_LOCATION_KEYS,
  PAYMENT_MODELS,
  generateSupplierCode,
  CUSTOM_LOCATION,
  type SupplierTypeKey,
  type SupplierLocationKey,
  type PaymentModelKey,
} from '@/config/supplier-config';

export interface Supplier {
  id: string;
  code: string;
  name: string;
  type: string;
  location: string | null;  // Location key or custom value
  paymentModel: PaymentModel;
  creditLimit: number | null;
  paymentTermDays: number | null;
  contactName: string | null;
  contactPhone: string | null;
  contactEmail: string | null;
  bankAccount: string | null;
  isActive: boolean;
  notes: string | null;
  createdAt: Date;
  updatedAt: Date;
  // Computed (from API)
  balance?: number;
  transactions?: SupplierTransaction[];
  operators?: Operator[];
}

export interface SupplierFormData {
  code: string;
  name: string;
  type: string;
  location?: string;
  paymentModel: PaymentModel;
  creditLimit?: number;
  paymentTermDays?: number;
  contactName?: string;
  contactPhone?: string;
  contactEmail?: string;
  bankAccount?: string;
  isActive?: boolean;
  notes?: string;
}

export interface SupplierTransaction {
  id: string;
  supplierId: string;
  supplier?: Supplier;
  type: TransactionType;
  amount: number;
  transactionDate: Date;
  description: string | null;
  proofLink: string | null;
  relatedBookingCode: string | null;
  createdBy: string;
  createdAt: Date;
}

export interface SupplierTransactionFormData {
  supplierId: string;
  type: TransactionType;
  amount: number;
  transactionDate: string;
  description?: string;
  proofLink?: string;
  relatedBookingCode?: string;
}

// Balance & Reports
export interface SupplierBalance {
  deposits: number;
  refunds: number;
  adjustments: number;
  fees: number;
  costs: number;
  balance: number;
}

export interface SupplierBalanceSummary {
  id: string;
  code: string;
  name: string;
  type: string;
  paymentModel: PaymentModel;
  totalDeposits: number;
  totalCosts: number;
  totalRefunds: number;
  balance: number;
  isActive: boolean;
}

export interface SupplierFilters {
  search?: string;
  type?: string;
  paymentModel?: PaymentModel;
  isActive?: boolean;
}

// ============================================
// OPERATOR TYPES (Dịch vụ/Chi phí)
// ============================================

// Re-export from config for consistency
export {
  SERVICE_TYPES,
  SERVICE_TYPE_KEYS,
  PAYMENT_STATUSES,
  PAYMENT_STATUS_KEYS,
  HISTORY_ACTIONS,
  DEFAULT_VAT_RATE,
  type ServiceTypeKey,
  type PaymentStatusKey,
  type HistoryActionKey,
} from '@/config/operator-config';

// Operator filters
export interface OperatorFilters {
  search?: string;
  requestId?: string;
  supplierId?: string;
  serviceType?: string;
  paymentStatus?: string;  // Relaxed to string for form state
  fromDate?: string;
  toDate?: string;
  isLocked?: boolean;
  includeArchived?: boolean;
}

// Operator history entry (includes 3-tier lock actions)
export interface OperatorHistoryEntry {
  id: string;
  operatorId: string;
  action:
    | 'CREATE'
    | 'UPDATE'
    | 'DELETE'
    | 'LOCK'
    | 'UNLOCK'
    | 'ARCHIVE'
    | 'UNARCHIVE'
    | 'LOCK_KT'
    | 'UNLOCK_KT'
    | 'LOCK_ADMIN'
    | 'UNLOCK_ADMIN'
    | 'LOCK_FINAL'
    | 'UNLOCK_FINAL'
    | 'APPROVE';
  changes: Record<string, { before: unknown; after: unknown } | unknown>;
  userId: string;
  createdAt: Date;
}

// Approval queue item (for Phase 2)
export interface ApprovalQueueItem {
  id: string;
  requestCode: string;
  customerName: string;
  serviceDate: Date;
  serviceType: string;
  serviceName: string;
  supplierName: string | null;
  totalCost: number;
  paidAmount: number;
  debt: number;  // W = totalCost - paidAmount
  paymentStatus: PaymentStatus;
  paymentDeadline: Date | null;
  daysOverdue: number;
  isLocked: boolean;
}

// ============================================
// OPERATOR REPORT TYPES (Phase 4)
// ============================================

// Cost by service type
export interface CostByServiceType {
  type: string;
  label: string;
  total: number;
  count: number;
}

// Cost by supplier
export interface CostBySupplier {
  supplierId: string | null;
  supplierName: string;
  total: number;
  count: number;
}

// Cost by month
export interface CostByMonth {
  month: string; // YYYY-MM format
  total: number;
  count: number;
}

// Cost report summary
export interface CostReportSummary {
  totalCost: number;
  totalCount: number;
  avgCost: number;
}

// Full operator cost report
export interface OperatorCostReport {
  byServiceType: CostByServiceType[];
  bySupplier: CostBySupplier[];
  byMonth: CostByMonth[];
  summary: CostReportSummary;
}

// Payment status report
export interface PaymentStatusReport {
  pending: { count: number; total: number };
  dueThisWeek: { count: number; total: number };
  overdue: { count: number; total: number };
  paidThisMonth: { count: number; total: number };
}

// ============================================
// PROFIT REPORT TYPES
// ============================================

// Profit data per booking
export interface ProfitByBooking {
  bookingCode: string;
  customerName: string;
  totalCost: number;
  totalRevenue: number;
  profit: number;
  profitMargin: number; // percentage
}

// Profit report summary
export interface ProfitReportSummary {
  totalCost: number;
  totalRevenue: number;
  totalProfit: number;
  avgProfitMargin: number;
  bookingCount: number;
}

// Full profit report
export interface ProfitReport {
  bookings: ProfitByBooking[];
  summary: ProfitReportSummary;
}

// ============================================
// SALES AGGREGATION TYPES (Revenue by Booking)
// ============================================

// Sale item - aggregated revenue per booking
export interface SaleItem {
  bookingCode: string;
  customerName: string;
  totalRevenue: number;  // SUM(amountVND) from Revenue
  totalCost: number;     // SUM(totalCost) from Operator
  profit: number;        // totalRevenue - totalCost
  revenueCount: number;  // Number of revenue records
  startDate: Date | null;
  endDate: Date | null;
}

// Sales summary statistics
export interface SalesSummary {
  totalRevenue: number;
  totalCost: number;
  totalProfit: number;
  bookingCount: number;
}

// Sales API response
export interface SalesResponse {
  sales: SaleItem[];
  summary: SalesSummary;
}
</file>

</files>
